
/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */

#include "qmi-enum-types.h"
/* enumerations from "../../../src/libqmi-glib/qmi-device.h" */
static const GFlagsValue qmi_device_open_flags_values[] = {
    { QMI_DEVICE_OPEN_FLAGS_NONE, "QMI_DEVICE_OPEN_FLAGS_NONE", "none" },
    { QMI_DEVICE_OPEN_FLAGS_VERSION_INFO, "QMI_DEVICE_OPEN_FLAGS_VERSION_INFO", "version-info" },
    { QMI_DEVICE_OPEN_FLAGS_SYNC, "QMI_DEVICE_OPEN_FLAGS_SYNC", "sync" },
    { QMI_DEVICE_OPEN_FLAGS_NET_802_3, "QMI_DEVICE_OPEN_FLAGS_NET_802_3", "net-802-3" },
    { QMI_DEVICE_OPEN_FLAGS_NET_RAW_IP, "QMI_DEVICE_OPEN_FLAGS_NET_RAW_IP", "net-raw-ip" },
    { QMI_DEVICE_OPEN_FLAGS_NET_QOS_HEADER, "QMI_DEVICE_OPEN_FLAGS_NET_QOS_HEADER", "net-qos-header" },
    { QMI_DEVICE_OPEN_FLAGS_NET_NO_QOS_HEADER, "QMI_DEVICE_OPEN_FLAGS_NET_NO_QOS_HEADER", "net-no-qos-header" },
    { QMI_DEVICE_OPEN_FLAGS_PROXY, "QMI_DEVICE_OPEN_FLAGS_PROXY", "proxy" },
    { QMI_DEVICE_OPEN_FLAGS_MBIM, "QMI_DEVICE_OPEN_FLAGS_MBIM", "mbim" },
    { QMI_DEVICE_OPEN_FLAGS_AUTO, "QMI_DEVICE_OPEN_FLAGS_AUTO", "auto" },
    { QMI_DEVICE_OPEN_FLAGS_EXPECT_INDICATIONS, "QMI_DEVICE_OPEN_FLAGS_EXPECT_INDICATIONS", "expect-indications" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_device_open_flags_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiDeviceOpenFlags"),
                                      qmi_device_open_flags_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DEVICE_OPEN_FLAGS_IS_ENUM__
const gchar *
qmi_device_open_flags_get_string (QmiDeviceOpenFlags val)
{
    guint i;

    for (i = 0; qmi_device_open_flags_values[i].value_nick; i++) {
      if ((gint)val == qmi_device_open_flags_values[i].value)
            return qmi_device_open_flags_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DEVICE_OPEN_FLAGS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DEVICE_OPEN_FLAGS_IS_FLAGS__
gchar *
qmi_device_open_flags_build_string_from_mask (QmiDeviceOpenFlags mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_device_open_flags_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_device_open_flags_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_device_open_flags_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_device_open_flags_values[i].value) {
            guint c;
            gulong number = qmi_device_open_flags_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_device_open_flags_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DEVICE_OPEN_FLAGS_IS_FLAGS__ */
static const GFlagsValue qmi_device_release_client_flags_values[] = {
    { QMI_DEVICE_RELEASE_CLIENT_FLAGS_NONE, "QMI_DEVICE_RELEASE_CLIENT_FLAGS_NONE", "none" },
    { QMI_DEVICE_RELEASE_CLIENT_FLAGS_RELEASE_CID, "QMI_DEVICE_RELEASE_CLIENT_FLAGS_RELEASE_CID", "release-cid" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_device_release_client_flags_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiDeviceReleaseClientFlags"),
                                      qmi_device_release_client_flags_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DEVICE_RELEASE_CLIENT_FLAGS_IS_ENUM__
const gchar *
qmi_device_release_client_flags_get_string (QmiDeviceReleaseClientFlags val)
{
    guint i;

    for (i = 0; qmi_device_release_client_flags_values[i].value_nick; i++) {
      if ((gint)val == qmi_device_release_client_flags_values[i].value)
            return qmi_device_release_client_flags_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DEVICE_RELEASE_CLIENT_FLAGS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DEVICE_RELEASE_CLIENT_FLAGS_IS_FLAGS__
gchar *
qmi_device_release_client_flags_build_string_from_mask (QmiDeviceReleaseClientFlags mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_device_release_client_flags_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_device_release_client_flags_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_device_release_client_flags_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_device_release_client_flags_values[i].value) {
            guint c;
            gulong number = qmi_device_release_client_flags_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_device_release_client_flags_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DEVICE_RELEASE_CLIENT_FLAGS_IS_FLAGS__ */
static const GEnumValue qmi_device_expected_data_format_values[] = {
    { QMI_DEVICE_EXPECTED_DATA_FORMAT_UNKNOWN, "QMI_DEVICE_EXPECTED_DATA_FORMAT_UNKNOWN", "unknown" },
    { QMI_DEVICE_EXPECTED_DATA_FORMAT_802_3, "QMI_DEVICE_EXPECTED_DATA_FORMAT_802_3", "802-3" },
    { QMI_DEVICE_EXPECTED_DATA_FORMAT_RAW_IP, "QMI_DEVICE_EXPECTED_DATA_FORMAT_RAW_IP", "raw-ip" },
    { QMI_DEVICE_EXPECTED_DATA_FORMAT_QMAP_PASS_THROUGH, "QMI_DEVICE_EXPECTED_DATA_FORMAT_QMAP_PASS_THROUGH", "qmap-pass-through" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_device_expected_data_format_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDeviceExpectedDataFormat"),
                                      qmi_device_expected_data_format_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DEVICE_EXPECTED_DATA_FORMAT_IS_ENUM__
const gchar *
qmi_device_expected_data_format_get_string (QmiDeviceExpectedDataFormat val)
{
    guint i;

    for (i = 0; qmi_device_expected_data_format_values[i].value_nick; i++) {
      if ((gint)val == qmi_device_expected_data_format_values[i].value)
            return qmi_device_expected_data_format_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DEVICE_EXPECTED_DATA_FORMAT_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DEVICE_EXPECTED_DATA_FORMAT_IS_FLAGS__
gchar *
qmi_device_expected_data_format_build_string_from_mask (QmiDeviceExpectedDataFormat mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_device_expected_data_format_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_device_expected_data_format_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_device_expected_data_format_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_device_expected_data_format_values[i].value) {
            guint c;
            gulong number = qmi_device_expected_data_format_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_device_expected_data_format_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DEVICE_EXPECTED_DATA_FORMAT_IS_FLAGS__ */
static const GFlagsValue qmi_device_add_link_flags_values[] = {
    { QMI_DEVICE_ADD_LINK_FLAGS_NONE, "QMI_DEVICE_ADD_LINK_FLAGS_NONE", "none" },
    { QMI_DEVICE_ADD_LINK_FLAGS_INGRESS_MAP_CKSUMV4, "QMI_DEVICE_ADD_LINK_FLAGS_INGRESS_MAP_CKSUMV4", "ingress-map-cksumv4" },
    { QMI_DEVICE_ADD_LINK_FLAGS_EGRESS_MAP_CKSUMV4, "QMI_DEVICE_ADD_LINK_FLAGS_EGRESS_MAP_CKSUMV4", "egress-map-cksumv4" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_device_add_link_flags_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiDeviceAddLinkFlags"),
                                      qmi_device_add_link_flags_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DEVICE_ADD_LINK_FLAGS_IS_ENUM__
const gchar *
qmi_device_add_link_flags_get_string (QmiDeviceAddLinkFlags val)
{
    guint i;

    for (i = 0; qmi_device_add_link_flags_values[i].value_nick; i++) {
      if ((gint)val == qmi_device_add_link_flags_values[i].value)
            return qmi_device_add_link_flags_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DEVICE_ADD_LINK_FLAGS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DEVICE_ADD_LINK_FLAGS_IS_FLAGS__
gchar *
qmi_device_add_link_flags_build_string_from_mask (QmiDeviceAddLinkFlags mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_device_add_link_flags_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_device_add_link_flags_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_device_add_link_flags_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_device_add_link_flags_values[i].value) {
            guint c;
            gulong number = qmi_device_add_link_flags_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_device_add_link_flags_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DEVICE_ADD_LINK_FLAGS_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-dms.h" */
static const GEnumValue qmi_dms_data_service_capability_values[] = {
    { QMI_DMS_DATA_SERVICE_CAPABILITY_NONE, "QMI_DMS_DATA_SERVICE_CAPABILITY_NONE", "none" },
    { QMI_DMS_DATA_SERVICE_CAPABILITY_CS, "QMI_DMS_DATA_SERVICE_CAPABILITY_CS", "cs" },
    { QMI_DMS_DATA_SERVICE_CAPABILITY_PS, "QMI_DMS_DATA_SERVICE_CAPABILITY_PS", "ps" },
    { QMI_DMS_DATA_SERVICE_CAPABILITY_SIMULTANEOUS_CS_PS, "QMI_DMS_DATA_SERVICE_CAPABILITY_SIMULTANEOUS_CS_PS", "simultaneous-cs-ps" },
    { QMI_DMS_DATA_SERVICE_CAPABILITY_NON_SIMULTANEOUS_CS_PS, "QMI_DMS_DATA_SERVICE_CAPABILITY_NON_SIMULTANEOUS_CS_PS", "non-simultaneous-cs-ps" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_data_service_capability_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsDataServiceCapability"),
                                      qmi_dms_data_service_capability_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_DATA_SERVICE_CAPABILITY_IS_ENUM__
const gchar *
qmi_dms_data_service_capability_get_string (QmiDmsDataServiceCapability val)
{
    guint i;

    for (i = 0; qmi_dms_data_service_capability_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_data_service_capability_values[i].value)
            return qmi_dms_data_service_capability_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_DATA_SERVICE_CAPABILITY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_DATA_SERVICE_CAPABILITY_IS_FLAGS__
gchar *
qmi_dms_data_service_capability_build_string_from_mask (QmiDmsDataServiceCapability mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_data_service_capability_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_data_service_capability_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_data_service_capability_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_data_service_capability_values[i].value) {
            guint c;
            gulong number = qmi_dms_data_service_capability_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_data_service_capability_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_DATA_SERVICE_CAPABILITY_IS_FLAGS__ */
static const GEnumValue qmi_dms_sim_capability_values[] = {
    { QMI_DMS_SIM_CAPABILITY_NOT_SUPPORTED, "QMI_DMS_SIM_CAPABILITY_NOT_SUPPORTED", "not-supported" },
    { QMI_DMS_SIM_CAPABILITY_SUPPORTED, "QMI_DMS_SIM_CAPABILITY_SUPPORTED", "supported" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_sim_capability_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsSimCapability"),
                                      qmi_dms_sim_capability_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_SIM_CAPABILITY_IS_ENUM__
const gchar *
qmi_dms_sim_capability_get_string (QmiDmsSimCapability val)
{
    guint i;

    for (i = 0; qmi_dms_sim_capability_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_sim_capability_values[i].value)
            return qmi_dms_sim_capability_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_SIM_CAPABILITY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_SIM_CAPABILITY_IS_FLAGS__
gchar *
qmi_dms_sim_capability_build_string_from_mask (QmiDmsSimCapability mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_sim_capability_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_sim_capability_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_sim_capability_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_sim_capability_values[i].value) {
            guint c;
            gulong number = qmi_dms_sim_capability_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_sim_capability_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_SIM_CAPABILITY_IS_FLAGS__ */
static const GEnumValue qmi_dms_radio_interface_values[] = {
    { QMI_DMS_RADIO_INTERFACE_CDMA20001X, "QMI_DMS_RADIO_INTERFACE_CDMA20001X", "cdma20001x" },
    { QMI_DMS_RADIO_INTERFACE_EVDO, "QMI_DMS_RADIO_INTERFACE_EVDO", "evdo" },
    { QMI_DMS_RADIO_INTERFACE_GSM, "QMI_DMS_RADIO_INTERFACE_GSM", "gsm" },
    { QMI_DMS_RADIO_INTERFACE_UMTS, "QMI_DMS_RADIO_INTERFACE_UMTS", "umts" },
    { QMI_DMS_RADIO_INTERFACE_LTE, "QMI_DMS_RADIO_INTERFACE_LTE", "lte" },
    { QMI_DMS_RADIO_INTERFACE_5GNR, "QMI_DMS_RADIO_INTERFACE_5GNR", "5gnr" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_radio_interface_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsRadioInterface"),
                                      qmi_dms_radio_interface_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_RADIO_INTERFACE_IS_ENUM__
const gchar *
qmi_dms_radio_interface_get_string (QmiDmsRadioInterface val)
{
    guint i;

    for (i = 0; qmi_dms_radio_interface_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_radio_interface_values[i].value)
            return qmi_dms_radio_interface_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_RADIO_INTERFACE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_RADIO_INTERFACE_IS_FLAGS__
gchar *
qmi_dms_radio_interface_build_string_from_mask (QmiDmsRadioInterface mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_radio_interface_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_radio_interface_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_radio_interface_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_radio_interface_values[i].value) {
            guint c;
            gulong number = qmi_dms_radio_interface_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_radio_interface_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_RADIO_INTERFACE_IS_FLAGS__ */
static const GFlagsValue qmi_dms_power_state_values[] = {
    { QMI_DMS_POWER_STATE_EXTERNAL_SOURCE, "QMI_DMS_POWER_STATE_EXTERNAL_SOURCE", "external-source" },
    { QMI_DMS_POWER_STATE_BATTERY_CONNECTED, "QMI_DMS_POWER_STATE_BATTERY_CONNECTED", "battery-connected" },
    { QMI_DMS_POWER_STATE_BATTERY_CHARGING, "QMI_DMS_POWER_STATE_BATTERY_CHARGING", "battery-charging" },
    { QMI_DMS_POWER_STATE_FAULT, "QMI_DMS_POWER_STATE_FAULT", "fault" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_power_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiDmsPowerState"),
                                      qmi_dms_power_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_POWER_STATE_IS_ENUM__
const gchar *
qmi_dms_power_state_get_string (QmiDmsPowerState val)
{
    guint i;

    for (i = 0; qmi_dms_power_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_power_state_values[i].value)
            return qmi_dms_power_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_POWER_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_POWER_STATE_IS_FLAGS__
gchar *
qmi_dms_power_state_build_string_from_mask (QmiDmsPowerState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_power_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_power_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_power_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_power_state_values[i].value) {
            guint c;
            gulong number = qmi_dms_power_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_power_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_POWER_STATE_IS_FLAGS__ */
static const GEnumValue qmi_dms_uim_pin_id_values[] = {
    { QMI_DMS_UIM_PIN_ID_PIN, "QMI_DMS_UIM_PIN_ID_PIN", "pin" },
    { QMI_DMS_UIM_PIN_ID_PIN2, "QMI_DMS_UIM_PIN_ID_PIN2", "pin2" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_uim_pin_id_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsUimPinId"),
                                      qmi_dms_uim_pin_id_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_UIM_PIN_ID_IS_ENUM__
const gchar *
qmi_dms_uim_pin_id_get_string (QmiDmsUimPinId val)
{
    guint i;

    for (i = 0; qmi_dms_uim_pin_id_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_uim_pin_id_values[i].value)
            return qmi_dms_uim_pin_id_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_UIM_PIN_ID_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_UIM_PIN_ID_IS_FLAGS__
gchar *
qmi_dms_uim_pin_id_build_string_from_mask (QmiDmsUimPinId mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_uim_pin_id_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_uim_pin_id_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_uim_pin_id_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_uim_pin_id_values[i].value) {
            guint c;
            gulong number = qmi_dms_uim_pin_id_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_uim_pin_id_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_UIM_PIN_ID_IS_FLAGS__ */
static const GEnumValue qmi_dms_uim_pin_status_values[] = {
    { QMI_DMS_UIM_PIN_STATUS_NOT_INITIALIZED, "QMI_DMS_UIM_PIN_STATUS_NOT_INITIALIZED", "not-initialized" },
    { QMI_DMS_UIM_PIN_STATUS_ENABLED_NOT_VERIFIED, "QMI_DMS_UIM_PIN_STATUS_ENABLED_NOT_VERIFIED", "enabled-not-verified" },
    { QMI_DMS_UIM_PIN_STATUS_ENABLED_VERIFIED, "QMI_DMS_UIM_PIN_STATUS_ENABLED_VERIFIED", "enabled-verified" },
    { QMI_DMS_UIM_PIN_STATUS_DISABLED, "QMI_DMS_UIM_PIN_STATUS_DISABLED", "disabled" },
    { QMI_DMS_UIM_PIN_STATUS_BLOCKED, "QMI_DMS_UIM_PIN_STATUS_BLOCKED", "blocked" },
    { QMI_DMS_UIM_PIN_STATUS_PERMANENTLY_BLOCKED, "QMI_DMS_UIM_PIN_STATUS_PERMANENTLY_BLOCKED", "permanently-blocked" },
    { QMI_DMS_UIM_PIN_STATUS_UNBLOCKED, "QMI_DMS_UIM_PIN_STATUS_UNBLOCKED", "unblocked" },
    { QMI_DMS_UIM_PIN_STATUS_CHANGED, "QMI_DMS_UIM_PIN_STATUS_CHANGED", "changed" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_uim_pin_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsUimPinStatus"),
                                      qmi_dms_uim_pin_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_UIM_PIN_STATUS_IS_ENUM__
const gchar *
qmi_dms_uim_pin_status_get_string (QmiDmsUimPinStatus val)
{
    guint i;

    for (i = 0; qmi_dms_uim_pin_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_uim_pin_status_values[i].value)
            return qmi_dms_uim_pin_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_UIM_PIN_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_UIM_PIN_STATUS_IS_FLAGS__
gchar *
qmi_dms_uim_pin_status_build_string_from_mask (QmiDmsUimPinStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_uim_pin_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_uim_pin_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_uim_pin_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_uim_pin_status_values[i].value) {
            guint c;
            gulong number = qmi_dms_uim_pin_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_uim_pin_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_UIM_PIN_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_dms_operating_mode_values[] = {
    { QMI_DMS_OPERATING_MODE_ONLINE, "QMI_DMS_OPERATING_MODE_ONLINE", "online" },
    { QMI_DMS_OPERATING_MODE_LOW_POWER, "QMI_DMS_OPERATING_MODE_LOW_POWER", "low-power" },
    { QMI_DMS_OPERATING_MODE_FACTORY_TEST, "QMI_DMS_OPERATING_MODE_FACTORY_TEST", "factory-test" },
    { QMI_DMS_OPERATING_MODE_OFFLINE, "QMI_DMS_OPERATING_MODE_OFFLINE", "offline" },
    { QMI_DMS_OPERATING_MODE_RESET, "QMI_DMS_OPERATING_MODE_RESET", "reset" },
    { QMI_DMS_OPERATING_MODE_SHUTTING_DOWN, "QMI_DMS_OPERATING_MODE_SHUTTING_DOWN", "shutting-down" },
    { QMI_DMS_OPERATING_MODE_PERSISTENT_LOW_POWER, "QMI_DMS_OPERATING_MODE_PERSISTENT_LOW_POWER", "persistent-low-power" },
    { QMI_DMS_OPERATING_MODE_MODE_ONLY_LOW_POWER, "QMI_DMS_OPERATING_MODE_MODE_ONLY_LOW_POWER", "mode-only-low-power" },
    { QMI_DMS_OPERATING_MODE_UNKNOWN, "QMI_DMS_OPERATING_MODE_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_operating_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsOperatingMode"),
                                      qmi_dms_operating_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_OPERATING_MODE_IS_ENUM__
const gchar *
qmi_dms_operating_mode_get_string (QmiDmsOperatingMode val)
{
    guint i;

    for (i = 0; qmi_dms_operating_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_operating_mode_values[i].value)
            return qmi_dms_operating_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_OPERATING_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_OPERATING_MODE_IS_FLAGS__
gchar *
qmi_dms_operating_mode_build_string_from_mask (QmiDmsOperatingMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_operating_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_operating_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_operating_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_operating_mode_values[i].value) {
            guint c;
            gulong number = qmi_dms_operating_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_operating_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_OPERATING_MODE_IS_FLAGS__ */
static const GFlagsValue qmi_dms_offline_reason_values[] = {
    { QMI_DMS_OFFLINE_REASON_HOST_IMAGE_MISCONFIGURATION, "QMI_DMS_OFFLINE_REASON_HOST_IMAGE_MISCONFIGURATION", "host-image-misconfiguration" },
    { QMI_DMS_OFFLINE_REASON_PRI_IMAGE_MISCONFIGURATION, "QMI_DMS_OFFLINE_REASON_PRI_IMAGE_MISCONFIGURATION", "pri-image-misconfiguration" },
    { QMI_DMS_OFFLINE_REASON_PRI_VERSION_INCOMPATIBLE, "QMI_DMS_OFFLINE_REASON_PRI_VERSION_INCOMPATIBLE", "pri-version-incompatible" },
    { QMI_DMS_OFFLINE_REASON_DEVICE_MEMORY_FULL, "QMI_DMS_OFFLINE_REASON_DEVICE_MEMORY_FULL", "device-memory-full" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_offline_reason_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiDmsOfflineReason"),
                                      qmi_dms_offline_reason_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_OFFLINE_REASON_IS_ENUM__
const gchar *
qmi_dms_offline_reason_get_string (QmiDmsOfflineReason val)
{
    guint i;

    for (i = 0; qmi_dms_offline_reason_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_offline_reason_values[i].value)
            return qmi_dms_offline_reason_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_OFFLINE_REASON_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_OFFLINE_REASON_IS_FLAGS__
gchar *
qmi_dms_offline_reason_build_string_from_mask (QmiDmsOfflineReason mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_offline_reason_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_offline_reason_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_offline_reason_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_offline_reason_values[i].value) {
            guint c;
            gulong number = qmi_dms_offline_reason_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_offline_reason_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_OFFLINE_REASON_IS_FLAGS__ */
static const GEnumValue qmi_dms_time_source_values[] = {
    { QMI_DMS_TIME_SOURCE_DEVICE, "QMI_DMS_TIME_SOURCE_DEVICE", "device" },
    { QMI_DMS_TIME_SOURCE_CDMA_NETWORK, "QMI_DMS_TIME_SOURCE_CDMA_NETWORK", "cdma-network" },
    { QMI_DMS_TIME_SOURCE_HDR_NETWORK, "QMI_DMS_TIME_SOURCE_HDR_NETWORK", "hdr-network" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_time_source_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsTimeSource"),
                                      qmi_dms_time_source_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_TIME_SOURCE_IS_ENUM__
const gchar *
qmi_dms_time_source_get_string (QmiDmsTimeSource val)
{
    guint i;

    for (i = 0; qmi_dms_time_source_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_time_source_values[i].value)
            return qmi_dms_time_source_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_TIME_SOURCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_TIME_SOURCE_IS_FLAGS__
gchar *
qmi_dms_time_source_build_string_from_mask (QmiDmsTimeSource mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_time_source_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_time_source_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_time_source_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_time_source_values[i].value) {
            guint c;
            gulong number = qmi_dms_time_source_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_time_source_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_TIME_SOURCE_IS_FLAGS__ */
static const GEnumValue qmi_dms_activation_state_values[] = {
    { QMI_DMS_ACTIVATION_STATE_NOT_ACTIVATED, "QMI_DMS_ACTIVATION_STATE_NOT_ACTIVATED", "not-activated" },
    { QMI_DMS_ACTIVATION_STATE_ACTIVATED, "QMI_DMS_ACTIVATION_STATE_ACTIVATED", "activated" },
    { QMI_DMS_ACTIVATION_STATE_CONNECTING, "QMI_DMS_ACTIVATION_STATE_CONNECTING", "connecting" },
    { QMI_DMS_ACTIVATION_STATE_CONNECTED, "QMI_DMS_ACTIVATION_STATE_CONNECTED", "connected" },
    { QMI_DMS_ACTIVATION_STATE_OTASP_AUTHENTICATED, "QMI_DMS_ACTIVATION_STATE_OTASP_AUTHENTICATED", "otasp-authenticated" },
    { QMI_DMS_ACTIVATION_STATE_OTASP_NAM, "QMI_DMS_ACTIVATION_STATE_OTASP_NAM", "otasp-nam" },
    { QMI_DMS_ACTIVATION_STATE_OTASP_MDN, "QMI_DMS_ACTIVATION_STATE_OTASP_MDN", "otasp-mdn" },
    { QMI_DMS_ACTIVATION_STATE_OTASP_IMSI, "QMI_DMS_ACTIVATION_STATE_OTASP_IMSI", "otasp-imsi" },
    { QMI_DMS_ACTIVATION_STATE_OTASP_PRL, "QMI_DMS_ACTIVATION_STATE_OTASP_PRL", "otasp-prl" },
    { QMI_DMS_ACTIVATION_STATE_OTASP_SPC, "QMI_DMS_ACTIVATION_STATE_OTASP_SPC", "otasp-spc" },
    { QMI_DMS_ACTIVATION_STATE_OTASP_COMMITED, "QMI_DMS_ACTIVATION_STATE_OTASP_COMMITED", "otasp-commited" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_activation_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsActivationState"),
                                      qmi_dms_activation_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_ACTIVATION_STATE_IS_ENUM__
const gchar *
qmi_dms_activation_state_get_string (QmiDmsActivationState val)
{
    guint i;

    for (i = 0; qmi_dms_activation_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_activation_state_values[i].value)
            return qmi_dms_activation_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_ACTIVATION_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_ACTIVATION_STATE_IS_FLAGS__
gchar *
qmi_dms_activation_state_build_string_from_mask (QmiDmsActivationState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_activation_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_activation_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_activation_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_activation_state_values[i].value) {
            guint c;
            gulong number = qmi_dms_activation_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_activation_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_ACTIVATION_STATE_IS_FLAGS__ */
static const GEnumValue qmi_dms_uim_facility_values[] = {
    { QMI_DMS_UIM_FACILITY_PN, "QMI_DMS_UIM_FACILITY_PN", "pn" },
    { QMI_DMS_UIM_FACILITY_PU, "QMI_DMS_UIM_FACILITY_PU", "pu" },
    { QMI_DMS_UIM_FACILITY_PP, "QMI_DMS_UIM_FACILITY_PP", "pp" },
    { QMI_DMS_UIM_FACILITY_PC, "QMI_DMS_UIM_FACILITY_PC", "pc" },
    { QMI_DMS_UIM_FACILITY_PF, "QMI_DMS_UIM_FACILITY_PF", "pf" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_uim_facility_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsUimFacility"),
                                      qmi_dms_uim_facility_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_UIM_FACILITY_IS_ENUM__
const gchar *
qmi_dms_uim_facility_get_string (QmiDmsUimFacility val)
{
    guint i;

    for (i = 0; qmi_dms_uim_facility_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_uim_facility_values[i].value)
            return qmi_dms_uim_facility_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_UIM_FACILITY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_UIM_FACILITY_IS_FLAGS__
gchar *
qmi_dms_uim_facility_build_string_from_mask (QmiDmsUimFacility mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_uim_facility_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_uim_facility_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_uim_facility_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_uim_facility_values[i].value) {
            guint c;
            gulong number = qmi_dms_uim_facility_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_uim_facility_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_UIM_FACILITY_IS_FLAGS__ */
static const GEnumValue qmi_dms_uim_facility_state_values[] = {
    { QMI_DMS_UIM_FACILITY_STATE_DEACTIVATED, "QMI_DMS_UIM_FACILITY_STATE_DEACTIVATED", "deactivated" },
    { QMI_DMS_UIM_FACILITY_STATE_ACTIVATED, "QMI_DMS_UIM_FACILITY_STATE_ACTIVATED", "activated" },
    { QMI_DMS_UIM_FACILITY_STATE_BLOCKED, "QMI_DMS_UIM_FACILITY_STATE_BLOCKED", "blocked" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_uim_facility_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsUimFacilityState"),
                                      qmi_dms_uim_facility_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_UIM_FACILITY_STATE_IS_ENUM__
const gchar *
qmi_dms_uim_facility_state_get_string (QmiDmsUimFacilityState val)
{
    guint i;

    for (i = 0; qmi_dms_uim_facility_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_uim_facility_state_values[i].value)
            return qmi_dms_uim_facility_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_UIM_FACILITY_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_UIM_FACILITY_STATE_IS_FLAGS__
gchar *
qmi_dms_uim_facility_state_build_string_from_mask (QmiDmsUimFacilityState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_uim_facility_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_uim_facility_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_uim_facility_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_uim_facility_state_values[i].value) {
            guint c;
            gulong number = qmi_dms_uim_facility_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_uim_facility_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_UIM_FACILITY_STATE_IS_FLAGS__ */
static const GEnumValue qmi_dms_uim_state_values[] = {
    { QMI_DMS_UIM_STATE_INITIALIZATION_COMPLETED, "QMI_DMS_UIM_STATE_INITIALIZATION_COMPLETED", "initialization-completed" },
    { QMI_DMS_UIM_STATE_LOCKED_OR_FAILED, "QMI_DMS_UIM_STATE_LOCKED_OR_FAILED", "locked-or-failed" },
    { QMI_DMS_UIM_STATE_NOT_PRESENT, "QMI_DMS_UIM_STATE_NOT_PRESENT", "not-present" },
    { QMI_DMS_UIM_STATE_RESERVED, "QMI_DMS_UIM_STATE_RESERVED", "reserved" },
    { QMI_DMS_UIM_STATE_UNKNOWN, "QMI_DMS_UIM_STATE_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_uim_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsUimState"),
                                      qmi_dms_uim_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_UIM_STATE_IS_ENUM__
const gchar *
qmi_dms_uim_state_get_string (QmiDmsUimState val)
{
    guint i;

    for (i = 0; qmi_dms_uim_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_uim_state_values[i].value)
            return qmi_dms_uim_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_UIM_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_UIM_STATE_IS_FLAGS__
gchar *
qmi_dms_uim_state_build_string_from_mask (QmiDmsUimState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_uim_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_uim_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_uim_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_uim_state_values[i].value) {
            guint c;
            gulong number = qmi_dms_uim_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_uim_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_UIM_STATE_IS_FLAGS__ */
static const GEnumValue qmi_dms_time_reference_type_values[] = {
    { QMI_DMS_TIME_REFERENCE_TYPE_USER, "QMI_DMS_TIME_REFERENCE_TYPE_USER", "user" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_time_reference_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsTimeReferenceType"),
                                      qmi_dms_time_reference_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_TIME_REFERENCE_TYPE_IS_ENUM__
const gchar *
qmi_dms_time_reference_type_get_string (QmiDmsTimeReferenceType val)
{
    guint i;

    for (i = 0; qmi_dms_time_reference_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_time_reference_type_values[i].value)
            return qmi_dms_time_reference_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_TIME_REFERENCE_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_TIME_REFERENCE_TYPE_IS_FLAGS__
gchar *
qmi_dms_time_reference_type_build_string_from_mask (QmiDmsTimeReferenceType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_time_reference_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_time_reference_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_time_reference_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_time_reference_type_values[i].value) {
            guint c;
            gulong number = qmi_dms_time_reference_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_time_reference_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_TIME_REFERENCE_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_dms_firmware_image_type_values[] = {
    { QMI_DMS_FIRMWARE_IMAGE_TYPE_MODEM, "QMI_DMS_FIRMWARE_IMAGE_TYPE_MODEM", "modem" },
    { QMI_DMS_FIRMWARE_IMAGE_TYPE_PRI, "QMI_DMS_FIRMWARE_IMAGE_TYPE_PRI", "pri" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_firmware_image_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsFirmwareImageType"),
                                      qmi_dms_firmware_image_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_ENUM__
const gchar *
qmi_dms_firmware_image_type_get_string (QmiDmsFirmwareImageType val)
{
    guint i;

    for (i = 0; qmi_dms_firmware_image_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_firmware_image_type_values[i].value)
            return qmi_dms_firmware_image_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_FLAGS__
gchar *
qmi_dms_firmware_image_type_build_string_from_mask (QmiDmsFirmwareImageType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_firmware_image_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_firmware_image_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_firmware_image_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_firmware_image_type_values[i].value) {
            guint c;
            gulong number = qmi_dms_firmware_image_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_firmware_image_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_dms_boot_image_download_mode_values[] = {
    { QMI_DMS_BOOT_IMAGE_DOWNLOAD_MODE_NORMAL, "QMI_DMS_BOOT_IMAGE_DOWNLOAD_MODE_NORMAL", "normal" },
    { QMI_DMS_BOOT_IMAGE_DOWNLOAD_MODE_BOOT_AND_RECOVERY, "QMI_DMS_BOOT_IMAGE_DOWNLOAD_MODE_BOOT_AND_RECOVERY", "boot-and-recovery" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_boot_image_download_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsBootImageDownloadMode"),
                                      qmi_dms_boot_image_download_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_BOOT_IMAGE_DOWNLOAD_MODE_IS_ENUM__
const gchar *
qmi_dms_boot_image_download_mode_get_string (QmiDmsBootImageDownloadMode val)
{
    guint i;

    for (i = 0; qmi_dms_boot_image_download_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_boot_image_download_mode_values[i].value)
            return qmi_dms_boot_image_download_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_BOOT_IMAGE_DOWNLOAD_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_BOOT_IMAGE_DOWNLOAD_MODE_IS_FLAGS__
gchar *
qmi_dms_boot_image_download_mode_build_string_from_mask (QmiDmsBootImageDownloadMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_boot_image_download_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_boot_image_download_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_boot_image_download_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_boot_image_download_mode_values[i].value) {
            guint c;
            gulong number = qmi_dms_boot_image_download_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_boot_image_download_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_BOOT_IMAGE_DOWNLOAD_MODE_IS_FLAGS__ */
static const GEnumValue qmi_dms_mac_type_values[] = {
    { QMI_DMS_MAC_TYPE_WLAN, "QMI_DMS_MAC_TYPE_WLAN", "wlan" },
    { QMI_DMS_MAC_TYPE_BT, "QMI_DMS_MAC_TYPE_BT", "bt" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_mac_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsMacType"),
                                      qmi_dms_mac_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_MAC_TYPE_IS_ENUM__
const gchar *
qmi_dms_mac_type_get_string (QmiDmsMacType val)
{
    guint i;

    for (i = 0; qmi_dms_mac_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_mac_type_values[i].value)
            return qmi_dms_mac_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_MAC_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_MAC_TYPE_IS_FLAGS__
gchar *
qmi_dms_mac_type_build_string_from_mask (QmiDmsMacType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_mac_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_mac_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_mac_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_mac_type_values[i].value) {
            guint c;
            gulong number = qmi_dms_mac_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_mac_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_MAC_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_dms_hp_device_mode_values[] = {
    { QMI_DMS_HP_DEVICE_MODE_FASTBOOT, "QMI_DMS_HP_DEVICE_MODE_FASTBOOT", "fastboot" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_hp_device_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsHpDeviceMode"),
                                      qmi_dms_hp_device_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_HP_DEVICE_MODE_IS_ENUM__
const gchar *
qmi_dms_hp_device_mode_get_string (QmiDmsHpDeviceMode val)
{
    guint i;

    for (i = 0; qmi_dms_hp_device_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_hp_device_mode_values[i].value)
            return qmi_dms_hp_device_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_HP_DEVICE_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_HP_DEVICE_MODE_IS_FLAGS__
gchar *
qmi_dms_hp_device_mode_build_string_from_mask (QmiDmsHpDeviceMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_hp_device_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_hp_device_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_hp_device_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_hp_device_mode_values[i].value) {
            guint c;
            gulong number = qmi_dms_hp_device_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_hp_device_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_HP_DEVICE_MODE_IS_FLAGS__ */
static const GEnumValue qmi_dms_swi_usb_composition_values[] = {
    { QMI_DMS_SWI_USB_COMPOSITION_UNKNOWN, "QMI_DMS_SWI_USB_COMPOSITION_UNKNOWN", "unknown" },
    { QMI_DMS_SWI_USB_COMPOSITION_0, "QMI_DMS_SWI_USB_COMPOSITION_0", "0" },
    { QMI_DMS_SWI_USB_COMPOSITION_1, "QMI_DMS_SWI_USB_COMPOSITION_1", "1" },
    { QMI_DMS_SWI_USB_COMPOSITION_2, "QMI_DMS_SWI_USB_COMPOSITION_2", "2" },
    { QMI_DMS_SWI_USB_COMPOSITION_3, "QMI_DMS_SWI_USB_COMPOSITION_3", "3" },
    { QMI_DMS_SWI_USB_COMPOSITION_4, "QMI_DMS_SWI_USB_COMPOSITION_4", "4" },
    { QMI_DMS_SWI_USB_COMPOSITION_5, "QMI_DMS_SWI_USB_COMPOSITION_5", "5" },
    { QMI_DMS_SWI_USB_COMPOSITION_6, "QMI_DMS_SWI_USB_COMPOSITION_6", "6" },
    { QMI_DMS_SWI_USB_COMPOSITION_7, "QMI_DMS_SWI_USB_COMPOSITION_7", "7" },
    { QMI_DMS_SWI_USB_COMPOSITION_8, "QMI_DMS_SWI_USB_COMPOSITION_8", "8" },
    { QMI_DMS_SWI_USB_COMPOSITION_9, "QMI_DMS_SWI_USB_COMPOSITION_9", "9" },
    { QMI_DMS_SWI_USB_COMPOSITION_10, "QMI_DMS_SWI_USB_COMPOSITION_10", "10" },
    { QMI_DMS_SWI_USB_COMPOSITION_11, "QMI_DMS_SWI_USB_COMPOSITION_11", "11" },
    { QMI_DMS_SWI_USB_COMPOSITION_12, "QMI_DMS_SWI_USB_COMPOSITION_12", "12" },
    { QMI_DMS_SWI_USB_COMPOSITION_13, "QMI_DMS_SWI_USB_COMPOSITION_13", "13" },
    { QMI_DMS_SWI_USB_COMPOSITION_14, "QMI_DMS_SWI_USB_COMPOSITION_14", "14" },
    { QMI_DMS_SWI_USB_COMPOSITION_15, "QMI_DMS_SWI_USB_COMPOSITION_15", "15" },
    { QMI_DMS_SWI_USB_COMPOSITION_16, "QMI_DMS_SWI_USB_COMPOSITION_16", "16" },
    { QMI_DMS_SWI_USB_COMPOSITION_17, "QMI_DMS_SWI_USB_COMPOSITION_17", "17" },
    { QMI_DMS_SWI_USB_COMPOSITION_18, "QMI_DMS_SWI_USB_COMPOSITION_18", "18" },
    { QMI_DMS_SWI_USB_COMPOSITION_19, "QMI_DMS_SWI_USB_COMPOSITION_19", "19" },
    { QMI_DMS_SWI_USB_COMPOSITION_20, "QMI_DMS_SWI_USB_COMPOSITION_20", "20" },
    { QMI_DMS_SWI_USB_COMPOSITION_21, "QMI_DMS_SWI_USB_COMPOSITION_21", "21" },
    { QMI_DMS_SWI_USB_COMPOSITION_22, "QMI_DMS_SWI_USB_COMPOSITION_22", "22" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_swi_usb_composition_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsSwiUsbComposition"),
                                      qmi_dms_swi_usb_composition_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_SWI_USB_COMPOSITION_IS_ENUM__
const gchar *
qmi_dms_swi_usb_composition_get_string (QmiDmsSwiUsbComposition val)
{
    guint i;

    for (i = 0; qmi_dms_swi_usb_composition_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_swi_usb_composition_values[i].value)
            return qmi_dms_swi_usb_composition_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_SWI_USB_COMPOSITION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_SWI_USB_COMPOSITION_IS_FLAGS__
gchar *
qmi_dms_swi_usb_composition_build_string_from_mask (QmiDmsSwiUsbComposition mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_swi_usb_composition_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_swi_usb_composition_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_swi_usb_composition_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_swi_usb_composition_values[i].value) {
            guint c;
            gulong number = qmi_dms_swi_usb_composition_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_swi_usb_composition_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_SWI_USB_COMPOSITION_IS_FLAGS__ */
static const GEnumValue qmi_dms_foxconn_device_mode_values[] = {
    { QMI_DMS_FOXCONN_DEVICE_MODE_UNKNOWN, "QMI_DMS_FOXCONN_DEVICE_MODE_UNKNOWN", "unknown" },
    { QMI_DMS_FOXCONN_DEVICE_MODE_FASTBOOT_ONLINE, "QMI_DMS_FOXCONN_DEVICE_MODE_FASTBOOT_ONLINE", "fastboot-online" },
    { QMI_DMS_FOXCONN_DEVICE_MODE_FASTBOOT_OTA, "QMI_DMS_FOXCONN_DEVICE_MODE_FASTBOOT_OTA", "fastboot-ota" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_foxconn_device_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsFoxconnDeviceMode"),
                                      qmi_dms_foxconn_device_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_FOXCONN_DEVICE_MODE_IS_ENUM__
const gchar *
qmi_dms_foxconn_device_mode_get_string (QmiDmsFoxconnDeviceMode val)
{
    guint i;

    for (i = 0; qmi_dms_foxconn_device_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_foxconn_device_mode_values[i].value)
            return qmi_dms_foxconn_device_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_FOXCONN_DEVICE_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_FOXCONN_DEVICE_MODE_IS_FLAGS__
gchar *
qmi_dms_foxconn_device_mode_build_string_from_mask (QmiDmsFoxconnDeviceMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_foxconn_device_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_foxconn_device_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_foxconn_device_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_foxconn_device_mode_values[i].value) {
            guint c;
            gulong number = qmi_dms_foxconn_device_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_foxconn_device_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_FOXCONN_DEVICE_MODE_IS_FLAGS__ */
static const GEnumValue qmi_dms_foxconn_firmware_version_type_values[] = {
    { QMI_DMS_FOXCONN_FIRMWARE_VERSION_TYPE_FIRMWARE_MCFG, "QMI_DMS_FOXCONN_FIRMWARE_VERSION_TYPE_FIRMWARE_MCFG", "firmware-mcfg" },
    { QMI_DMS_FOXCONN_FIRMWARE_VERSION_TYPE_FIRMWARE_MCFG_APPS, "QMI_DMS_FOXCONN_FIRMWARE_VERSION_TYPE_FIRMWARE_MCFG_APPS", "firmware-mcfg-apps" },
    { QMI_DMS_FOXCONN_FIRMWARE_VERSION_TYPE_APPS, "QMI_DMS_FOXCONN_FIRMWARE_VERSION_TYPE_APPS", "apps" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dms_foxconn_firmware_version_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDmsFoxconnFirmwareVersionType"),
                                      qmi_dms_foxconn_firmware_version_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DMS_FOXCONN_FIRMWARE_VERSION_TYPE_IS_ENUM__
const gchar *
qmi_dms_foxconn_firmware_version_type_get_string (QmiDmsFoxconnFirmwareVersionType val)
{
    guint i;

    for (i = 0; qmi_dms_foxconn_firmware_version_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_dms_foxconn_firmware_version_type_values[i].value)
            return qmi_dms_foxconn_firmware_version_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DMS_FOXCONN_FIRMWARE_VERSION_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DMS_FOXCONN_FIRMWARE_VERSION_TYPE_IS_FLAGS__
gchar *
qmi_dms_foxconn_firmware_version_type_build_string_from_mask (QmiDmsFoxconnFirmwareVersionType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dms_foxconn_firmware_version_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dms_foxconn_firmware_version_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dms_foxconn_firmware_version_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dms_foxconn_firmware_version_type_values[i].value) {
            guint c;
            gulong number = qmi_dms_foxconn_firmware_version_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dms_foxconn_firmware_version_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DMS_FOXCONN_FIRMWARE_VERSION_TYPE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-dsd.h" */
static const GEnumValue qmi_dsd_apn_type_values[] = {
    { QMI_DSD_APN_TYPE_DEFAULT, "QMI_DSD_APN_TYPE_DEFAULT", "default" },
    { QMI_DSD_APN_TYPE_IMS, "QMI_DSD_APN_TYPE_IMS", "ims" },
    { QMI_DSD_APN_TYPE_MMS, "QMI_DSD_APN_TYPE_MMS", "mms" },
    { QMI_DSD_APN_TYPE_DUN, "QMI_DSD_APN_TYPE_DUN", "dun" },
    { QMI_DSD_APN_TYPE_SUPL, "QMI_DSD_APN_TYPE_SUPL", "supl" },
    { QMI_DSD_APN_TYPE_HIPRI, "QMI_DSD_APN_TYPE_HIPRI", "hipri" },
    { QMI_DSD_APN_TYPE_FOTA, "QMI_DSD_APN_TYPE_FOTA", "fota" },
    { QMI_DSD_APN_TYPE_CBS, "QMI_DSD_APN_TYPE_CBS", "cbs" },
    { QMI_DSD_APN_TYPE_IA, "QMI_DSD_APN_TYPE_IA", "ia" },
    { QMI_DSD_APN_TYPE_EMERGENCY, "QMI_DSD_APN_TYPE_EMERGENCY", "emergency" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_dsd_apn_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDsdApnType"),
                                      qmi_dsd_apn_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DSD_APN_TYPE_IS_ENUM__
const gchar *
qmi_dsd_apn_type_get_string (QmiDsdApnType val)
{
    guint i;

    for (i = 0; qmi_dsd_apn_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_dsd_apn_type_values[i].value)
            return qmi_dsd_apn_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DSD_APN_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DSD_APN_TYPE_IS_FLAGS__
gchar *
qmi_dsd_apn_type_build_string_from_mask (QmiDsdApnType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_dsd_apn_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_dsd_apn_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_dsd_apn_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_dsd_apn_type_values[i].value) {
            guint c;
            gulong number = qmi_dsd_apn_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_dsd_apn_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DSD_APN_TYPE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-gas.h" */
static const GEnumValue qmi_gas_firmware_listing_mode_values[] = {
    { QMI_GAS_FIRMWARE_LISTING_MODE_ACTIVE_FIRMWARE, "QMI_GAS_FIRMWARE_LISTING_MODE_ACTIVE_FIRMWARE", "active-firmware" },
    { QMI_GAS_FIRMWARE_LISTING_MODE_ALL_FIRMWARE, "QMI_GAS_FIRMWARE_LISTING_MODE_ALL_FIRMWARE", "all-firmware" },
    { QMI_GAS_FIRMWARE_LISTING_MODE_SPECIFIC_FIRMWARE, "QMI_GAS_FIRMWARE_LISTING_MODE_SPECIFIC_FIRMWARE", "specific-firmware" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_gas_firmware_listing_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiGasFirmwareListingMode"),
                                      qmi_gas_firmware_listing_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_GAS_FIRMWARE_LISTING_MODE_IS_ENUM__
const gchar *
qmi_gas_firmware_listing_mode_get_string (QmiGasFirmwareListingMode val)
{
    guint i;

    for (i = 0; qmi_gas_firmware_listing_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_gas_firmware_listing_mode_values[i].value)
            return qmi_gas_firmware_listing_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_GAS_FIRMWARE_LISTING_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_GAS_FIRMWARE_LISTING_MODE_IS_FLAGS__
gchar *
qmi_gas_firmware_listing_mode_build_string_from_mask (QmiGasFirmwareListingMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_gas_firmware_listing_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_gas_firmware_listing_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_gas_firmware_listing_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_gas_firmware_listing_mode_values[i].value) {
            guint c;
            gulong number = qmi_gas_firmware_listing_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_gas_firmware_listing_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_GAS_FIRMWARE_LISTING_MODE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-loc.h" */
static const GEnumValue qmi_loc_intermediate_report_state_values[] = {
    { QMI_LOC_INTERMEDIATE_REPORT_STATE_UNKNOWN, "QMI_LOC_INTERMEDIATE_REPORT_STATE_UNKNOWN", "unknown" },
    { QMI_LOC_INTERMEDIATE_REPORT_STATE_ENABLE, "QMI_LOC_INTERMEDIATE_REPORT_STATE_ENABLE", "enable" },
    { QMI_LOC_INTERMEDIATE_REPORT_STATE_DISABLE, "QMI_LOC_INTERMEDIATE_REPORT_STATE_DISABLE", "disable" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_intermediate_report_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocIntermediateReportState"),
                                      qmi_loc_intermediate_report_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_INTERMEDIATE_REPORT_STATE_IS_ENUM__
const gchar *
qmi_loc_intermediate_report_state_get_string (QmiLocIntermediateReportState val)
{
    guint i;

    for (i = 0; qmi_loc_intermediate_report_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_intermediate_report_state_values[i].value)
            return qmi_loc_intermediate_report_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_INTERMEDIATE_REPORT_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_INTERMEDIATE_REPORT_STATE_IS_FLAGS__
gchar *
qmi_loc_intermediate_report_state_build_string_from_mask (QmiLocIntermediateReportState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_intermediate_report_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_intermediate_report_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_intermediate_report_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_intermediate_report_state_values[i].value) {
            guint c;
            gulong number = qmi_loc_intermediate_report_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_intermediate_report_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_INTERMEDIATE_REPORT_STATE_IS_FLAGS__ */
static const GEnumValue qmi_loc_indication_status_values[] = {
    { QMI_LOC_INDICATION_STATUS_SUCCESS, "QMI_LOC_INDICATION_STATUS_SUCCESS", "success" },
    { QMI_LOC_INDICATION_STATUS_GENERAL_FAILURE, "QMI_LOC_INDICATION_STATUS_GENERAL_FAILURE", "general-failure" },
    { QMI_LOC_INDICATION_STATUS_UNSUPPORTED, "QMI_LOC_INDICATION_STATUS_UNSUPPORTED", "unsupported" },
    { QMI_LOC_INDICATION_STATUS_INVALID_PARAMETER, "QMI_LOC_INDICATION_STATUS_INVALID_PARAMETER", "invalid-parameter" },
    { QMI_LOC_INDICATION_STATUS_ENGINE_BUSY, "QMI_LOC_INDICATION_STATUS_ENGINE_BUSY", "engine-busy" },
    { QMI_LOC_INDICATION_STATUS_PHONE_OFFLINE, "QMI_LOC_INDICATION_STATUS_PHONE_OFFLINE", "phone-offline" },
    { QMI_LOC_INDICATION_STATUS_TIMEOUT, "QMI_LOC_INDICATION_STATUS_TIMEOUT", "timeout" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_indication_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocIndicationStatus"),
                                      qmi_loc_indication_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_INDICATION_STATUS_IS_ENUM__
const gchar *
qmi_loc_indication_status_get_string (QmiLocIndicationStatus val)
{
    guint i;

    for (i = 0; qmi_loc_indication_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_indication_status_values[i].value)
            return qmi_loc_indication_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_INDICATION_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_INDICATION_STATUS_IS_FLAGS__
gchar *
qmi_loc_indication_status_build_string_from_mask (QmiLocIndicationStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_indication_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_indication_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_indication_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_indication_status_values[i].value) {
            guint c;
            gulong number = qmi_loc_indication_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_indication_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_INDICATION_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_loc_session_status_values[] = {
    { QMI_LOC_SESSION_STATUS_SUCCESS, "QMI_LOC_SESSION_STATUS_SUCCESS", "success" },
    { QMI_LOC_SESSION_STATUS_IN_PROGRESS, "QMI_LOC_SESSION_STATUS_IN_PROGRESS", "in-progress" },
    { QMI_LOC_SESSION_STATUS_GENERAL_FAILURE, "QMI_LOC_SESSION_STATUS_GENERAL_FAILURE", "general-failure" },
    { QMI_LOC_SESSION_STATUS_TIMEOUT, "QMI_LOC_SESSION_STATUS_TIMEOUT", "timeout" },
    { QMI_LOC_SESSION_STATUS_USER_ENDED, "QMI_LOC_SESSION_STATUS_USER_ENDED", "user-ended" },
    { QMI_LOC_SESSION_STATUS_BAD_PARAMETER, "QMI_LOC_SESSION_STATUS_BAD_PARAMETER", "bad-parameter" },
    { QMI_LOC_SESSION_STATUS_PHONE_OFFLINE, "QMI_LOC_SESSION_STATUS_PHONE_OFFLINE", "phone-offline" },
    { QMI_LOC_SESSION_STATUS_ENGINE_LOCKED, "QMI_LOC_SESSION_STATUS_ENGINE_LOCKED", "engine-locked" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_session_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocSessionStatus"),
                                      qmi_loc_session_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_SESSION_STATUS_IS_ENUM__
const gchar *
qmi_loc_session_status_get_string (QmiLocSessionStatus val)
{
    guint i;

    for (i = 0; qmi_loc_session_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_session_status_values[i].value)
            return qmi_loc_session_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_SESSION_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_SESSION_STATUS_IS_FLAGS__
gchar *
qmi_loc_session_status_build_string_from_mask (QmiLocSessionStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_session_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_session_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_session_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_session_status_values[i].value) {
            guint c;
            gulong number = qmi_loc_session_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_session_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_SESSION_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_loc_fix_recurrence_type_values[] = {
    { QMI_LOC_FIX_RECURRENCE_TYPE_REQUEST_PERIODIC_FIXES, "QMI_LOC_FIX_RECURRENCE_TYPE_REQUEST_PERIODIC_FIXES", "periodic-fixes" },
    { QMI_LOC_FIX_RECURRENCE_TYPE_REQUEST_SINGLE_FIX, "QMI_LOC_FIX_RECURRENCE_TYPE_REQUEST_SINGLE_FIX", "single-fix" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_fix_recurrence_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocFixRecurrenceType"),
                                      qmi_loc_fix_recurrence_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_FIX_RECURRENCE_TYPE_IS_ENUM__
const gchar *
qmi_loc_fix_recurrence_type_get_string (QmiLocFixRecurrenceType val)
{
    guint i;

    for (i = 0; qmi_loc_fix_recurrence_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_fix_recurrence_type_values[i].value)
            return qmi_loc_fix_recurrence_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_FIX_RECURRENCE_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_FIX_RECURRENCE_TYPE_IS_FLAGS__
gchar *
qmi_loc_fix_recurrence_type_build_string_from_mask (QmiLocFixRecurrenceType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_fix_recurrence_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_fix_recurrence_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_fix_recurrence_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_fix_recurrence_type_values[i].value) {
            guint c;
            gulong number = qmi_loc_fix_recurrence_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_fix_recurrence_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_FIX_RECURRENCE_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_loc_operation_mode_values[] = {
    { QMI_LOC_OPERATION_MODE_DEFAULT, "QMI_LOC_OPERATION_MODE_DEFAULT", "default" },
    { QMI_LOC_OPERATION_MODE_MSB, "QMI_LOC_OPERATION_MODE_MSB", "msb" },
    { QMI_LOC_OPERATION_MODE_MSA, "QMI_LOC_OPERATION_MODE_MSA", "msa" },
    { QMI_LOC_OPERATION_MODE_STANDALONE, "QMI_LOC_OPERATION_MODE_STANDALONE", "standalone" },
    { QMI_LOC_OPERATION_MODE_CELLID, "QMI_LOC_OPERATION_MODE_CELLID", "cellid" },
    { QMI_LOC_OPERATION_MODE_WWAN, "QMI_LOC_OPERATION_MODE_WWAN", "wwan" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_operation_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocOperationMode"),
                                      qmi_loc_operation_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_OPERATION_MODE_IS_ENUM__
const gchar *
qmi_loc_operation_mode_get_string (QmiLocOperationMode val)
{
    guint i;

    for (i = 0; qmi_loc_operation_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_operation_mode_values[i].value)
            return qmi_loc_operation_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_OPERATION_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_OPERATION_MODE_IS_FLAGS__
gchar *
qmi_loc_operation_mode_build_string_from_mask (QmiLocOperationMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_operation_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_operation_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_operation_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_operation_mode_values[i].value) {
            guint c;
            gulong number = qmi_loc_operation_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_operation_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_OPERATION_MODE_IS_FLAGS__ */
static const GEnumValue qmi_loc_engine_state_values[] = {
    { QMI_LOC_ENGINE_STATE_ON, "QMI_LOC_ENGINE_STATE_ON", "on" },
    { QMI_LOC_ENGINE_STATE_OFF, "QMI_LOC_ENGINE_STATE_OFF", "off" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_engine_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocEngineState"),
                                      qmi_loc_engine_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_ENGINE_STATE_IS_ENUM__
const gchar *
qmi_loc_engine_state_get_string (QmiLocEngineState val)
{
    guint i;

    for (i = 0; qmi_loc_engine_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_engine_state_values[i].value)
            return qmi_loc_engine_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_ENGINE_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_ENGINE_STATE_IS_FLAGS__
gchar *
qmi_loc_engine_state_build_string_from_mask (QmiLocEngineState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_engine_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_engine_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_engine_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_engine_state_values[i].value) {
            guint c;
            gulong number = qmi_loc_engine_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_engine_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_ENGINE_STATE_IS_FLAGS__ */
static const GFlagsValue qmi_loc_technology_used_values[] = {
    { QMI_LOC_TECHNOLOGY_USED_SATELLITE, "QMI_LOC_TECHNOLOGY_USED_SATELLITE", "satellite" },
    { QMI_LOC_TECHNOLOGY_USED_CELLULAR, "QMI_LOC_TECHNOLOGY_USED_CELLULAR", "cellular" },
    { QMI_LOC_TECHNOLOGY_USED_WIFI, "QMI_LOC_TECHNOLOGY_USED_WIFI", "wifi" },
    { QMI_LOC_TECHNOLOGY_USED_SENSORS, "QMI_LOC_TECHNOLOGY_USED_SENSORS", "sensors" },
    { QMI_LOC_TECHNOLOGY_USED_REFERENCE_LOCATION, "QMI_LOC_TECHNOLOGY_USED_REFERENCE_LOCATION", "reference-location" },
    { QMI_LOC_TECHNOLOGY_USED_INJECTED_POSITION, "QMI_LOC_TECHNOLOGY_USED_INJECTED_POSITION", "injected-position" },
    { QMI_LOC_TECHNOLOGY_USED_AFLT, "QMI_LOC_TECHNOLOGY_USED_AFLT", "aflt" },
    { QMI_LOC_TECHNOLOGY_USED_HYBRID, "QMI_LOC_TECHNOLOGY_USED_HYBRID", "hybrid" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_technology_used_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiLocTechnologyUsed"),
                                      qmi_loc_technology_used_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_TECHNOLOGY_USED_IS_ENUM__
const gchar *
qmi_loc_technology_used_get_string (QmiLocTechnologyUsed val)
{
    guint i;

    for (i = 0; qmi_loc_technology_used_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_technology_used_values[i].value)
            return qmi_loc_technology_used_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_TECHNOLOGY_USED_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_TECHNOLOGY_USED_IS_FLAGS__
gchar *
qmi_loc_technology_used_build_string_from_mask (QmiLocTechnologyUsed mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_technology_used_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_technology_used_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_technology_used_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_technology_used_values[i].value) {
            guint c;
            gulong number = qmi_loc_technology_used_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_technology_used_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_TECHNOLOGY_USED_IS_FLAGS__ */
static const GEnumValue qmi_loc_reliability_values[] = {
    { QMI_LOC_RELIABILITY_NOT_SET, "QMI_LOC_RELIABILITY_NOT_SET", "not-set" },
    { QMI_LOC_RELIABILITY_VERY_LOW, "QMI_LOC_RELIABILITY_VERY_LOW", "very-low" },
    { QMI_LOC_RELIABILITY_LOW, "QMI_LOC_RELIABILITY_LOW", "low" },
    { QMI_LOC_RELIABILITY_MEDIUM, "QMI_LOC_RELIABILITY_MEDIUM", "medium" },
    { QMI_LOC_RELIABILITY_HIGH, "QMI_LOC_RELIABILITY_HIGH", "high" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_reliability_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocReliability"),
                                      qmi_loc_reliability_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_RELIABILITY_IS_ENUM__
const gchar *
qmi_loc_reliability_get_string (QmiLocReliability val)
{
    guint i;

    for (i = 0; qmi_loc_reliability_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_reliability_values[i].value)
            return qmi_loc_reliability_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_RELIABILITY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_RELIABILITY_IS_FLAGS__
gchar *
qmi_loc_reliability_build_string_from_mask (QmiLocReliability mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_reliability_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_reliability_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_reliability_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_reliability_values[i].value) {
            guint c;
            gulong number = qmi_loc_reliability_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_reliability_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_RELIABILITY_IS_FLAGS__ */
static const GEnumValue qmi_loc_time_source_values[] = {
    { QMI_LOC_TIME_SOURCE_INVALID, "QMI_LOC_TIME_SOURCE_INVALID", "invalid" },
    { QMI_LOC_TIME_SOURCE_NETWORK_TIME_TRANSFER, "QMI_LOC_TIME_SOURCE_NETWORK_TIME_TRANSFER", "network-time-transfer" },
    { QMI_LOC_TIME_SOURCE_NETWORK_TIME_TAGGING, "QMI_LOC_TIME_SOURCE_NETWORK_TIME_TAGGING", "network-time-tagging" },
    { QMI_LOC_TIME_SOURCE_EXTERNAL_INPUT, "QMI_LOC_TIME_SOURCE_EXTERNAL_INPUT", "external-input" },
    { QMI_LOC_TIME_SOURCE_TOW_DECODE, "QMI_LOC_TIME_SOURCE_TOW_DECODE", "tow-decode" },
    { QMI_LOC_TIME_SOURCE_TOW_CONFIRMED, "QMI_LOC_TIME_SOURCE_TOW_CONFIRMED", "tow-confirmed" },
    { QMI_LOC_TIME_SOURCE_TOW_AND_WEEK_CONFIRMED, "QMI_LOC_TIME_SOURCE_TOW_AND_WEEK_CONFIRMED", "tow-and-week-confirmed" },
    { QMI_LOC_TIME_SOURCE_NAVIGATION_SOLUTION, "QMI_LOC_TIME_SOURCE_NAVIGATION_SOLUTION", "navigation-solution" },
    { QMI_LOC_TIME_SOURCE_SOLVE_FOR_TIME, "QMI_LOC_TIME_SOURCE_SOLVE_FOR_TIME", "solve-for-time" },
    { QMI_LOC_TIME_SOURCE_GLO_TOW_DECODE, "QMI_LOC_TIME_SOURCE_GLO_TOW_DECODE", "glo-tow-decode" },
    { QMI_LOC_TIME_SOURCE_TIME_TRANSFORM, "QMI_LOC_TIME_SOURCE_TIME_TRANSFORM", "time-transform" },
    { QMI_LOC_TIME_SOURCE_WCDMA_SLEEP_TIME_TAG, "QMI_LOC_TIME_SOURCE_WCDMA_SLEEP_TIME_TAG", "wcdma-sleep-time-tag" },
    { QMI_LOC_TIME_SOURCE_GSM_SLEEP_TIME_TAG, "QMI_LOC_TIME_SOURCE_GSM_SLEEP_TIME_TAG", "gsm-sleep-time-tag" },
    { QMI_LOC_TIME_SOURCE_UNKNOWN, "QMI_LOC_TIME_SOURCE_UNKNOWN", "unknown" },
    { QMI_LOC_TIME_SOURCE_SYSTEM_TIMETICK, "QMI_LOC_TIME_SOURCE_SYSTEM_TIMETICK", "system-timetick" },
    { QMI_LOC_TIME_SOURCE_QZSS_TOW_DECODE, "QMI_LOC_TIME_SOURCE_QZSS_TOW_DECODE", "qzss-tow-decode" },
    { QMI_LOC_TIME_SOURCE_BDS_TOW_DECODE, "QMI_LOC_TIME_SOURCE_BDS_TOW_DECODE", "bds-tow-decode" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_time_source_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocTimeSource"),
                                      qmi_loc_time_source_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_TIME_SOURCE_IS_ENUM__
const gchar *
qmi_loc_time_source_get_string (QmiLocTimeSource val)
{
    guint i;

    for (i = 0; qmi_loc_time_source_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_time_source_values[i].value)
            return qmi_loc_time_source_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_TIME_SOURCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_TIME_SOURCE_IS_FLAGS__
gchar *
qmi_loc_time_source_build_string_from_mask (QmiLocTimeSource mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_time_source_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_time_source_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_time_source_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_time_source_values[i].value) {
            guint c;
            gulong number = qmi_loc_time_source_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_time_source_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_TIME_SOURCE_IS_FLAGS__ */
static const GFlagsValue qmi_loc_satellite_valid_information_values[] = {
    { QMI_LOC_SATELLITE_VALID_INFORMATION_SYSTEM, "QMI_LOC_SATELLITE_VALID_INFORMATION_SYSTEM", "system" },
    { QMI_LOC_SATELLITE_VALID_INFORMATION_GNSS_SATELLITE_ID, "QMI_LOC_SATELLITE_VALID_INFORMATION_GNSS_SATELLITE_ID", "gnss-satellite-id" },
    { QMI_LOC_SATELLITE_VALID_INFORMATION_HEALTH_STATUS, "QMI_LOC_SATELLITE_VALID_INFORMATION_HEALTH_STATUS", "health-status" },
    { QMI_LOC_SATELLITE_VALID_INFORMATION_PROCESS_STATUS, "QMI_LOC_SATELLITE_VALID_INFORMATION_PROCESS_STATUS", "process-status" },
    { QMI_LOC_SATELLITE_VALID_INFORMATION_SATELLITE_INFO_MASK, "QMI_LOC_SATELLITE_VALID_INFORMATION_SATELLITE_INFO_MASK", "satellite-info-mask" },
    { QMI_LOC_SATELLITE_VALID_INFORMATION_ELEVATION, "QMI_LOC_SATELLITE_VALID_INFORMATION_ELEVATION", "elevation" },
    { QMI_LOC_SATELLITE_VALID_INFORMATION_AZIMUTH, "QMI_LOC_SATELLITE_VALID_INFORMATION_AZIMUTH", "azimuth" },
    { QMI_LOC_SATELLITE_VALID_INFORMATION_SIGNAL_TO_NOISE_RATIO, "QMI_LOC_SATELLITE_VALID_INFORMATION_SIGNAL_TO_NOISE_RATIO", "signal-to-noise-ratio" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_satellite_valid_information_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiLocSatelliteValidInformation"),
                                      qmi_loc_satellite_valid_information_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_SATELLITE_VALID_INFORMATION_IS_ENUM__
const gchar *
qmi_loc_satellite_valid_information_get_string (QmiLocSatelliteValidInformation val)
{
    guint i;

    for (i = 0; qmi_loc_satellite_valid_information_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_satellite_valid_information_values[i].value)
            return qmi_loc_satellite_valid_information_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_SATELLITE_VALID_INFORMATION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_SATELLITE_VALID_INFORMATION_IS_FLAGS__
gchar *
qmi_loc_satellite_valid_information_build_string_from_mask (QmiLocSatelliteValidInformation mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_satellite_valid_information_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_satellite_valid_information_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_satellite_valid_information_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_satellite_valid_information_values[i].value) {
            guint c;
            gulong number = qmi_loc_satellite_valid_information_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_satellite_valid_information_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_SATELLITE_VALID_INFORMATION_IS_FLAGS__ */
static const GEnumValue qmi_loc_system_values[] = {
    { QMI_LOC_SYSTEM_GPS, "QMI_LOC_SYSTEM_GPS", "gps" },
    { QMI_LOC_SYSTEM_GALILEO, "QMI_LOC_SYSTEM_GALILEO", "galileo" },
    { QMI_LOC_SYSTEM_SBAS, "QMI_LOC_SYSTEM_SBAS", "sbas" },
    { QMI_LOC_SYSTEM_COMPASS, "QMI_LOC_SYSTEM_COMPASS", "compass" },
    { QMI_LOC_SYSTEM_GLONASS, "QMI_LOC_SYSTEM_GLONASS", "glonass" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_system_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocSystem"),
                                      qmi_loc_system_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_SYSTEM_IS_ENUM__
const gchar *
qmi_loc_system_get_string (QmiLocSystem val)
{
    guint i;

    for (i = 0; qmi_loc_system_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_system_values[i].value)
            return qmi_loc_system_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_SYSTEM_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_SYSTEM_IS_FLAGS__
gchar *
qmi_loc_system_build_string_from_mask (QmiLocSystem mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_system_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_system_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_system_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_system_values[i].value) {
            guint c;
            gulong number = qmi_loc_system_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_system_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_SYSTEM_IS_FLAGS__ */
static const GEnumValue qmi_loc_health_status_values[] = {
    { QMI_LOC_HEALTH_STATUS_UNHEALTHY, "QMI_LOC_HEALTH_STATUS_UNHEALTHY", "unhealthy" },
    { QMI_LOC_HEALTH_STATUS_HEALTHY, "QMI_LOC_HEALTH_STATUS_HEALTHY", "healthy" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_health_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocHealthStatus"),
                                      qmi_loc_health_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_HEALTH_STATUS_IS_ENUM__
const gchar *
qmi_loc_health_status_get_string (QmiLocHealthStatus val)
{
    guint i;

    for (i = 0; qmi_loc_health_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_health_status_values[i].value)
            return qmi_loc_health_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_HEALTH_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_HEALTH_STATUS_IS_FLAGS__
gchar *
qmi_loc_health_status_build_string_from_mask (QmiLocHealthStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_health_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_health_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_health_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_health_status_values[i].value) {
            guint c;
            gulong number = qmi_loc_health_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_health_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_HEALTH_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_loc_navigation_data_values[] = {
    { QMI_LOC_NAVIGATION_DATA_HAS_EPHEMERIS, "QMI_LOC_NAVIGATION_DATA_HAS_EPHEMERIS", "ephemeris" },
    { QMI_LOC_NAVIGATION_DATA_HAS_ALMANAC, "QMI_LOC_NAVIGATION_DATA_HAS_ALMANAC", "almanac" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_navigation_data_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocNavigationData"),
                                      qmi_loc_navigation_data_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_NAVIGATION_DATA_IS_ENUM__
const gchar *
qmi_loc_navigation_data_get_string (QmiLocNavigationData val)
{
    guint i;

    for (i = 0; qmi_loc_navigation_data_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_navigation_data_values[i].value)
            return qmi_loc_navigation_data_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_NAVIGATION_DATA_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_NAVIGATION_DATA_IS_FLAGS__
gchar *
qmi_loc_navigation_data_build_string_from_mask (QmiLocNavigationData mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_navigation_data_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_navigation_data_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_navigation_data_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_navigation_data_values[i].value) {
            guint c;
            gulong number = qmi_loc_navigation_data_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_navigation_data_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_NAVIGATION_DATA_IS_FLAGS__ */
static const GEnumValue qmi_loc_satellite_status_values[] = {
    { QMI_LOC_SATELLITE_STATUS_IDLE, "QMI_LOC_SATELLITE_STATUS_IDLE", "idle" },
    { QMI_LOC_SATELLITE_STATUS_SEARCHING, "QMI_LOC_SATELLITE_STATUS_SEARCHING", "searching" },
    { QMI_LOC_SATELLITE_STATUS_TRACKING, "QMI_LOC_SATELLITE_STATUS_TRACKING", "tracking" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_satellite_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocSatelliteStatus"),
                                      qmi_loc_satellite_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_SATELLITE_STATUS_IS_ENUM__
const gchar *
qmi_loc_satellite_status_get_string (QmiLocSatelliteStatus val)
{
    guint i;

    for (i = 0; qmi_loc_satellite_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_satellite_status_values[i].value)
            return qmi_loc_satellite_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_SATELLITE_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_SATELLITE_STATUS_IS_FLAGS__
gchar *
qmi_loc_satellite_status_build_string_from_mask (QmiLocSatelliteStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_satellite_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_satellite_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_satellite_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_satellite_status_values[i].value) {
            guint c;
            gulong number = qmi_loc_satellite_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_satellite_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_SATELLITE_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_loc_server_type_values[] = {
    { QMI_LOC_SERVER_TYPE_UNKNOWN, "QMI_LOC_SERVER_TYPE_UNKNOWN", "unknown" },
    { QMI_LOC_SERVER_TYPE_CDMA_PDE, "QMI_LOC_SERVER_TYPE_CDMA_PDE", "cdma-pde" },
    { QMI_LOC_SERVER_TYPE_CDMA_MPC, "QMI_LOC_SERVER_TYPE_CDMA_MPC", "cdma-mpc" },
    { QMI_LOC_SERVER_TYPE_UMTS_SLP, "QMI_LOC_SERVER_TYPE_UMTS_SLP", "umts-slp" },
    { QMI_LOC_SERVER_TYPE_CUSTOM_PDE, "QMI_LOC_SERVER_TYPE_CUSTOM_PDE", "custom-pde" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_server_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocServerType"),
                                      qmi_loc_server_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_SERVER_TYPE_IS_ENUM__
const gchar *
qmi_loc_server_type_get_string (QmiLocServerType val)
{
    guint i;

    for (i = 0; qmi_loc_server_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_server_type_values[i].value)
            return qmi_loc_server_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_SERVER_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_SERVER_TYPE_IS_FLAGS__
gchar *
qmi_loc_server_type_build_string_from_mask (QmiLocServerType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_server_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_server_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_server_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_server_type_values[i].value) {
            guint c;
            gulong number = qmi_loc_server_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_server_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_SERVER_TYPE_IS_FLAGS__ */
static const GFlagsValue qmi_loc_server_address_type_values[] = {
    { QMI_LOC_SERVER_ADDRESS_TYPE_NONE, "QMI_LOC_SERVER_ADDRESS_TYPE_NONE", "none" },
    { QMI_LOC_SERVER_ADDRESS_TYPE_IPV4, "QMI_LOC_SERVER_ADDRESS_TYPE_IPV4", "ipv4" },
    { QMI_LOC_SERVER_ADDRESS_TYPE_IPV6, "QMI_LOC_SERVER_ADDRESS_TYPE_IPV6", "ipv6" },
    { QMI_LOC_SERVER_ADDRESS_TYPE_URL, "QMI_LOC_SERVER_ADDRESS_TYPE_URL", "url" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_server_address_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiLocServerAddressType"),
                                      qmi_loc_server_address_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_SERVER_ADDRESS_TYPE_IS_ENUM__
const gchar *
qmi_loc_server_address_type_get_string (QmiLocServerAddressType val)
{
    guint i;

    for (i = 0; qmi_loc_server_address_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_server_address_type_values[i].value)
            return qmi_loc_server_address_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_SERVER_ADDRESS_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_SERVER_ADDRESS_TYPE_IS_FLAGS__
gchar *
qmi_loc_server_address_type_build_string_from_mask (QmiLocServerAddressType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_server_address_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_server_address_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_server_address_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_server_address_type_values[i].value) {
            guint c;
            gulong number = qmi_loc_server_address_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_server_address_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_SERVER_ADDRESS_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_loc_predicted_orbits_data_format_values[] = {
    { QMI_LOC_PREDICTED_ORBITS_DATA_FORMAT_XTRA, "QMI_LOC_PREDICTED_ORBITS_DATA_FORMAT_XTRA", "xtra" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_predicted_orbits_data_format_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocPredictedOrbitsDataFormat"),
                                      qmi_loc_predicted_orbits_data_format_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_PREDICTED_ORBITS_DATA_FORMAT_IS_ENUM__
const gchar *
qmi_loc_predicted_orbits_data_format_get_string (QmiLocPredictedOrbitsDataFormat val)
{
    guint i;

    for (i = 0; qmi_loc_predicted_orbits_data_format_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_predicted_orbits_data_format_values[i].value)
            return qmi_loc_predicted_orbits_data_format_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_PREDICTED_ORBITS_DATA_FORMAT_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_PREDICTED_ORBITS_DATA_FORMAT_IS_FLAGS__
gchar *
qmi_loc_predicted_orbits_data_format_build_string_from_mask (QmiLocPredictedOrbitsDataFormat mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_predicted_orbits_data_format_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_predicted_orbits_data_format_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_predicted_orbits_data_format_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_predicted_orbits_data_format_values[i].value) {
            guint c;
            gulong number = qmi_loc_predicted_orbits_data_format_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_predicted_orbits_data_format_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_PREDICTED_ORBITS_DATA_FORMAT_IS_FLAGS__ */
static const GFlagsValue qmi_loc_delete_sv_info_values[] = {
    { QMI_LOC_DELETE_SV_INFO_EPHEMERIS, "QMI_LOC_DELETE_SV_INFO_EPHEMERIS", "ephemeris" },
    { QMI_LOC_DELETE_SV_INFO_ALMANAC, "QMI_LOC_DELETE_SV_INFO_ALMANAC", "almanac" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_delete_sv_info_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiLocDeleteSvInfo"),
                                      qmi_loc_delete_sv_info_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_DELETE_SV_INFO_IS_ENUM__
const gchar *
qmi_loc_delete_sv_info_get_string (QmiLocDeleteSvInfo val)
{
    guint i;

    for (i = 0; qmi_loc_delete_sv_info_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_delete_sv_info_values[i].value)
            return qmi_loc_delete_sv_info_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_DELETE_SV_INFO_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_DELETE_SV_INFO_IS_FLAGS__
gchar *
qmi_loc_delete_sv_info_build_string_from_mask (QmiLocDeleteSvInfo mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_delete_sv_info_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_delete_sv_info_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_delete_sv_info_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_delete_sv_info_values[i].value) {
            guint c;
            gulong number = qmi_loc_delete_sv_info_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_delete_sv_info_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_DELETE_SV_INFO_IS_FLAGS__ */
static const GFlagsValue qmi_loc_delete_cell_database_values[] = {
    { QMI_LOC_DELETE_CELL_DATABASE_POS, "QMI_LOC_DELETE_CELL_DATABASE_POS", "pos" },
    { QMI_LOC_DELETE_CELL_DATABASE_LATEST_GPS_POS, "QMI_LOC_DELETE_CELL_DATABASE_LATEST_GPS_POS", "latest-gps-pos" },
    { QMI_LOC_DELETE_CELL_DATABASE_OTA_POS, "QMI_LOC_DELETE_CELL_DATABASE_OTA_POS", "ota-pos" },
    { QMI_LOC_DELETE_CELL_DATABASE_EXT_REF_POS, "QMI_LOC_DELETE_CELL_DATABASE_EXT_REF_POS", "ext-ref-pos" },
    { QMI_LOC_DELETE_CELL_DATABASE_TIMETAG, "QMI_LOC_DELETE_CELL_DATABASE_TIMETAG", "timetag" },
    { QMI_LOC_DELETE_CELL_DATABASE_CELLID, "QMI_LOC_DELETE_CELL_DATABASE_CELLID", "cellid" },
    { QMI_LOC_DELETE_CELL_DATABASE_CACHED_CELLID, "QMI_LOC_DELETE_CELL_DATABASE_CACHED_CELLID", "cached-cellid" },
    { QMI_LOC_DELETE_CELL_DATABASE_LAST_SRV_CELL, "QMI_LOC_DELETE_CELL_DATABASE_LAST_SRV_CELL", "last-srv-cell" },
    { QMI_LOC_DELETE_CELL_DATABASE_CUR_SRV_CELL, "QMI_LOC_DELETE_CELL_DATABASE_CUR_SRV_CELL", "cur-srv-cell" },
    { QMI_LOC_DELETE_CELL_DATABASE_NEIGHBOR_INFO, "QMI_LOC_DELETE_CELL_DATABASE_NEIGHBOR_INFO", "neighbor-info" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_delete_cell_database_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiLocDeleteCellDatabase"),
                                      qmi_loc_delete_cell_database_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_DELETE_CELL_DATABASE_IS_ENUM__
const gchar *
qmi_loc_delete_cell_database_get_string (QmiLocDeleteCellDatabase val)
{
    guint i;

    for (i = 0; qmi_loc_delete_cell_database_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_delete_cell_database_values[i].value)
            return qmi_loc_delete_cell_database_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_DELETE_CELL_DATABASE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_DELETE_CELL_DATABASE_IS_FLAGS__
gchar *
qmi_loc_delete_cell_database_build_string_from_mask (QmiLocDeleteCellDatabase mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_delete_cell_database_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_delete_cell_database_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_delete_cell_database_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_delete_cell_database_values[i].value) {
            guint c;
            gulong number = qmi_loc_delete_cell_database_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_delete_cell_database_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_DELETE_CELL_DATABASE_IS_FLAGS__ */
static const GFlagsValue qmi_loc_delete_clock_info_values[] = {
    { QMI_LOC_DELETE_CLOCK_INFO_TIME_EST, "QMI_LOC_DELETE_CLOCK_INFO_TIME_EST", "time-est" },
    { QMI_LOC_DELETE_CLOCK_INFO_FREQ_EST, "QMI_LOC_DELETE_CLOCK_INFO_FREQ_EST", "freq-est" },
    { QMI_LOC_DELETE_CLOCK_INFO_WEEK_NUMBER, "QMI_LOC_DELETE_CLOCK_INFO_WEEK_NUMBER", "week-number" },
    { QMI_LOC_DELETE_CLOCK_INFO_RTC_TIME, "QMI_LOC_DELETE_CLOCK_INFO_RTC_TIME", "rtc-time" },
    { QMI_LOC_DELETE_CLOCK_INFO_TIME_TRANSFER, "QMI_LOC_DELETE_CLOCK_INFO_TIME_TRANSFER", "time-transfer" },
    { QMI_LOC_DELETE_CLOCK_INFO_GPS_TIME_EST, "QMI_LOC_DELETE_CLOCK_INFO_GPS_TIME_EST", "gps-time-est" },
    { QMI_LOC_DELETE_CLOCK_INFO_GLO_TIME_EST, "QMI_LOC_DELETE_CLOCK_INFO_GLO_TIME_EST", "glo-time-est" },
    { QMI_LOC_DELETE_CLOCK_INFO_GLO_DAY_NUMBER, "QMI_LOC_DELETE_CLOCK_INFO_GLO_DAY_NUMBER", "glo-day-number" },
    { QMI_LOC_DELETE_CLOCK_INFO_GLO_YEAR_NUMBER, "QMI_LOC_DELETE_CLOCK_INFO_GLO_YEAR_NUMBER", "glo-year-number" },
    { QMI_LOC_DELETE_CLOCK_INFO_GLO_RF_GRP_DELAY, "QMI_LOC_DELETE_CLOCK_INFO_GLO_RF_GRP_DELAY", "glo-rf-grp-delay" },
    { QMI_LOC_DELETE_CLOCK_INFO_DISABLE_TT, "QMI_LOC_DELETE_CLOCK_INFO_DISABLE_TT", "disable-tt" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_delete_clock_info_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiLocDeleteClockInfo"),
                                      qmi_loc_delete_clock_info_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_DELETE_CLOCK_INFO_IS_ENUM__
const gchar *
qmi_loc_delete_clock_info_get_string (QmiLocDeleteClockInfo val)
{
    guint i;

    for (i = 0; qmi_loc_delete_clock_info_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_delete_clock_info_values[i].value)
            return qmi_loc_delete_clock_info_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_DELETE_CLOCK_INFO_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_DELETE_CLOCK_INFO_IS_FLAGS__
gchar *
qmi_loc_delete_clock_info_build_string_from_mask (QmiLocDeleteClockInfo mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_delete_clock_info_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_delete_clock_info_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_delete_clock_info_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_delete_clock_info_values[i].value) {
            guint c;
            gulong number = qmi_loc_delete_clock_info_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_delete_clock_info_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_DELETE_CLOCK_INFO_IS_FLAGS__ */
static const GFlagsValue qmi_loc_nmea_type_values[] = {
    { QMI_LOC_NMEA_TYPE_GGA, "QMI_LOC_NMEA_TYPE_GGA", "gga" },
    { QMI_LOC_NMEA_TYPE_RMC, "QMI_LOC_NMEA_TYPE_RMC", "rmc" },
    { QMI_LOC_NMEA_TYPE_GSV, "QMI_LOC_NMEA_TYPE_GSV", "gsv" },
    { QMI_LOC_NMEA_TYPE_GSA, "QMI_LOC_NMEA_TYPE_GSA", "gsa" },
    { QMI_LOC_NMEA_TYPE_VTG, "QMI_LOC_NMEA_TYPE_VTG", "vtg" },
    { QMI_LOC_NMEA_TYPE_PQXFI, "QMI_LOC_NMEA_TYPE_PQXFI", "pqxfi" },
    { QMI_LOC_NMEA_TYPE_PSTIS, "QMI_LOC_NMEA_TYPE_PSTIS", "pstis" },
    { QMI_LOC_NMEA_TYPE_ALL, "QMI_LOC_NMEA_TYPE_ALL", "all" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_nmea_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiLocNmeaType"),
                                      qmi_loc_nmea_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_NMEA_TYPE_IS_ENUM__
const gchar *
qmi_loc_nmea_type_get_string (QmiLocNmeaType val)
{
    guint i;

    for (i = 0; qmi_loc_nmea_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_nmea_type_values[i].value)
            return qmi_loc_nmea_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_NMEA_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_NMEA_TYPE_IS_FLAGS__
gchar *
qmi_loc_nmea_type_build_string_from_mask (QmiLocNmeaType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_nmea_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_nmea_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_nmea_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_nmea_type_values[i].value) {
            guint c;
            gulong number = qmi_loc_nmea_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_nmea_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_NMEA_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_loc_lock_type_values[] = {
    { QMI_LOC_LOCK_TYPE_NONE, "QMI_LOC_LOCK_TYPE_NONE", "none" },
    { QMI_LOC_LOCK_TYPE_MI, "QMI_LOC_LOCK_TYPE_MI", "mi" },
    { QMI_LOC_LOCK_TYPE_MT, "QMI_LOC_LOCK_TYPE_MT", "mt" },
    { QMI_LOC_LOCK_TYPE_ALL, "QMI_LOC_LOCK_TYPE_ALL", "all" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_loc_lock_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiLocLockType"),
                                      qmi_loc_lock_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_LOC_LOCK_TYPE_IS_ENUM__
const gchar *
qmi_loc_lock_type_get_string (QmiLocLockType val)
{
    guint i;

    for (i = 0; qmi_loc_lock_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_loc_lock_type_values[i].value)
            return qmi_loc_lock_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_LOC_LOCK_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_LOC_LOCK_TYPE_IS_FLAGS__
gchar *
qmi_loc_lock_type_build_string_from_mask (QmiLocLockType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_loc_lock_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_loc_lock_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_loc_lock_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_loc_lock_type_values[i].value) {
            guint c;
            gulong number = qmi_loc_lock_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_loc_lock_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_LOC_LOCK_TYPE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-nas.h" */
static const GEnumValue qmi_nas_radio_interface_values[] = {
    { QMI_NAS_RADIO_INTERFACE_UNKNOWN, "QMI_NAS_RADIO_INTERFACE_UNKNOWN", "unknown" },
    { QMI_NAS_RADIO_INTERFACE_NONE, "QMI_NAS_RADIO_INTERFACE_NONE", "none" },
    { QMI_NAS_RADIO_INTERFACE_CDMA_1X, "QMI_NAS_RADIO_INTERFACE_CDMA_1X", "cdma-1x" },
    { QMI_NAS_RADIO_INTERFACE_CDMA_1XEVDO, "QMI_NAS_RADIO_INTERFACE_CDMA_1XEVDO", "cdma-1xevdo" },
    { QMI_NAS_RADIO_INTERFACE_AMPS, "QMI_NAS_RADIO_INTERFACE_AMPS", "amps" },
    { QMI_NAS_RADIO_INTERFACE_GSM, "QMI_NAS_RADIO_INTERFACE_GSM", "gsm" },
    { QMI_NAS_RADIO_INTERFACE_UMTS, "QMI_NAS_RADIO_INTERFACE_UMTS", "umts" },
    { QMI_NAS_RADIO_INTERFACE_LTE, "QMI_NAS_RADIO_INTERFACE_LTE", "lte" },
    { QMI_NAS_RADIO_INTERFACE_TD_SCDMA, "QMI_NAS_RADIO_INTERFACE_TD_SCDMA", "td-scdma" },
    { QMI_NAS_RADIO_INTERFACE_5GNR, "QMI_NAS_RADIO_INTERFACE_5GNR", "5gnr" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_radio_interface_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasRadioInterface"),
                                      qmi_nas_radio_interface_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
const gchar *
qmi_nas_radio_interface_get_string (QmiNasRadioInterface val)
{
    guint i;

    for (i = 0; qmi_nas_radio_interface_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_radio_interface_values[i].value)
            return qmi_nas_radio_interface_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_RADIO_INTERFACE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
gchar *
qmi_nas_radio_interface_build_string_from_mask (QmiNasRadioInterface mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_radio_interface_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_radio_interface_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_radio_interface_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_radio_interface_values[i].value) {
            guint c;
            gulong number = qmi_nas_radio_interface_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_radio_interface_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__ */
static const GEnumValue qmi_nas_active_band_values[] = {
    { QMI_NAS_ACTIVE_BAND_BC_0, "QMI_NAS_ACTIVE_BAND_BC_0", "bc-0" },
    { QMI_NAS_ACTIVE_BAND_BC_1, "QMI_NAS_ACTIVE_BAND_BC_1", "bc-1" },
    { QMI_NAS_ACTIVE_BAND_BC_2, "QMI_NAS_ACTIVE_BAND_BC_2", "bc-2" },
    { QMI_NAS_ACTIVE_BAND_BC_3, "QMI_NAS_ACTIVE_BAND_BC_3", "bc-3" },
    { QMI_NAS_ACTIVE_BAND_BC_4, "QMI_NAS_ACTIVE_BAND_BC_4", "bc-4" },
    { QMI_NAS_ACTIVE_BAND_BC_5, "QMI_NAS_ACTIVE_BAND_BC_5", "bc-5" },
    { QMI_NAS_ACTIVE_BAND_BC_6, "QMI_NAS_ACTIVE_BAND_BC_6", "bc-6" },
    { QMI_NAS_ACTIVE_BAND_BC_7, "QMI_NAS_ACTIVE_BAND_BC_7", "bc-7" },
    { QMI_NAS_ACTIVE_BAND_BC_8, "QMI_NAS_ACTIVE_BAND_BC_8", "bc-8" },
    { QMI_NAS_ACTIVE_BAND_BC_9, "QMI_NAS_ACTIVE_BAND_BC_9", "bc-9" },
    { QMI_NAS_ACTIVE_BAND_BC_10, "QMI_NAS_ACTIVE_BAND_BC_10", "bc-10" },
    { QMI_NAS_ACTIVE_BAND_BC_11, "QMI_NAS_ACTIVE_BAND_BC_11", "bc-11" },
    { QMI_NAS_ACTIVE_BAND_BC_12, "QMI_NAS_ACTIVE_BAND_BC_12", "bc-12" },
    { QMI_NAS_ACTIVE_BAND_BC_13, "QMI_NAS_ACTIVE_BAND_BC_13", "bc-13" },
    { QMI_NAS_ACTIVE_BAND_BC_14, "QMI_NAS_ACTIVE_BAND_BC_14", "bc-14" },
    { QMI_NAS_ACTIVE_BAND_BC_15, "QMI_NAS_ACTIVE_BAND_BC_15", "bc-15" },
    { QMI_NAS_ACTIVE_BAND_BC_16, "QMI_NAS_ACTIVE_BAND_BC_16", "bc-16" },
    { QMI_NAS_ACTIVE_BAND_BC_17, "QMI_NAS_ACTIVE_BAND_BC_17", "bc-17" },
    { QMI_NAS_ACTIVE_BAND_BC_18, "QMI_NAS_ACTIVE_BAND_BC_18", "bc-18" },
    { QMI_NAS_ACTIVE_BAND_BC_19, "QMI_NAS_ACTIVE_BAND_BC_19", "bc-19" },
    { QMI_NAS_ACTIVE_BAND_GSM_450, "QMI_NAS_ACTIVE_BAND_GSM_450", "gsm-450" },
    { QMI_NAS_ACTIVE_BAND_GSM_480, "QMI_NAS_ACTIVE_BAND_GSM_480", "gsm-480" },
    { QMI_NAS_ACTIVE_BAND_GSM_750, "QMI_NAS_ACTIVE_BAND_GSM_750", "gsm-750" },
    { QMI_NAS_ACTIVE_BAND_GSM_850, "QMI_NAS_ACTIVE_BAND_GSM_850", "gsm-850" },
    { QMI_NAS_ACTIVE_BAND_GSM_900_EXTENDED, "QMI_NAS_ACTIVE_BAND_GSM_900_EXTENDED", "gsm-900-extended" },
    { QMI_NAS_ACTIVE_BAND_GSM_900_PRIMARY, "QMI_NAS_ACTIVE_BAND_GSM_900_PRIMARY", "gsm-900-primary" },
    { QMI_NAS_ACTIVE_BAND_GSM_900_RAILWAYS, "QMI_NAS_ACTIVE_BAND_GSM_900_RAILWAYS", "gsm-900-railways" },
    { QMI_NAS_ACTIVE_BAND_GSM_DCS_1800, "QMI_NAS_ACTIVE_BAND_GSM_DCS_1800", "gsm-dcs-1800" },
    { QMI_NAS_ACTIVE_BAND_GSM_PCS_1900, "QMI_NAS_ACTIVE_BAND_GSM_PCS_1900", "gsm-pcs-1900" },
    { QMI_NAS_ACTIVE_BAND_WCDMA_2100, "QMI_NAS_ACTIVE_BAND_WCDMA_2100", "wcdma-2100" },
    { QMI_NAS_ACTIVE_BAND_WCDMA_PCS_1900, "QMI_NAS_ACTIVE_BAND_WCDMA_PCS_1900", "wcdma-pcs-1900" },
    { QMI_NAS_ACTIVE_BAND_WCDMA_DCS_1800, "QMI_NAS_ACTIVE_BAND_WCDMA_DCS_1800", "wcdma-dcs-1800" },
    { QMI_NAS_ACTIVE_BAND_WCDMA_1700_US, "QMI_NAS_ACTIVE_BAND_WCDMA_1700_US", "wcdma-1700-us" },
    { QMI_NAS_ACTIVE_BAND_WCDMA_850, "QMI_NAS_ACTIVE_BAND_WCDMA_850", "wcdma-850" },
    { QMI_NAS_ACTIVE_BAND_WCDMA_800, "QMI_NAS_ACTIVE_BAND_WCDMA_800", "wcdma-800" },
    { QMI_NAS_ACTIVE_BAND_WCDMA_2600, "QMI_NAS_ACTIVE_BAND_WCDMA_2600", "wcdma-2600" },
    { QMI_NAS_ACTIVE_BAND_WCDMA_900, "QMI_NAS_ACTIVE_BAND_WCDMA_900", "wcdma-900" },
    { QMI_NAS_ACTIVE_BAND_WCDMA_1700_JAPAN, "QMI_NAS_ACTIVE_BAND_WCDMA_1700_JAPAN", "wcdma-1700-japan" },
    { QMI_NAS_ACTIVE_BAND_WCDMA_1500_JAPAN, "QMI_NAS_ACTIVE_BAND_WCDMA_1500_JAPAN", "wcdma-1500-japan" },
    { QMI_NAS_ACTIVE_BAND_WCDMA_850_JAPAN, "QMI_NAS_ACTIVE_BAND_WCDMA_850_JAPAN", "wcdma-850-japan" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_1, "QMI_NAS_ACTIVE_BAND_EUTRAN_1", "eutran-1" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_2, "QMI_NAS_ACTIVE_BAND_EUTRAN_2", "eutran-2" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_3, "QMI_NAS_ACTIVE_BAND_EUTRAN_3", "eutran-3" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_4, "QMI_NAS_ACTIVE_BAND_EUTRAN_4", "eutran-4" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_5, "QMI_NAS_ACTIVE_BAND_EUTRAN_5", "eutran-5" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_6, "QMI_NAS_ACTIVE_BAND_EUTRAN_6", "eutran-6" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_7, "QMI_NAS_ACTIVE_BAND_EUTRAN_7", "eutran-7" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_8, "QMI_NAS_ACTIVE_BAND_EUTRAN_8", "eutran-8" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_9, "QMI_NAS_ACTIVE_BAND_EUTRAN_9", "eutran-9" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_10, "QMI_NAS_ACTIVE_BAND_EUTRAN_10", "eutran-10" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_11, "QMI_NAS_ACTIVE_BAND_EUTRAN_11", "eutran-11" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_12, "QMI_NAS_ACTIVE_BAND_EUTRAN_12", "eutran-12" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_13, "QMI_NAS_ACTIVE_BAND_EUTRAN_13", "eutran-13" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_14, "QMI_NAS_ACTIVE_BAND_EUTRAN_14", "eutran-14" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_17, "QMI_NAS_ACTIVE_BAND_EUTRAN_17", "eutran-17" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_18, "QMI_NAS_ACTIVE_BAND_EUTRAN_18", "eutran-18" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_19, "QMI_NAS_ACTIVE_BAND_EUTRAN_19", "eutran-19" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_20, "QMI_NAS_ACTIVE_BAND_EUTRAN_20", "eutran-20" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_21, "QMI_NAS_ACTIVE_BAND_EUTRAN_21", "eutran-21" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_23, "QMI_NAS_ACTIVE_BAND_EUTRAN_23", "eutran-23" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_24, "QMI_NAS_ACTIVE_BAND_EUTRAN_24", "eutran-24" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_25, "QMI_NAS_ACTIVE_BAND_EUTRAN_25", "eutran-25" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_26, "QMI_NAS_ACTIVE_BAND_EUTRAN_26", "eutran-26" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_27, "QMI_NAS_ACTIVE_BAND_EUTRAN_27", "eutran-27" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_28, "QMI_NAS_ACTIVE_BAND_EUTRAN_28", "eutran-28" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_29, "QMI_NAS_ACTIVE_BAND_EUTRAN_29", "eutran-29" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_30, "QMI_NAS_ACTIVE_BAND_EUTRAN_30", "eutran-30" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_31, "QMI_NAS_ACTIVE_BAND_EUTRAN_31", "eutran-31" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_32, "QMI_NAS_ACTIVE_BAND_EUTRAN_32", "eutran-32" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_33, "QMI_NAS_ACTIVE_BAND_EUTRAN_33", "eutran-33" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_34, "QMI_NAS_ACTIVE_BAND_EUTRAN_34", "eutran-34" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_35, "QMI_NAS_ACTIVE_BAND_EUTRAN_35", "eutran-35" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_36, "QMI_NAS_ACTIVE_BAND_EUTRAN_36", "eutran-36" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_37, "QMI_NAS_ACTIVE_BAND_EUTRAN_37", "eutran-37" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_38, "QMI_NAS_ACTIVE_BAND_EUTRAN_38", "eutran-38" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_39, "QMI_NAS_ACTIVE_BAND_EUTRAN_39", "eutran-39" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_40, "QMI_NAS_ACTIVE_BAND_EUTRAN_40", "eutran-40" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_41, "QMI_NAS_ACTIVE_BAND_EUTRAN_41", "eutran-41" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_42, "QMI_NAS_ACTIVE_BAND_EUTRAN_42", "eutran-42" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_43, "QMI_NAS_ACTIVE_BAND_EUTRAN_43", "eutran-43" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_46, "QMI_NAS_ACTIVE_BAND_EUTRAN_46", "eutran-46" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_47, "QMI_NAS_ACTIVE_BAND_EUTRAN_47", "eutran-47" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_48, "QMI_NAS_ACTIVE_BAND_EUTRAN_48", "eutran-48" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_66, "QMI_NAS_ACTIVE_BAND_EUTRAN_66", "eutran-66" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_71, "QMI_NAS_ACTIVE_BAND_EUTRAN_71", "eutran-71" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_125, "QMI_NAS_ACTIVE_BAND_EUTRAN_125", "eutran-125" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_126, "QMI_NAS_ACTIVE_BAND_EUTRAN_126", "eutran-126" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_127, "QMI_NAS_ACTIVE_BAND_EUTRAN_127", "eutran-127" },
    { QMI_NAS_ACTIVE_BAND_EUTRAN_250, "QMI_NAS_ACTIVE_BAND_EUTRAN_250", "eutran-250" },
    { QMI_NAS_ACTIVE_BAND_TDSCDMA_A, "QMI_NAS_ACTIVE_BAND_TDSCDMA_A", "tdscdma-a" },
    { QMI_NAS_ACTIVE_BAND_TDSCDMA_B, "QMI_NAS_ACTIVE_BAND_TDSCDMA_B", "tdscdma-b" },
    { QMI_NAS_ACTIVE_BAND_TDSCDMA_C, "QMI_NAS_ACTIVE_BAND_TDSCDMA_C", "tdscdma-c" },
    { QMI_NAS_ACTIVE_BAND_TDSCDMA_D, "QMI_NAS_ACTIVE_BAND_TDSCDMA_D", "tdscdma-d" },
    { QMI_NAS_ACTIVE_BAND_TDSCDMA_E, "QMI_NAS_ACTIVE_BAND_TDSCDMA_E", "tdscdma-e" },
    { QMI_NAS_ACTIVE_BAND_TDSCDMA_F, "QMI_NAS_ACTIVE_BAND_TDSCDMA_F", "tdscdma-f" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_active_band_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasActiveBand"),
                                      qmi_nas_active_band_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_ACTIVE_BAND_IS_ENUM__
const gchar *
qmi_nas_active_band_get_string (QmiNasActiveBand val)
{
    guint i;

    for (i = 0; qmi_nas_active_band_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_active_band_values[i].value)
            return qmi_nas_active_band_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_ACTIVE_BAND_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_ACTIVE_BAND_IS_FLAGS__
gchar *
qmi_nas_active_band_build_string_from_mask (QmiNasActiveBand mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_active_band_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_active_band_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_active_band_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_active_band_values[i].value) {
            guint c;
            gulong number = qmi_nas_active_band_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_active_band_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_ACTIVE_BAND_IS_FLAGS__ */
static const GEnumValue qmi_nas_network_service_domain_values[] = {
    { QMI_NAS_NETWORK_SERVICE_DOMAIN_NONE, "QMI_NAS_NETWORK_SERVICE_DOMAIN_NONE", "none" },
    { QMI_NAS_NETWORK_SERVICE_DOMAIN_CS, "QMI_NAS_NETWORK_SERVICE_DOMAIN_CS", "cs" },
    { QMI_NAS_NETWORK_SERVICE_DOMAIN_PS, "QMI_NAS_NETWORK_SERVICE_DOMAIN_PS", "ps" },
    { QMI_NAS_NETWORK_SERVICE_DOMAIN_CS_PS, "QMI_NAS_NETWORK_SERVICE_DOMAIN_CS_PS", "cs-ps" },
    { QMI_NAS_NETWORK_SERVICE_DOMAIN_UNKNOWN, "QMI_NAS_NETWORK_SERVICE_DOMAIN_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_service_domain_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasNetworkServiceDomain"),
                                      qmi_nas_network_service_domain_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
const gchar *
qmi_nas_network_service_domain_get_string (QmiNasNetworkServiceDomain val)
{
    guint i;

    for (i = 0; qmi_nas_network_service_domain_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_service_domain_values[i].value)
            return qmi_nas_network_service_domain_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
gchar *
qmi_nas_network_service_domain_build_string_from_mask (QmiNasNetworkServiceDomain mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_service_domain_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_service_domain_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_service_domain_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_service_domain_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_service_domain_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_service_domain_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__ */
static const GEnumValue qmi_nas_evdo_sinr_level_values[] = {
    { QMI_NAS_EVDO_SINR_LEVEL_0, "QMI_NAS_EVDO_SINR_LEVEL_0", "0" },
    { QMI_NAS_EVDO_SINR_LEVEL_1, "QMI_NAS_EVDO_SINR_LEVEL_1", "1" },
    { QMI_NAS_EVDO_SINR_LEVEL_2, "QMI_NAS_EVDO_SINR_LEVEL_2", "2" },
    { QMI_NAS_EVDO_SINR_LEVEL_3, "QMI_NAS_EVDO_SINR_LEVEL_3", "3" },
    { QMI_NAS_EVDO_SINR_LEVEL_4, "QMI_NAS_EVDO_SINR_LEVEL_4", "4" },
    { QMI_NAS_EVDO_SINR_LEVEL_5, "QMI_NAS_EVDO_SINR_LEVEL_5", "5" },
    { QMI_NAS_EVDO_SINR_LEVEL_6, "QMI_NAS_EVDO_SINR_LEVEL_6", "6" },
    { QMI_NAS_EVDO_SINR_LEVEL_7, "QMI_NAS_EVDO_SINR_LEVEL_7", "7" },
    { QMI_NAS_EVDO_SINR_LEVEL_8, "QMI_NAS_EVDO_SINR_LEVEL_8", "8" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_evdo_sinr_level_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasEvdoSinrLevel"),
                                      qmi_nas_evdo_sinr_level_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_EVDO_SINR_LEVEL_IS_ENUM__
const gchar *
qmi_nas_evdo_sinr_level_get_string (QmiNasEvdoSinrLevel val)
{
    guint i;

    for (i = 0; qmi_nas_evdo_sinr_level_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_evdo_sinr_level_values[i].value)
            return qmi_nas_evdo_sinr_level_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_EVDO_SINR_LEVEL_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_EVDO_SINR_LEVEL_IS_FLAGS__
gchar *
qmi_nas_evdo_sinr_level_build_string_from_mask (QmiNasEvdoSinrLevel mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_evdo_sinr_level_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_evdo_sinr_level_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_evdo_sinr_level_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_evdo_sinr_level_values[i].value) {
            guint c;
            gulong number = qmi_nas_evdo_sinr_level_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_evdo_sinr_level_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_EVDO_SINR_LEVEL_IS_FLAGS__ */
static const GFlagsValue qmi_nas_signal_strength_request_values[] = {
    { QMI_NAS_SIGNAL_STRENGTH_REQUEST_NONE, "QMI_NAS_SIGNAL_STRENGTH_REQUEST_NONE", "none" },
    { QMI_NAS_SIGNAL_STRENGTH_REQUEST_RSSI, "QMI_NAS_SIGNAL_STRENGTH_REQUEST_RSSI", "rssi" },
    { QMI_NAS_SIGNAL_STRENGTH_REQUEST_ECIO, "QMI_NAS_SIGNAL_STRENGTH_REQUEST_ECIO", "ecio" },
    { QMI_NAS_SIGNAL_STRENGTH_REQUEST_IO, "QMI_NAS_SIGNAL_STRENGTH_REQUEST_IO", "io" },
    { QMI_NAS_SIGNAL_STRENGTH_REQUEST_SINR, "QMI_NAS_SIGNAL_STRENGTH_REQUEST_SINR", "sinr" },
    { QMI_NAS_SIGNAL_STRENGTH_REQUEST_ERROR_RATE, "QMI_NAS_SIGNAL_STRENGTH_REQUEST_ERROR_RATE", "error-rate" },
    { QMI_NAS_SIGNAL_STRENGTH_REQUEST_RSRQ, "QMI_NAS_SIGNAL_STRENGTH_REQUEST_RSRQ", "rsrq" },
    { QMI_NAS_SIGNAL_STRENGTH_REQUEST_LTE_SNR, "QMI_NAS_SIGNAL_STRENGTH_REQUEST_LTE_SNR", "lte-snr" },
    { QMI_NAS_SIGNAL_STRENGTH_REQUEST_LTE_RSRP, "QMI_NAS_SIGNAL_STRENGTH_REQUEST_LTE_RSRP", "lte-rsrp" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_signal_strength_request_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiNasSignalStrengthRequest"),
                                      qmi_nas_signal_strength_request_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_SIGNAL_STRENGTH_REQUEST_IS_ENUM__
const gchar *
qmi_nas_signal_strength_request_get_string (QmiNasSignalStrengthRequest val)
{
    guint i;

    for (i = 0; qmi_nas_signal_strength_request_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_signal_strength_request_values[i].value)
            return qmi_nas_signal_strength_request_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_SIGNAL_STRENGTH_REQUEST_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_SIGNAL_STRENGTH_REQUEST_IS_FLAGS__
gchar *
qmi_nas_signal_strength_request_build_string_from_mask (QmiNasSignalStrengthRequest mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_signal_strength_request_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_signal_strength_request_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_signal_strength_request_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_signal_strength_request_values[i].value) {
            guint c;
            gulong number = qmi_nas_signal_strength_request_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_signal_strength_request_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_SIGNAL_STRENGTH_REQUEST_IS_FLAGS__ */
static const GFlagsValue qmi_nas_network_scan_type_values[] = {
    { QMI_NAS_NETWORK_SCAN_TYPE_GSM, "QMI_NAS_NETWORK_SCAN_TYPE_GSM", "gsm" },
    { QMI_NAS_NETWORK_SCAN_TYPE_UMTS, "QMI_NAS_NETWORK_SCAN_TYPE_UMTS", "umts" },
    { QMI_NAS_NETWORK_SCAN_TYPE_LTE, "QMI_NAS_NETWORK_SCAN_TYPE_LTE", "lte" },
    { QMI_NAS_NETWORK_SCAN_TYPE_TD_SCDMA, "QMI_NAS_NETWORK_SCAN_TYPE_TD_SCDMA", "td-scdma" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_scan_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiNasNetworkScanType"),
                                      qmi_nas_network_scan_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_SCAN_TYPE_IS_ENUM__
const gchar *
qmi_nas_network_scan_type_get_string (QmiNasNetworkScanType val)
{
    guint i;

    for (i = 0; qmi_nas_network_scan_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_scan_type_values[i].value)
            return qmi_nas_network_scan_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_SCAN_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_SCAN_TYPE_IS_FLAGS__
gchar *
qmi_nas_network_scan_type_build_string_from_mask (QmiNasNetworkScanType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_scan_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_scan_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_scan_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_scan_type_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_scan_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_scan_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_SCAN_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_nas_network_scan_result_values[] = {
    { QMI_NAS_NETWORK_SCAN_RESULT_SUCCESS, "QMI_NAS_NETWORK_SCAN_RESULT_SUCCESS", "success" },
    { QMI_NAS_NETWORK_SCAN_RESULT_ABORT, "QMI_NAS_NETWORK_SCAN_RESULT_ABORT", "abort" },
    { QMI_NAS_NETWORK_SCAN_RESULT_RADIO_LINK_FAILURE, "QMI_NAS_NETWORK_SCAN_RESULT_RADIO_LINK_FAILURE", "radio-link-failure" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_scan_result_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasNetworkScanResult"),
                                      qmi_nas_network_scan_result_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_SCAN_RESULT_IS_ENUM__
const gchar *
qmi_nas_network_scan_result_get_string (QmiNasNetworkScanResult val)
{
    guint i;

    for (i = 0; qmi_nas_network_scan_result_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_scan_result_values[i].value)
            return qmi_nas_network_scan_result_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_SCAN_RESULT_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_SCAN_RESULT_IS_FLAGS__
gchar *
qmi_nas_network_scan_result_build_string_from_mask (QmiNasNetworkScanResult mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_scan_result_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_scan_result_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_scan_result_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_scan_result_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_scan_result_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_scan_result_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_SCAN_RESULT_IS_FLAGS__ */
static const GFlagsValue qmi_nas_network_status_values[] = {
    { QMI_NAS_NETWORK_STATUS_CURRENT_SERVING, "QMI_NAS_NETWORK_STATUS_CURRENT_SERVING", "current-serving" },
    { QMI_NAS_NETWORK_STATUS_AVAILABLE, "QMI_NAS_NETWORK_STATUS_AVAILABLE", "available" },
    { QMI_NAS_NETWORK_STATUS_HOME, "QMI_NAS_NETWORK_STATUS_HOME", "home" },
    { QMI_NAS_NETWORK_STATUS_ROAMING, "QMI_NAS_NETWORK_STATUS_ROAMING", "roaming" },
    { QMI_NAS_NETWORK_STATUS_FORBIDDEN, "QMI_NAS_NETWORK_STATUS_FORBIDDEN", "forbidden" },
    { QMI_NAS_NETWORK_STATUS_NOT_FORBIDDEN, "QMI_NAS_NETWORK_STATUS_NOT_FORBIDDEN", "not-forbidden" },
    { QMI_NAS_NETWORK_STATUS_PREFERRED, "QMI_NAS_NETWORK_STATUS_PREFERRED", "preferred" },
    { QMI_NAS_NETWORK_STATUS_NOT_PREFERRED, "QMI_NAS_NETWORK_STATUS_NOT_PREFERRED", "not-preferred" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiNasNetworkStatus"),
                                      qmi_nas_network_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_STATUS_IS_ENUM__
const gchar *
qmi_nas_network_status_get_string (QmiNasNetworkStatus val)
{
    guint i;

    for (i = 0; qmi_nas_network_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_status_values[i].value)
            return qmi_nas_network_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_STATUS_IS_FLAGS__
gchar *
qmi_nas_network_status_build_string_from_mask (QmiNasNetworkStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_status_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_nas_network_register_type_values[] = {
    { QMI_NAS_NETWORK_REGISTER_TYPE_AUTOMATIC, "QMI_NAS_NETWORK_REGISTER_TYPE_AUTOMATIC", "automatic" },
    { QMI_NAS_NETWORK_REGISTER_TYPE_MANUAL, "QMI_NAS_NETWORK_REGISTER_TYPE_MANUAL", "manual" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_register_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasNetworkRegisterType"),
                                      qmi_nas_network_register_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_REGISTER_TYPE_IS_ENUM__
const gchar *
qmi_nas_network_register_type_get_string (QmiNasNetworkRegisterType val)
{
    guint i;

    for (i = 0; qmi_nas_network_register_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_register_type_values[i].value)
            return qmi_nas_network_register_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_REGISTER_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_REGISTER_TYPE_IS_FLAGS__
gchar *
qmi_nas_network_register_type_build_string_from_mask (QmiNasNetworkRegisterType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_register_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_register_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_register_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_register_type_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_register_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_register_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_REGISTER_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_nas_ps_attach_action_values[] = {
    { QMI_NAS_PS_ATTACH_ACTION_ATTACH, "QMI_NAS_PS_ATTACH_ACTION_ATTACH", "attach" },
    { QMI_NAS_PS_ATTACH_ACTION_DETACH, "QMI_NAS_PS_ATTACH_ACTION_DETACH", "detach" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_ps_attach_action_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasPsAttachAction"),
                                      qmi_nas_ps_attach_action_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_PS_ATTACH_ACTION_IS_ENUM__
const gchar *
qmi_nas_ps_attach_action_get_string (QmiNasPsAttachAction val)
{
    guint i;

    for (i = 0; qmi_nas_ps_attach_action_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_ps_attach_action_values[i].value)
            return qmi_nas_ps_attach_action_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_PS_ATTACH_ACTION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_PS_ATTACH_ACTION_IS_FLAGS__
gchar *
qmi_nas_ps_attach_action_build_string_from_mask (QmiNasPsAttachAction mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_ps_attach_action_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_ps_attach_action_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_ps_attach_action_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_ps_attach_action_values[i].value) {
            guint c;
            gulong number = qmi_nas_ps_attach_action_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_ps_attach_action_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_PS_ATTACH_ACTION_IS_FLAGS__ */
static const GEnumValue qmi_nas_registration_state_values[] = {
    { QMI_NAS_REGISTRATION_STATE_NOT_REGISTERED, "QMI_NAS_REGISTRATION_STATE_NOT_REGISTERED", "not-registered" },
    { QMI_NAS_REGISTRATION_STATE_REGISTERED, "QMI_NAS_REGISTRATION_STATE_REGISTERED", "registered" },
    { QMI_NAS_REGISTRATION_STATE_NOT_REGISTERED_SEARCHING, "QMI_NAS_REGISTRATION_STATE_NOT_REGISTERED_SEARCHING", "not-registered-searching" },
    { QMI_NAS_REGISTRATION_STATE_REGISTRATION_DENIED, "QMI_NAS_REGISTRATION_STATE_REGISTRATION_DENIED", "registration-denied" },
    { QMI_NAS_REGISTRATION_STATE_UNKNOWN, "QMI_NAS_REGISTRATION_STATE_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_registration_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasRegistrationState"),
                                      qmi_nas_registration_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_REGISTRATION_STATE_IS_ENUM__
const gchar *
qmi_nas_registration_state_get_string (QmiNasRegistrationState val)
{
    guint i;

    for (i = 0; qmi_nas_registration_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_registration_state_values[i].value)
            return qmi_nas_registration_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_REGISTRATION_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_REGISTRATION_STATE_IS_FLAGS__
gchar *
qmi_nas_registration_state_build_string_from_mask (QmiNasRegistrationState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_registration_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_registration_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_registration_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_registration_state_values[i].value) {
            guint c;
            gulong number = qmi_nas_registration_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_registration_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_REGISTRATION_STATE_IS_FLAGS__ */
static const GEnumValue qmi_nas_attach_state_values[] = {
    { QMI_NAS_ATTACH_STATE_UNKNOWN, "QMI_NAS_ATTACH_STATE_UNKNOWN", "unknown" },
    { QMI_NAS_ATTACH_STATE_ATTACHED, "QMI_NAS_ATTACH_STATE_ATTACHED", "attached" },
    { QMI_NAS_ATTACH_STATE_DETACHED, "QMI_NAS_ATTACH_STATE_DETACHED", "detached" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_attach_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasAttachState"),
                                      qmi_nas_attach_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_ATTACH_STATE_IS_ENUM__
const gchar *
qmi_nas_attach_state_get_string (QmiNasAttachState val)
{
    guint i;

    for (i = 0; qmi_nas_attach_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_attach_state_values[i].value)
            return qmi_nas_attach_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_ATTACH_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_ATTACH_STATE_IS_FLAGS__
gchar *
qmi_nas_attach_state_build_string_from_mask (QmiNasAttachState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_attach_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_attach_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_attach_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_attach_state_values[i].value) {
            guint c;
            gulong number = qmi_nas_attach_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_attach_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_ATTACH_STATE_IS_FLAGS__ */
static const GEnumValue qmi_nas_network_type_values[] = {
    { QMI_NAS_NETWORK_TYPE_UNKNOWN, "QMI_NAS_NETWORK_TYPE_UNKNOWN", "unknown" },
    { QMI_NAS_NETWORK_TYPE_3GPP2, "QMI_NAS_NETWORK_TYPE_3GPP2", "3gpp2" },
    { QMI_NAS_NETWORK_TYPE_3GPP, "QMI_NAS_NETWORK_TYPE_3GPP", "3gpp" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasNetworkType"),
                                      qmi_nas_network_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_TYPE_IS_ENUM__
const gchar *
qmi_nas_network_type_get_string (QmiNasNetworkType val)
{
    guint i;

    for (i = 0; qmi_nas_network_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_type_values[i].value)
            return qmi_nas_network_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_TYPE_IS_FLAGS__
gchar *
qmi_nas_network_type_build_string_from_mask (QmiNasNetworkType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_type_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_nas_roaming_indicator_status_values[] = {
    { QMI_NAS_ROAMING_INDICATOR_STATUS_ON, "QMI_NAS_ROAMING_INDICATOR_STATUS_ON", "on" },
    { QMI_NAS_ROAMING_INDICATOR_STATUS_OFF, "QMI_NAS_ROAMING_INDICATOR_STATUS_OFF", "off" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_roaming_indicator_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasRoamingIndicatorStatus"),
                                      qmi_nas_roaming_indicator_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
const gchar *
qmi_nas_roaming_indicator_status_get_string (QmiNasRoamingIndicatorStatus val)
{
    guint i;

    for (i = 0; qmi_nas_roaming_indicator_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_roaming_indicator_status_values[i].value)
            return qmi_nas_roaming_indicator_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
gchar *
qmi_nas_roaming_indicator_status_build_string_from_mask (QmiNasRoamingIndicatorStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_roaming_indicator_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_roaming_indicator_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_roaming_indicator_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_roaming_indicator_status_values[i].value) {
            guint c;
            gulong number = qmi_nas_roaming_indicator_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_roaming_indicator_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_nas_data_capability_values[] = {
    { QMI_NAS_DATA_CAPABILITY_NONE, "QMI_NAS_DATA_CAPABILITY_NONE", "none" },
    { QMI_NAS_DATA_CAPABILITY_GPRS, "QMI_NAS_DATA_CAPABILITY_GPRS", "gprs" },
    { QMI_NAS_DATA_CAPABILITY_EDGE, "QMI_NAS_DATA_CAPABILITY_EDGE", "edge" },
    { QMI_NAS_DATA_CAPABILITY_HSDPA, "QMI_NAS_DATA_CAPABILITY_HSDPA", "hsdpa" },
    { QMI_NAS_DATA_CAPABILITY_HSUPA, "QMI_NAS_DATA_CAPABILITY_HSUPA", "hsupa" },
    { QMI_NAS_DATA_CAPABILITY_WCDMA, "QMI_NAS_DATA_CAPABILITY_WCDMA", "wcdma" },
    { QMI_NAS_DATA_CAPABILITY_CDMA, "QMI_NAS_DATA_CAPABILITY_CDMA", "cdma" },
    { QMI_NAS_DATA_CAPABILITY_EVDO_REV_0, "QMI_NAS_DATA_CAPABILITY_EVDO_REV_0", "evdo-rev-0" },
    { QMI_NAS_DATA_CAPABILITY_EVDO_REV_A, "QMI_NAS_DATA_CAPABILITY_EVDO_REV_A", "evdo-rev-a" },
    { QMI_NAS_DATA_CAPABILITY_GSM, "QMI_NAS_DATA_CAPABILITY_GSM", "gsm" },
    { QMI_NAS_DATA_CAPABILITY_EVDO_REV_B, "QMI_NAS_DATA_CAPABILITY_EVDO_REV_B", "evdo-rev-b" },
    { QMI_NAS_DATA_CAPABILITY_LTE, "QMI_NAS_DATA_CAPABILITY_LTE", "lte" },
    { QMI_NAS_DATA_CAPABILITY_HSDPA_PLUS, "QMI_NAS_DATA_CAPABILITY_HSDPA_PLUS", "hsdpa-plus" },
    { QMI_NAS_DATA_CAPABILITY_DC_HSDPA_PLUS, "QMI_NAS_DATA_CAPABILITY_DC_HSDPA_PLUS", "dc-hsdpa-plus" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_data_capability_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasDataCapability"),
                                      qmi_nas_data_capability_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_DATA_CAPABILITY_IS_ENUM__
const gchar *
qmi_nas_data_capability_get_string (QmiNasDataCapability val)
{
    guint i;

    for (i = 0; qmi_nas_data_capability_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_data_capability_values[i].value)
            return qmi_nas_data_capability_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_DATA_CAPABILITY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_DATA_CAPABILITY_IS_FLAGS__
gchar *
qmi_nas_data_capability_build_string_from_mask (QmiNasDataCapability mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_data_capability_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_data_capability_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_data_capability_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_data_capability_values[i].value) {
            guint c;
            gulong number = qmi_nas_data_capability_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_data_capability_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_DATA_CAPABILITY_IS_FLAGS__ */
static const GEnumValue qmi_nas_service_status_values[] = {
    { QMI_NAS_SERVICE_STATUS_NONE, "QMI_NAS_SERVICE_STATUS_NONE", "none" },
    { QMI_NAS_SERVICE_STATUS_LIMITED, "QMI_NAS_SERVICE_STATUS_LIMITED", "limited" },
    { QMI_NAS_SERVICE_STATUS_AVAILABLE, "QMI_NAS_SERVICE_STATUS_AVAILABLE", "available" },
    { QMI_NAS_SERVICE_STATUS_LIMITED_REGIONAL, "QMI_NAS_SERVICE_STATUS_LIMITED_REGIONAL", "limited-regional" },
    { QMI_NAS_SERVICE_STATUS_POWER_SAVE, "QMI_NAS_SERVICE_STATUS_POWER_SAVE", "power-save" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_service_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasServiceStatus"),
                                      qmi_nas_service_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_SERVICE_STATUS_IS_ENUM__
const gchar *
qmi_nas_service_status_get_string (QmiNasServiceStatus val)
{
    guint i;

    for (i = 0; qmi_nas_service_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_service_status_values[i].value)
            return qmi_nas_service_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_SERVICE_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
gchar *
qmi_nas_service_status_build_string_from_mask (QmiNasServiceStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_service_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_service_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_service_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_service_status_values[i].value) {
            guint c;
            gulong number = qmi_nas_service_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_service_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_SERVICE_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_nas_hdr_personality_values[] = {
    { QMI_NAS_HDR_PERSONALITY_UNKNOWN, "QMI_NAS_HDR_PERSONALITY_UNKNOWN", "unknown" },
    { QMI_NAS_HDR_PERSONALITY_HRPD, "QMI_NAS_HDR_PERSONALITY_HRPD", "hrpd" },
    { QMI_NAS_HDR_PERSONALITY_EHRPD, "QMI_NAS_HDR_PERSONALITY_EHRPD", "ehrpd" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_hdr_personality_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasHdrPersonality"),
                                      qmi_nas_hdr_personality_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_HDR_PERSONALITY_IS_ENUM__
const gchar *
qmi_nas_hdr_personality_get_string (QmiNasHdrPersonality val)
{
    guint i;

    for (i = 0; qmi_nas_hdr_personality_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_hdr_personality_values[i].value)
            return qmi_nas_hdr_personality_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_HDR_PERSONALITY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_HDR_PERSONALITY_IS_FLAGS__
gchar *
qmi_nas_hdr_personality_build_string_from_mask (QmiNasHdrPersonality mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_hdr_personality_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_hdr_personality_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_hdr_personality_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_hdr_personality_values[i].value) {
            guint c;
            gulong number = qmi_nas_hdr_personality_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_hdr_personality_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_HDR_PERSONALITY_IS_FLAGS__ */
static const GEnumValue qmi_nas_call_barring_status_values[] = {
    { QMI_NAS_CALL_BARRING_STATUS_NORMAL_ONLY, "QMI_NAS_CALL_BARRING_STATUS_NORMAL_ONLY", "normal-only" },
    { QMI_NAS_CALL_BARRING_STATUS_EMERGENCY_ONLY, "QMI_NAS_CALL_BARRING_STATUS_EMERGENCY_ONLY", "emergency-only" },
    { QMI_NAS_CALL_BARRING_STATUS_NO_CALLS, "QMI_NAS_CALL_BARRING_STATUS_NO_CALLS", "no-calls" },
    { QMI_NAS_CALL_BARRING_STATUS_ALL_CALLS, "QMI_NAS_CALL_BARRING_STATUS_ALL_CALLS", "all-calls" },
    { QMI_NAS_CALL_BARRING_STATUS_UNKNOWN, "QMI_NAS_CALL_BARRING_STATUS_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_call_barring_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasCallBarringStatus"),
                                      qmi_nas_call_barring_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
const gchar *
qmi_nas_call_barring_status_get_string (QmiNasCallBarringStatus val)
{
    guint i;

    for (i = 0; qmi_nas_call_barring_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_call_barring_status_values[i].value)
            return qmi_nas_call_barring_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
gchar *
qmi_nas_call_barring_status_build_string_from_mask (QmiNasCallBarringStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_call_barring_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_call_barring_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_call_barring_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_call_barring_status_values[i].value) {
            guint c;
            gulong number = qmi_nas_call_barring_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_call_barring_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_nas_network_description_display_values[] = {
    { QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_NO, "QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_NO", "no" },
    { QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_YES, "QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_YES", "yes" },
    { QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_UNKNOWN, "QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_description_display_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasNetworkDescriptionDisplay"),
                                      qmi_nas_network_description_display_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_IS_ENUM__
const gchar *
qmi_nas_network_description_display_get_string (QmiNasNetworkDescriptionDisplay val)
{
    guint i;

    for (i = 0; qmi_nas_network_description_display_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_description_display_values[i].value)
            return qmi_nas_network_description_display_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_IS_FLAGS__
gchar *
qmi_nas_network_description_display_build_string_from_mask (QmiNasNetworkDescriptionDisplay mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_description_display_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_description_display_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_description_display_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_description_display_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_description_display_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_description_display_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_IS_FLAGS__ */
static const GEnumValue qmi_nas_network_description_encoding_values[] = {
    { QMI_NAS_NETWORK_DESCRIPTION_ENCODING_UNSPECIFIED, "QMI_NAS_NETWORK_DESCRIPTION_ENCODING_UNSPECIFIED", "unspecified" },
    { QMI_NAS_NETWORK_DESCRIPTION_ENCODING_ASCII7, "QMI_NAS_NETWORK_DESCRIPTION_ENCODING_ASCII7", "ascii7" },
    { QMI_NAS_NETWORK_DESCRIPTION_ENCODING_UNICODE, "QMI_NAS_NETWORK_DESCRIPTION_ENCODING_UNICODE", "unicode" },
    { QMI_NAS_NETWORK_DESCRIPTION_ENCODING_GSM, "QMI_NAS_NETWORK_DESCRIPTION_ENCODING_GSM", "gsm" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_description_encoding_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasNetworkDescriptionEncoding"),
                                      qmi_nas_network_description_encoding_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_ENUM__
const gchar *
qmi_nas_network_description_encoding_get_string (QmiNasNetworkDescriptionEncoding val)
{
    guint i;

    for (i = 0; qmi_nas_network_description_encoding_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_description_encoding_values[i].value)
            return qmi_nas_network_description_encoding_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_FLAGS__
gchar *
qmi_nas_network_description_encoding_build_string_from_mask (QmiNasNetworkDescriptionEncoding mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_description_encoding_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_description_encoding_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_description_encoding_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_description_encoding_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_description_encoding_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_description_encoding_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_FLAGS__ */
static const GFlagsValue qmi_nas_plmn_access_technology_identifier_values[] = {
    { QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_UNSPECIFIED, "QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_UNSPECIFIED", "unspecified" },
    { QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_GSM_COMPACT, "QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_GSM_COMPACT", "gsm-compact" },
    { QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_GSM, "QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_GSM", "gsm" },
    { QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_NGRAN, "QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_NGRAN", "ngran" },
    { QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_EUTRAN, "QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_EUTRAN", "eutran" },
    { QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_UTRAN, "QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_UTRAN", "utran" },
    { QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_ALL, "QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_ALL", "all" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_plmn_access_technology_identifier_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiNasPlmnAccessTechnologyIdentifier"),
                                      qmi_nas_plmn_access_technology_identifier_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_IS_ENUM__
const gchar *
qmi_nas_plmn_access_technology_identifier_get_string (QmiNasPlmnAccessTechnologyIdentifier val)
{
    guint i;

    for (i = 0; qmi_nas_plmn_access_technology_identifier_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_plmn_access_technology_identifier_values[i].value)
            return qmi_nas_plmn_access_technology_identifier_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_IS_FLAGS__
gchar *
qmi_nas_plmn_access_technology_identifier_build_string_from_mask (QmiNasPlmnAccessTechnologyIdentifier mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_plmn_access_technology_identifier_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_plmn_access_technology_identifier_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_plmn_access_technology_identifier_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_plmn_access_technology_identifier_values[i].value) {
            guint c;
            gulong number = qmi_nas_plmn_access_technology_identifier_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_plmn_access_technology_identifier_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_IS_FLAGS__ */
static const GFlagsValue qmi_nas_radio_technology_preference_values[] = {
    { QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_AUTO, "QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_AUTO", "auto" },
    { QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_3GPP2, "QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_3GPP2", "3gpp2" },
    { QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_3GPP, "QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_3GPP", "3gpp" },
    { QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_AMPS_OR_GSM, "QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_AMPS_OR_GSM", "amps-or-gsm" },
    { QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_CDMA_OR_WCDMA, "QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_CDMA_OR_WCDMA", "cdma-or-wcdma" },
    { QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_HDR, "QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_HDR", "hdr" },
    { QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_LTE, "QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_LTE", "lte" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_radio_technology_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiNasRadioTechnologyPreference"),
                                      qmi_nas_radio_technology_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_ENUM__
const gchar *
qmi_nas_radio_technology_preference_get_string (QmiNasRadioTechnologyPreference val)
{
    guint i;

    for (i = 0; qmi_nas_radio_technology_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_radio_technology_preference_values[i].value)
            return qmi_nas_radio_technology_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_FLAGS__
gchar *
qmi_nas_radio_technology_preference_build_string_from_mask (QmiNasRadioTechnologyPreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_radio_technology_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_radio_technology_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_radio_technology_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_radio_technology_preference_values[i].value) {
            guint c;
            gulong number = qmi_nas_radio_technology_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_radio_technology_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_FLAGS__ */
static const GEnumValue qmi_nas_preference_duration_values[] = {
    { QMI_NAS_PREFERENCE_DURATION_PERMANENT, "QMI_NAS_PREFERENCE_DURATION_PERMANENT", "permanent" },
    { QMI_NAS_PREFERENCE_DURATION_POWER_CYCLE, "QMI_NAS_PREFERENCE_DURATION_POWER_CYCLE", "power-cycle" },
    { QMI_NAS_PREFERENCE_DURATION_ONE_CALL, "QMI_NAS_PREFERENCE_DURATION_ONE_CALL", "one-call" },
    { QMI_NAS_PREFERENCE_DURATION_ONE_CALL_OR_TIME, "QMI_NAS_PREFERENCE_DURATION_ONE_CALL_OR_TIME", "one-call-or-time" },
    { QMI_NAS_PREFERENCE_DURATION_INTERNAL_ONE_CALL_1, "QMI_NAS_PREFERENCE_DURATION_INTERNAL_ONE_CALL_1", "internal-one-call-1" },
    { QMI_NAS_PREFERENCE_DURATION_INTERNAL_ONE_CALL_2, "QMI_NAS_PREFERENCE_DURATION_INTERNAL_ONE_CALL_2", "internal-one-call-2" },
    { QMI_NAS_PREFERENCE_DURATION_INTERNAL_ONE_CALL_3, "QMI_NAS_PREFERENCE_DURATION_INTERNAL_ONE_CALL_3", "internal-one-call-3" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_preference_duration_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasPreferenceDuration"),
                                      qmi_nas_preference_duration_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_PREFERENCE_DURATION_IS_ENUM__
const gchar *
qmi_nas_preference_duration_get_string (QmiNasPreferenceDuration val)
{
    guint i;

    for (i = 0; qmi_nas_preference_duration_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_preference_duration_values[i].value)
            return qmi_nas_preference_duration_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_PREFERENCE_DURATION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_PREFERENCE_DURATION_IS_FLAGS__
gchar *
qmi_nas_preference_duration_build_string_from_mask (QmiNasPreferenceDuration mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_preference_duration_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_preference_duration_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_preference_duration_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_preference_duration_values[i].value) {
            guint c;
            gulong number = qmi_nas_preference_duration_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_preference_duration_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_PREFERENCE_DURATION_IS_FLAGS__ */
static const GFlagsValue qmi_nas_rat_mode_preference_values[] = {
    { QMI_NAS_RAT_MODE_PREFERENCE_CDMA_1X, "QMI_NAS_RAT_MODE_PREFERENCE_CDMA_1X", "cdma-1x" },
    { QMI_NAS_RAT_MODE_PREFERENCE_CDMA_1XEVDO, "QMI_NAS_RAT_MODE_PREFERENCE_CDMA_1XEVDO", "cdma-1xevdo" },
    { QMI_NAS_RAT_MODE_PREFERENCE_GSM, "QMI_NAS_RAT_MODE_PREFERENCE_GSM", "gsm" },
    { QMI_NAS_RAT_MODE_PREFERENCE_UMTS, "QMI_NAS_RAT_MODE_PREFERENCE_UMTS", "umts" },
    { QMI_NAS_RAT_MODE_PREFERENCE_LTE, "QMI_NAS_RAT_MODE_PREFERENCE_LTE", "lte" },
    { QMI_NAS_RAT_MODE_PREFERENCE_TD_SCDMA, "QMI_NAS_RAT_MODE_PREFERENCE_TD_SCDMA", "td-scdma" },
    { QMI_NAS_RAT_MODE_PREFERENCE_5GNR, "QMI_NAS_RAT_MODE_PREFERENCE_5GNR", "5gnr" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_rat_mode_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiNasRatModePreference"),
                                      qmi_nas_rat_mode_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_RAT_MODE_PREFERENCE_IS_ENUM__
const gchar *
qmi_nas_rat_mode_preference_get_string (QmiNasRatModePreference val)
{
    guint i;

    for (i = 0; qmi_nas_rat_mode_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_rat_mode_preference_values[i].value)
            return qmi_nas_rat_mode_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_RAT_MODE_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_RAT_MODE_PREFERENCE_IS_FLAGS__
gchar *
qmi_nas_rat_mode_preference_build_string_from_mask (QmiNasRatModePreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_rat_mode_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_rat_mode_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_rat_mode_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_rat_mode_preference_values[i].value) {
            guint c;
            gulong number = qmi_nas_rat_mode_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_rat_mode_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_RAT_MODE_PREFERENCE_IS_FLAGS__ */
static const GEnumValue qmi_nas_cdma_prl_preference_values[] = {
    { QMI_NAS_CDMA_PRL_PREFERENCE_A_SIDE_ONLY, "QMI_NAS_CDMA_PRL_PREFERENCE_A_SIDE_ONLY", "a-side-only" },
    { QMI_NAS_CDMA_PRL_PREFERENCE_B_SIDE_ONLY, "QMI_NAS_CDMA_PRL_PREFERENCE_B_SIDE_ONLY", "b-side-only" },
    { QMI_NAS_CDMA_PRL_PREFERENCE_ANY, "QMI_NAS_CDMA_PRL_PREFERENCE_ANY", "any" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_cdma_prl_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasCdmaPrlPreference"),
                                      qmi_nas_cdma_prl_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_CDMA_PRL_PREFERENCE_IS_ENUM__
const gchar *
qmi_nas_cdma_prl_preference_get_string (QmiNasCdmaPrlPreference val)
{
    guint i;

    for (i = 0; qmi_nas_cdma_prl_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_cdma_prl_preference_values[i].value)
            return qmi_nas_cdma_prl_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_CDMA_PRL_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_CDMA_PRL_PREFERENCE_IS_FLAGS__
gchar *
qmi_nas_cdma_prl_preference_build_string_from_mask (QmiNasCdmaPrlPreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_cdma_prl_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_cdma_prl_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_cdma_prl_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_cdma_prl_preference_values[i].value) {
            guint c;
            gulong number = qmi_nas_cdma_prl_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_cdma_prl_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_CDMA_PRL_PREFERENCE_IS_FLAGS__ */
static const GEnumValue qmi_nas_roaming_preference_values[] = {
    { QMI_NAS_ROAMING_PREFERENCE_OFF, "QMI_NAS_ROAMING_PREFERENCE_OFF", "off" },
    { QMI_NAS_ROAMING_PREFERENCE_NOT_OFF, "QMI_NAS_ROAMING_PREFERENCE_NOT_OFF", "not-off" },
    { QMI_NAS_ROAMING_PREFERENCE_NOT_FLASHING, "QMI_NAS_ROAMING_PREFERENCE_NOT_FLASHING", "not-flashing" },
    { QMI_NAS_ROAMING_PREFERENCE_ANY, "QMI_NAS_ROAMING_PREFERENCE_ANY", "any" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_roaming_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasRoamingPreference"),
                                      qmi_nas_roaming_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_ROAMING_PREFERENCE_IS_ENUM__
const gchar *
qmi_nas_roaming_preference_get_string (QmiNasRoamingPreference val)
{
    guint i;

    for (i = 0; qmi_nas_roaming_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_roaming_preference_values[i].value)
            return qmi_nas_roaming_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_ROAMING_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_ROAMING_PREFERENCE_IS_FLAGS__
gchar *
qmi_nas_roaming_preference_build_string_from_mask (QmiNasRoamingPreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_roaming_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_roaming_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_roaming_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_roaming_preference_values[i].value) {
            guint c;
            gulong number = qmi_nas_roaming_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_roaming_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_ROAMING_PREFERENCE_IS_FLAGS__ */
static const GEnumValue qmi_nas_network_selection_preference_values[] = {
    { QMI_NAS_NETWORK_SELECTION_PREFERENCE_AUTOMATIC, "QMI_NAS_NETWORK_SELECTION_PREFERENCE_AUTOMATIC", "automatic" },
    { QMI_NAS_NETWORK_SELECTION_PREFERENCE_MANUAL, "QMI_NAS_NETWORK_SELECTION_PREFERENCE_MANUAL", "manual" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_selection_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasNetworkSelectionPreference"),
                                      qmi_nas_network_selection_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_ENUM__
const gchar *
qmi_nas_network_selection_preference_get_string (QmiNasNetworkSelectionPreference val)
{
    guint i;

    for (i = 0; qmi_nas_network_selection_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_selection_preference_values[i].value)
            return qmi_nas_network_selection_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_FLAGS__
gchar *
qmi_nas_network_selection_preference_build_string_from_mask (QmiNasNetworkSelectionPreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_selection_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_selection_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_selection_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_selection_preference_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_selection_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_selection_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_FLAGS__ */
static const GEnumValue qmi_nas_change_duration_values[] = {
    { QMI_NAS_CHANGE_DURATION_POWER_CYCLE, "QMI_NAS_CHANGE_DURATION_POWER_CYCLE", "power-cycle" },
    { QMI_NAS_CHANGE_DURATION_PERMANENT, "QMI_NAS_CHANGE_DURATION_PERMANENT", "permanent" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_change_duration_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasChangeDuration"),
                                      qmi_nas_change_duration_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_CHANGE_DURATION_IS_ENUM__
const gchar *
qmi_nas_change_duration_get_string (QmiNasChangeDuration val)
{
    guint i;

    for (i = 0; qmi_nas_change_duration_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_change_duration_values[i].value)
            return qmi_nas_change_duration_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_CHANGE_DURATION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_CHANGE_DURATION_IS_FLAGS__
gchar *
qmi_nas_change_duration_build_string_from_mask (QmiNasChangeDuration mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_change_duration_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_change_duration_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_change_duration_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_change_duration_values[i].value) {
            guint c;
            gulong number = qmi_nas_change_duration_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_change_duration_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_CHANGE_DURATION_IS_FLAGS__ */
static const GEnumValue qmi_nas_service_domain_preference_values[] = {
    { QMI_NAS_SERVICE_DOMAIN_PREFERENCE_CS_ONLY, "QMI_NAS_SERVICE_DOMAIN_PREFERENCE_CS_ONLY", "cs-only" },
    { QMI_NAS_SERVICE_DOMAIN_PREFERENCE_PS_ONLY, "QMI_NAS_SERVICE_DOMAIN_PREFERENCE_PS_ONLY", "ps-only" },
    { QMI_NAS_SERVICE_DOMAIN_PREFERENCE_CS_PS, "QMI_NAS_SERVICE_DOMAIN_PREFERENCE_CS_PS", "cs-ps" },
    { QMI_NAS_SERVICE_DOMAIN_PREFERENCE_PS_ATTACH, "QMI_NAS_SERVICE_DOMAIN_PREFERENCE_PS_ATTACH", "ps-attach" },
    { QMI_NAS_SERVICE_DOMAIN_PREFERENCE_PS_DETACH, "QMI_NAS_SERVICE_DOMAIN_PREFERENCE_PS_DETACH", "ps-detach" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_service_domain_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasServiceDomainPreference"),
                                      qmi_nas_service_domain_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_ENUM__
const gchar *
qmi_nas_service_domain_preference_get_string (QmiNasServiceDomainPreference val)
{
    guint i;

    for (i = 0; qmi_nas_service_domain_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_service_domain_preference_values[i].value)
            return qmi_nas_service_domain_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_FLAGS__
gchar *
qmi_nas_service_domain_preference_build_string_from_mask (QmiNasServiceDomainPreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_service_domain_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_service_domain_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_service_domain_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_service_domain_preference_values[i].value) {
            guint c;
            gulong number = qmi_nas_service_domain_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_service_domain_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_FLAGS__ */
static const GEnumValue qmi_nas_gsm_wcdma_acquisition_order_preference_values[] = {
    { QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_AUTOMATIC, "QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_AUTOMATIC", "automatic" },
    { QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_GSM, "QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_GSM", "gsm" },
    { QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_WCDMA, "QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_WCDMA", "wcdma" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_gsm_wcdma_acquisition_order_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasGsmWcdmaAcquisitionOrderPreference"),
                                      qmi_nas_gsm_wcdma_acquisition_order_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_ENUM__
const gchar *
qmi_nas_gsm_wcdma_acquisition_order_preference_get_string (QmiNasGsmWcdmaAcquisitionOrderPreference val)
{
    guint i;

    for (i = 0; qmi_nas_gsm_wcdma_acquisition_order_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_gsm_wcdma_acquisition_order_preference_values[i].value)
            return qmi_nas_gsm_wcdma_acquisition_order_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_FLAGS__
gchar *
qmi_nas_gsm_wcdma_acquisition_order_preference_build_string_from_mask (QmiNasGsmWcdmaAcquisitionOrderPreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_gsm_wcdma_acquisition_order_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_gsm_wcdma_acquisition_order_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_gsm_wcdma_acquisition_order_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_gsm_wcdma_acquisition_order_preference_values[i].value) {
            guint c;
            gulong number = qmi_nas_gsm_wcdma_acquisition_order_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_gsm_wcdma_acquisition_order_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_FLAGS__ */
static const GFlagsValue qmi_nas_td_scdma_band_preference_values[] = {
    { QMI_NAS_TD_SCDMA_BAND_PREFERENCE_A, "QMI_NAS_TD_SCDMA_BAND_PREFERENCE_A", "a" },
    { QMI_NAS_TD_SCDMA_BAND_PREFERENCE_B, "QMI_NAS_TD_SCDMA_BAND_PREFERENCE_B", "b" },
    { QMI_NAS_TD_SCDMA_BAND_PREFERENCE_C, "QMI_NAS_TD_SCDMA_BAND_PREFERENCE_C", "c" },
    { QMI_NAS_TD_SCDMA_BAND_PREFERENCE_D, "QMI_NAS_TD_SCDMA_BAND_PREFERENCE_D", "d" },
    { QMI_NAS_TD_SCDMA_BAND_PREFERENCE_E, "QMI_NAS_TD_SCDMA_BAND_PREFERENCE_E", "e" },
    { QMI_NAS_TD_SCDMA_BAND_PREFERENCE_F, "QMI_NAS_TD_SCDMA_BAND_PREFERENCE_F", "f" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_td_scdma_band_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiNasTdScdmaBandPreference"),
                                      qmi_nas_td_scdma_band_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_ENUM__
const gchar *
qmi_nas_td_scdma_band_preference_get_string (QmiNasTdScdmaBandPreference val)
{
    guint i;

    for (i = 0; qmi_nas_td_scdma_band_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_td_scdma_band_preference_values[i].value)
            return qmi_nas_td_scdma_band_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_FLAGS__
gchar *
qmi_nas_td_scdma_band_preference_build_string_from_mask (QmiNasTdScdmaBandPreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_td_scdma_band_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_td_scdma_band_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_td_scdma_band_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_td_scdma_band_preference_values[i].value) {
            guint c;
            gulong number = qmi_nas_td_scdma_band_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_td_scdma_band_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_FLAGS__ */
static const GEnumValue qmi_nas_voice_domain_preference_values[] = {
    { QMI_NAS_VOICE_DOMAIN_PREFERENCE_CS_ONLY, "QMI_NAS_VOICE_DOMAIN_PREFERENCE_CS_ONLY", "cs-only" },
    { QMI_NAS_VOICE_DOMAIN_PREFERENCE_PS_ONLY, "QMI_NAS_VOICE_DOMAIN_PREFERENCE_PS_ONLY", "ps-only" },
    { QMI_NAS_VOICE_DOMAIN_PREFERENCE_CS_PREFERRED, "QMI_NAS_VOICE_DOMAIN_PREFERENCE_CS_PREFERRED", "cs-preferred" },
    { QMI_NAS_VOICE_DOMAIN_PREFERENCE_PS_PREFERRED, "QMI_NAS_VOICE_DOMAIN_PREFERENCE_PS_PREFERRED", "ps-preferred" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_voice_domain_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasVoiceDomainPreference"),
                                      qmi_nas_voice_domain_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_VOICE_DOMAIN_PREFERENCE_IS_ENUM__
const gchar *
qmi_nas_voice_domain_preference_get_string (QmiNasVoiceDomainPreference val)
{
    guint i;

    for (i = 0; qmi_nas_voice_domain_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_voice_domain_preference_values[i].value)
            return qmi_nas_voice_domain_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_VOICE_DOMAIN_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_VOICE_DOMAIN_PREFERENCE_IS_FLAGS__
gchar *
qmi_nas_voice_domain_preference_build_string_from_mask (QmiNasVoiceDomainPreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_voice_domain_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_voice_domain_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_voice_domain_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_voice_domain_preference_values[i].value) {
            guint c;
            gulong number = qmi_nas_voice_domain_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_voice_domain_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_VOICE_DOMAIN_PREFERENCE_IS_FLAGS__ */
static const GEnumValue qmi_nas_network_selection_registration_restriction_values[] = {
    { QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_UNRESTRICTED, "QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_UNRESTRICTED", "unrestricted" },
    { QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_CAMPED_ONLY, "QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_CAMPED_ONLY", "camped-only" },
    { QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_LIMITED, "QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_LIMITED", "limited" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_selection_registration_restriction_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasNetworkSelectionRegistrationRestriction"),
                                      qmi_nas_network_selection_registration_restriction_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_IS_ENUM__
const gchar *
qmi_nas_network_selection_registration_restriction_get_string (QmiNasNetworkSelectionRegistrationRestriction val)
{
    guint i;

    for (i = 0; qmi_nas_network_selection_registration_restriction_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_selection_registration_restriction_values[i].value)
            return qmi_nas_network_selection_registration_restriction_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_IS_FLAGS__
gchar *
qmi_nas_network_selection_registration_restriction_build_string_from_mask (QmiNasNetworkSelectionRegistrationRestriction mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_selection_registration_restriction_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_selection_registration_restriction_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_selection_registration_restriction_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_selection_registration_restriction_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_selection_registration_restriction_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_selection_registration_restriction_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_IS_FLAGS__ */
static const GEnumValue qmi_nas_lte_registration_domain_values[] = {
    { QMI_NAS_LTE_REGISTRATION_DOMAIN_NOT_APPLICABLE, "QMI_NAS_LTE_REGISTRATION_DOMAIN_NOT_APPLICABLE", "not-applicable" },
    { QMI_NAS_LTE_REGISTRATION_DOMAIN_CS_ONLY, "QMI_NAS_LTE_REGISTRATION_DOMAIN_CS_ONLY", "cs-only" },
    { QMI_NAS_LTE_REGISTRATION_DOMAIN_PS_ONLY, "QMI_NAS_LTE_REGISTRATION_DOMAIN_PS_ONLY", "ps-only" },
    { QMI_NAS_LTE_REGISTRATION_DOMAIN_CS_PS, "QMI_NAS_LTE_REGISTRATION_DOMAIN_CS_PS", "cs-ps" },
    { QMI_NAS_LTE_REGISTRATION_DOMAIN_LIMITED_SERVICE, "QMI_NAS_LTE_REGISTRATION_DOMAIN_LIMITED_SERVICE", "limited-service" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_lte_registration_domain_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasLteRegistrationDomain"),
                                      qmi_nas_lte_registration_domain_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_LTE_REGISTRATION_DOMAIN_IS_ENUM__
const gchar *
qmi_nas_lte_registration_domain_get_string (QmiNasLteRegistrationDomain val)
{
    guint i;

    for (i = 0; qmi_nas_lte_registration_domain_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_lte_registration_domain_values[i].value)
            return qmi_nas_lte_registration_domain_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_LTE_REGISTRATION_DOMAIN_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_LTE_REGISTRATION_DOMAIN_IS_FLAGS__
gchar *
qmi_nas_lte_registration_domain_build_string_from_mask (QmiNasLteRegistrationDomain mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_lte_registration_domain_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_lte_registration_domain_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_lte_registration_domain_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_lte_registration_domain_values[i].value) {
            guint c;
            gulong number = qmi_nas_lte_registration_domain_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_lte_registration_domain_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_LTE_REGISTRATION_DOMAIN_IS_FLAGS__ */
static const GEnumValue qmi_nas_roaming_status_values[] = {
    { QMI_NAS_ROAMING_STATUS_OFF, "QMI_NAS_ROAMING_STATUS_OFF", "off" },
    { QMI_NAS_ROAMING_STATUS_ON, "QMI_NAS_ROAMING_STATUS_ON", "on" },
    { QMI_NAS_ROAMING_STATUS_BLINK, "QMI_NAS_ROAMING_STATUS_BLINK", "blink" },
    { QMI_NAS_ROAMING_STATUS_OUT_OF_NEIGHBORHOOD, "QMI_NAS_ROAMING_STATUS_OUT_OF_NEIGHBORHOOD", "out-of-neighborhood" },
    { QMI_NAS_ROAMING_STATUS_OUT_OF_BUILDING, "QMI_NAS_ROAMING_STATUS_OUT_OF_BUILDING", "out-of-building" },
    { QMI_NAS_ROAMING_STATUS_PREFERRED_SYSTEM, "QMI_NAS_ROAMING_STATUS_PREFERRED_SYSTEM", "preferred-system" },
    { QMI_NAS_ROAMING_STATUS_AVAILABLE_SYSTEM, "QMI_NAS_ROAMING_STATUS_AVAILABLE_SYSTEM", "available-system" },
    { QMI_NAS_ROAMING_STATUS_ALLIANCE_PARTNER, "QMI_NAS_ROAMING_STATUS_ALLIANCE_PARTNER", "alliance-partner" },
    { QMI_NAS_ROAMING_STATUS_PREMIUM_PARTNER, "QMI_NAS_ROAMING_STATUS_PREMIUM_PARTNER", "premium-partner" },
    { QMI_NAS_ROAMING_STATUS_FULL_SERVICE, "QMI_NAS_ROAMING_STATUS_FULL_SERVICE", "full-service" },
    { QMI_NAS_ROAMING_STATUS_PARTIAL_SERVICE, "QMI_NAS_ROAMING_STATUS_PARTIAL_SERVICE", "partial-service" },
    { QMI_NAS_ROAMING_STATUS_BANNER_ON, "QMI_NAS_ROAMING_STATUS_BANNER_ON", "banner-on" },
    { QMI_NAS_ROAMING_STATUS_BANNER_OFF, "QMI_NAS_ROAMING_STATUS_BANNER_OFF", "banner-off" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_roaming_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasRoamingStatus"),
                                      qmi_nas_roaming_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_ROAMING_STATUS_IS_ENUM__
const gchar *
qmi_nas_roaming_status_get_string (QmiNasRoamingStatus val)
{
    guint i;

    for (i = 0; qmi_nas_roaming_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_roaming_status_values[i].value)
            return qmi_nas_roaming_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_ROAMING_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
gchar *
qmi_nas_roaming_status_build_string_from_mask (QmiNasRoamingStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_roaming_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_roaming_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_roaming_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_roaming_status_values[i].value) {
            guint c;
            gulong number = qmi_nas_roaming_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_roaming_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_ROAMING_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_nas_lte_cell_access_status_values[] = {
    { QMI_NAS_CELL_ACCESS_STATUS_NORMAL_ONLY, "QMI_NAS_CELL_ACCESS_STATUS_NORMAL_ONLY", "normal-only" },
    { QMI_NAS_CELL_ACCESS_STATUS_EMERGENCY_ONLY, "QMI_NAS_CELL_ACCESS_STATUS_EMERGENCY_ONLY", "emergency-only" },
    { QMI_NAS_CELL_ACCESS_STATUS_NO_CALLS, "QMI_NAS_CELL_ACCESS_STATUS_NO_CALLS", "no-calls" },
    { QMI_NAS_CELL_ACCESS_STATUS_ALL_CALLS, "QMI_NAS_CELL_ACCESS_STATUS_ALL_CALLS", "all-calls" },
    { QMI_NAS_CELL_ACCESS_STATUS_UNKNOWN, "QMI_NAS_CELL_ACCESS_STATUS_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_lte_cell_access_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasLteCellAccessStatus"),
                                      qmi_nas_lte_cell_access_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_LTE_CELL_ACCESS_STATUS_IS_ENUM__
const gchar *
qmi_nas_lte_cell_access_status_get_string (QmiNasLteCellAccessStatus val)
{
    guint i;

    for (i = 0; qmi_nas_lte_cell_access_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_lte_cell_access_status_values[i].value)
            return qmi_nas_lte_cell_access_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_LTE_CELL_ACCESS_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_LTE_CELL_ACCESS_STATUS_IS_FLAGS__
gchar *
qmi_nas_lte_cell_access_status_build_string_from_mask (QmiNasLteCellAccessStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_lte_cell_access_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_lte_cell_access_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_lte_cell_access_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_lte_cell_access_status_values[i].value) {
            guint c;
            gulong number = qmi_nas_lte_cell_access_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_lte_cell_access_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_LTE_CELL_ACCESS_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_nas_hdr_protocol_revision_values[] = {
    { QMI_NAS_HDR_PROTOCOL_REVISION_NONE, "QMI_NAS_HDR_PROTOCOL_REVISION_NONE", "none" },
    { QMI_NAS_HDR_PROTOCOL_REVISION_REL_0, "QMI_NAS_HDR_PROTOCOL_REVISION_REL_0", "rel-0" },
    { QMI_NAS_HDR_PROTOCOL_REVISION_REL_A, "QMI_NAS_HDR_PROTOCOL_REVISION_REL_A", "rel-a" },
    { QMI_NAS_HDR_PROTOCOL_REVISION_REL_B, "QMI_NAS_HDR_PROTOCOL_REVISION_REL_B", "rel-b" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_hdr_protocol_revision_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasHdrProtocolRevision"),
                                      qmi_nas_hdr_protocol_revision_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_HDR_PROTOCOL_REVISION_IS_ENUM__
const gchar *
qmi_nas_hdr_protocol_revision_get_string (QmiNasHdrProtocolRevision val)
{
    guint i;

    for (i = 0; qmi_nas_hdr_protocol_revision_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_hdr_protocol_revision_values[i].value)
            return qmi_nas_hdr_protocol_revision_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_HDR_PROTOCOL_REVISION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_HDR_PROTOCOL_REVISION_IS_FLAGS__
gchar *
qmi_nas_hdr_protocol_revision_build_string_from_mask (QmiNasHdrProtocolRevision mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_hdr_protocol_revision_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_hdr_protocol_revision_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_hdr_protocol_revision_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_hdr_protocol_revision_values[i].value) {
            guint c;
            gulong number = qmi_nas_hdr_protocol_revision_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_hdr_protocol_revision_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_HDR_PROTOCOL_REVISION_IS_FLAGS__ */
static const GEnumValue qmi_nas_wcdma_hs_service_values[] = {
    { QMI_NAS_WCDMA_HS_SERVICE_HSDPA_HSUPA_UNSUPPORTED, "QMI_NAS_WCDMA_HS_SERVICE_HSDPA_HSUPA_UNSUPPORTED", "hsdpa-hsupa-unsupported" },
    { QMI_NAS_WCDMA_HS_SERVICE_HSDPA_SUPPORTED, "QMI_NAS_WCDMA_HS_SERVICE_HSDPA_SUPPORTED", "hsdpa-supported" },
    { QMI_NAS_WCDMA_HS_SERVICE_HSUPA_SUPPORTED, "QMI_NAS_WCDMA_HS_SERVICE_HSUPA_SUPPORTED", "hsupa-supported" },
    { QMI_NAS_WCDMA_HS_SERVICE_HSDPA_HSUPA_SUPPORTED, "QMI_NAS_WCDMA_HS_SERVICE_HSDPA_HSUPA_SUPPORTED", "hsdpa-hsupa-supported" },
    { QMI_NAS_WCDMA_HS_SERVICE_HSDPA_PLUS_SUPPORTED, "QMI_NAS_WCDMA_HS_SERVICE_HSDPA_PLUS_SUPPORTED", "hsdpa-plus-supported" },
    { QMI_NAS_WCDMA_HS_SERVICE_HSDPA_PLUS_HSUPA_SUPPORTED, "QMI_NAS_WCDMA_HS_SERVICE_HSDPA_PLUS_HSUPA_SUPPORTED", "hsdpa-plus-hsupa-supported" },
    { QMI_NAS_WCDMA_HS_SERVICE_DC_HSDPA_PLUS_SUPPORTED, "QMI_NAS_WCDMA_HS_SERVICE_DC_HSDPA_PLUS_SUPPORTED", "dc-hsdpa-plus-supported" },
    { QMI_NAS_WCDMA_HS_SERVICE_DC_HSDPA_PLUS_HSUPA_SUPPORTED, "QMI_NAS_WCDMA_HS_SERVICE_DC_HSDPA_PLUS_HSUPA_SUPPORTED", "dc-hsdpa-plus-hsupa-supported" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_wcdma_hs_service_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasWcdmaHsService"),
                                      qmi_nas_wcdma_hs_service_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
const gchar *
qmi_nas_wcdma_hs_service_get_string (QmiNasWcdmaHsService val)
{
    guint i;

    for (i = 0; qmi_nas_wcdma_hs_service_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_wcdma_hs_service_values[i].value)
            return qmi_nas_wcdma_hs_service_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
gchar *
qmi_nas_wcdma_hs_service_build_string_from_mask (QmiNasWcdmaHsService mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_wcdma_hs_service_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_wcdma_hs_service_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_wcdma_hs_service_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_wcdma_hs_service_values[i].value) {
            guint c;
            gulong number = qmi_nas_wcdma_hs_service_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_wcdma_hs_service_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__ */
static const GEnumValue qmi_nas_cell_broadcast_capability_values[] = {
    { QMI_NAS_CELL_BROADCAST_CAPABILITY_UNKNOWN, "QMI_NAS_CELL_BROADCAST_CAPABILITY_UNKNOWN", "unknown" },
    { QMI_NAS_CELL_BROADCAST_CAPABILITY_OFF, "QMI_NAS_CELL_BROADCAST_CAPABILITY_OFF", "off" },
    { QMI_NAS_CELL_BROADCAST_CAPABILITY_ON, "QMI_NAS_CELL_BROADCAST_CAPABILITY_ON", "on" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_cell_broadcast_capability_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasCellBroadcastCapability"),
                                      qmi_nas_cell_broadcast_capability_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
const gchar *
qmi_nas_cell_broadcast_capability_get_string (QmiNasCellBroadcastCapability val)
{
    guint i;

    for (i = 0; qmi_nas_cell_broadcast_capability_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_cell_broadcast_capability_values[i].value)
            return qmi_nas_cell_broadcast_capability_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
gchar *
qmi_nas_cell_broadcast_capability_build_string_from_mask (QmiNasCellBroadcastCapability mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_cell_broadcast_capability_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_cell_broadcast_capability_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_cell_broadcast_capability_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_cell_broadcast_capability_values[i].value) {
            guint c;
            gulong number = qmi_nas_cell_broadcast_capability_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_cell_broadcast_capability_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__ */
static const GEnumValue qmi_nas_sim_reject_state_values[] = {
    { QMI_NAS_SIM_REJECT_STATE_SIM_UNAVAILABLE, "QMI_NAS_SIM_REJECT_STATE_SIM_UNAVAILABLE", "unavailable" },
    { QMI_NAS_SIM_REJECT_STATE_SIM_AVAILABLE, "QMI_NAS_SIM_REJECT_STATE_SIM_AVAILABLE", "available" },
    { QMI_NAS_SIM_REJECT_STATE_SIM_CS_INVALID, "QMI_NAS_SIM_REJECT_STATE_SIM_CS_INVALID", "cs-invalid" },
    { QMI_NAS_SIM_REJECT_STATE_SIM_PS_INVALID, "QMI_NAS_SIM_REJECT_STATE_SIM_PS_INVALID", "ps-invalid" },
    { QMI_NAS_SIM_REJECT_STATE_SIM_CS_PS_INVALID, "QMI_NAS_SIM_REJECT_STATE_SIM_CS_PS_INVALID", "cs-ps-invalid" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_sim_reject_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasSimRejectState"),
                                      qmi_nas_sim_reject_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_SIM_REJECT_STATE_IS_ENUM__
const gchar *
qmi_nas_sim_reject_state_get_string (QmiNasSimRejectState val)
{
    guint i;

    for (i = 0; qmi_nas_sim_reject_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_sim_reject_state_values[i].value)
            return qmi_nas_sim_reject_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_SIM_REJECT_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_SIM_REJECT_STATE_IS_FLAGS__
gchar *
qmi_nas_sim_reject_state_build_string_from_mask (QmiNasSimRejectState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_sim_reject_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_sim_reject_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_sim_reject_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_sim_reject_state_values[i].value) {
            guint c;
            gulong number = qmi_nas_sim_reject_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_sim_reject_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_SIM_REJECT_STATE_IS_FLAGS__ */
static const GEnumValue qmi_nas_cdma_pilot_type_values[] = {
    { QMI_NAS_CDMA_PILOT_TYPE_ACTIVE, "QMI_NAS_CDMA_PILOT_TYPE_ACTIVE", "active" },
    { QMI_NAS_CDMA_PILOT_TYPE_NEIGHBOR, "QMI_NAS_CDMA_PILOT_TYPE_NEIGHBOR", "neighbor" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_cdma_pilot_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasCdmaPilotType"),
                                      qmi_nas_cdma_pilot_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_CDMA_PILOT_TYPE_IS_ENUM__
const gchar *
qmi_nas_cdma_pilot_type_get_string (QmiNasCdmaPilotType val)
{
    guint i;

    for (i = 0; qmi_nas_cdma_pilot_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_cdma_pilot_type_values[i].value)
            return qmi_nas_cdma_pilot_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_CDMA_PILOT_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_CDMA_PILOT_TYPE_IS_FLAGS__
gchar *
qmi_nas_cdma_pilot_type_build_string_from_mask (QmiNasCdmaPilotType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_cdma_pilot_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_cdma_pilot_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_cdma_pilot_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_cdma_pilot_type_values[i].value) {
            guint c;
            gulong number = qmi_nas_cdma_pilot_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_cdma_pilot_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_CDMA_PILOT_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_nas_day_of_week_values[] = {
    { QMI_NAS_DAY_OF_WEEK_MONDAY, "QMI_NAS_DAY_OF_WEEK_MONDAY", "monday" },
    { QMI_NAS_DAY_OF_WEEK_TUESDAY, "QMI_NAS_DAY_OF_WEEK_TUESDAY", "tuesday" },
    { QMI_NAS_DAY_OF_WEEK_WEDNESDAY, "QMI_NAS_DAY_OF_WEEK_WEDNESDAY", "wednesday" },
    { QMI_NAS_DAY_OF_WEEK_THURSDAY, "QMI_NAS_DAY_OF_WEEK_THURSDAY", "thursday" },
    { QMI_NAS_DAY_OF_WEEK_FRIDAY, "QMI_NAS_DAY_OF_WEEK_FRIDAY", "friday" },
    { QMI_NAS_DAY_OF_WEEK_SATURDAY, "QMI_NAS_DAY_OF_WEEK_SATURDAY", "saturday" },
    { QMI_NAS_DAY_OF_WEEK_SUNDAY, "QMI_NAS_DAY_OF_WEEK_SUNDAY", "sunday" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_day_of_week_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasDayOfWeek"),
                                      qmi_nas_day_of_week_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_DAY_OF_WEEK_IS_ENUM__
const gchar *
qmi_nas_day_of_week_get_string (QmiNasDayOfWeek val)
{
    guint i;

    for (i = 0; qmi_nas_day_of_week_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_day_of_week_values[i].value)
            return qmi_nas_day_of_week_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_DAY_OF_WEEK_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_DAY_OF_WEEK_IS_FLAGS__
gchar *
qmi_nas_day_of_week_build_string_from_mask (QmiNasDayOfWeek mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_day_of_week_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_day_of_week_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_day_of_week_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_day_of_week_values[i].value) {
            guint c;
            gulong number = qmi_nas_day_of_week_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_day_of_week_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_DAY_OF_WEEK_IS_FLAGS__ */
static const GEnumValue qmi_nas_daylight_savings_adjustment_values[] = {
    { QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_NONE, "QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_NONE", "none" },
    { QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_ONE_HOUR, "QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_ONE_HOUR", "one-hour" },
    { QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_TWO_HOURS, "QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_TWO_HOURS", "two-hours" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_daylight_savings_adjustment_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasDaylightSavingsAdjustment"),
                                      qmi_nas_daylight_savings_adjustment_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_IS_ENUM__
const gchar *
qmi_nas_daylight_savings_adjustment_get_string (QmiNasDaylightSavingsAdjustment val)
{
    guint i;

    for (i = 0; qmi_nas_daylight_savings_adjustment_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_daylight_savings_adjustment_values[i].value)
            return qmi_nas_daylight_savings_adjustment_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_IS_FLAGS__
gchar *
qmi_nas_daylight_savings_adjustment_build_string_from_mask (QmiNasDaylightSavingsAdjustment mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_daylight_savings_adjustment_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_daylight_savings_adjustment_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_daylight_savings_adjustment_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_daylight_savings_adjustment_values[i].value) {
            guint c;
            gulong number = qmi_nas_daylight_savings_adjustment_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_daylight_savings_adjustment_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_IS_FLAGS__ */
static const GEnumValue qmi_nas_wcdma_rrc_state_values[] = {
    { QMI_NAS_WCDMA_RRC_STATE_DISCONNECTED, "QMI_NAS_WCDMA_RRC_STATE_DISCONNECTED", "disconnected" },
    { QMI_NAS_WCDMA_RRC_STATE_CELL_PCH, "QMI_NAS_WCDMA_RRC_STATE_CELL_PCH", "cell-pch" },
    { QMI_NAS_WCDMA_RRC_STATE_URA_PCH, "QMI_NAS_WCDMA_RRC_STATE_URA_PCH", "ura-pch" },
    { QMI_NAS_WCDMA_RRC_STATE_CELL_FACH, "QMI_NAS_WCDMA_RRC_STATE_CELL_FACH", "cell-fach" },
    { QMI_NAS_WCDMA_RRC_STATE_CELL_DCH, "QMI_NAS_WCDMA_RRC_STATE_CELL_DCH", "cell-dch" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_wcdma_rrc_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasWcdmaRrcState"),
                                      qmi_nas_wcdma_rrc_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_WCDMA_RRC_STATE_IS_ENUM__
const gchar *
qmi_nas_wcdma_rrc_state_get_string (QmiNasWcdmaRrcState val)
{
    guint i;

    for (i = 0; qmi_nas_wcdma_rrc_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_wcdma_rrc_state_values[i].value)
            return qmi_nas_wcdma_rrc_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_WCDMA_RRC_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_WCDMA_RRC_STATE_IS_FLAGS__
gchar *
qmi_nas_wcdma_rrc_state_build_string_from_mask (QmiNasWcdmaRrcState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_wcdma_rrc_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_wcdma_rrc_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_wcdma_rrc_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_wcdma_rrc_state_values[i].value) {
            guint c;
            gulong number = qmi_nas_wcdma_rrc_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_wcdma_rrc_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_WCDMA_RRC_STATE_IS_FLAGS__ */
static const GEnumValue qmi_nas_dl_bandwidth_values[] = {
    { QMI_NAS_DL_BANDWIDTH_1_4, "QMI_NAS_DL_BANDWIDTH_1_4", "1-4" },
    { QMI_NAS_DL_BANDWIDTH_3, "QMI_NAS_DL_BANDWIDTH_3", "3" },
    { QMI_NAS_DL_BANDWIDTH_5, "QMI_NAS_DL_BANDWIDTH_5", "5" },
    { QMI_NAS_DL_BANDWIDTH_10, "QMI_NAS_DL_BANDWIDTH_10", "10" },
    { QMI_NAS_DL_BANDWIDTH_15, "QMI_NAS_DL_BANDWIDTH_15", "15" },
    { QMI_NAS_DL_BANDWIDTH_20, "QMI_NAS_DL_BANDWIDTH_20", "20" },
    { QMI_NAS_DL_BANDWIDTH_INVALID, "QMI_NAS_DL_BANDWIDTH_INVALID", "invalid" },
    { QMI_NAS_DL_BANDWIDTH_UNKNOWN, "QMI_NAS_DL_BANDWIDTH_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_dl_bandwidth_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasDLBandwidth"),
                                      qmi_nas_dl_bandwidth_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_DL_BANDWIDTH_IS_ENUM__
const gchar *
qmi_nas_dl_bandwidth_get_string (QmiNasDLBandwidth val)
{
    guint i;

    for (i = 0; qmi_nas_dl_bandwidth_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_dl_bandwidth_values[i].value)
            return qmi_nas_dl_bandwidth_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_DL_BANDWIDTH_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_DL_BANDWIDTH_IS_FLAGS__
gchar *
qmi_nas_dl_bandwidth_build_string_from_mask (QmiNasDLBandwidth mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_dl_bandwidth_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_dl_bandwidth_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_dl_bandwidth_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_dl_bandwidth_values[i].value) {
            guint c;
            gulong number = qmi_nas_dl_bandwidth_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_dl_bandwidth_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_DL_BANDWIDTH_IS_FLAGS__ */
static const GEnumValue qmi_nas_scell_state_values[] = {
    { QMI_NAS_SCELL_STATE_DECONFIGURED, "QMI_NAS_SCELL_STATE_DECONFIGURED", "deconfigured" },
    { QMI_NAS_SCELL_STATE_DEACTIVATED, "QMI_NAS_SCELL_STATE_DEACTIVATED", "deactivated" },
    { QMI_NAS_SCELL_STATE_ACTIVATED, "QMI_NAS_SCELL_STATE_ACTIVATED", "activated" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_scell_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasScellState"),
                                      qmi_nas_scell_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_SCELL_STATE_IS_ENUM__
const gchar *
qmi_nas_scell_state_get_string (QmiNasScellState val)
{
    guint i;

    for (i = 0; qmi_nas_scell_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_scell_state_values[i].value)
            return qmi_nas_scell_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_SCELL_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_SCELL_STATE_IS_FLAGS__
gchar *
qmi_nas_scell_state_build_string_from_mask (QmiNasScellState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_scell_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_scell_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_scell_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_scell_state_values[i].value) {
            guint c;
            gulong number = qmi_nas_scell_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_scell_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_SCELL_STATE_IS_FLAGS__ */
static const GEnumValue qmi_nas_plmn_encoding_scheme_values[] = {
    { QMI_NAS_PLMN_ENCODING_SCHEME_GSM, "QMI_NAS_PLMN_ENCODING_SCHEME_GSM", "gsm" },
    { QMI_NAS_PLMN_ENCODING_SCHEME_UCS2LE, "QMI_NAS_PLMN_ENCODING_SCHEME_UCS2LE", "ucs2le" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_plmn_encoding_scheme_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasPlmnEncodingScheme"),
                                      qmi_nas_plmn_encoding_scheme_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_PLMN_ENCODING_SCHEME_IS_ENUM__
const gchar *
qmi_nas_plmn_encoding_scheme_get_string (QmiNasPlmnEncodingScheme val)
{
    guint i;

    for (i = 0; qmi_nas_plmn_encoding_scheme_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_plmn_encoding_scheme_values[i].value)
            return qmi_nas_plmn_encoding_scheme_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_PLMN_ENCODING_SCHEME_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_PLMN_ENCODING_SCHEME_IS_FLAGS__
gchar *
qmi_nas_plmn_encoding_scheme_build_string_from_mask (QmiNasPlmnEncodingScheme mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_plmn_encoding_scheme_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_plmn_encoding_scheme_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_plmn_encoding_scheme_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_plmn_encoding_scheme_values[i].value) {
            guint c;
            gulong number = qmi_nas_plmn_encoding_scheme_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_plmn_encoding_scheme_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_PLMN_ENCODING_SCHEME_IS_FLAGS__ */
static const GFlagsValue qmi_nas_network_name_display_condition_values[] = {
    { QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_DISPLAY_REGISTERED_PLMN_IF_KNOWN_NETWORK, "QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_DISPLAY_REGISTERED_PLMN_IF_KNOWN_NETWORK", "registered-plmn-if-known-network" },
    { QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_DISPLAY_SPN_NOT_REQUIRED_IF_UNKNOWN_NETWORK, "QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_DISPLAY_SPN_NOT_REQUIRED_IF_UNKNOWN_NETWORK", "spn-not-required-if-unknown-network" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_name_display_condition_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiNasNetworkNameDisplayCondition"),
                                      qmi_nas_network_name_display_condition_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_IS_ENUM__
const gchar *
qmi_nas_network_name_display_condition_get_string (QmiNasNetworkNameDisplayCondition val)
{
    guint i;

    for (i = 0; qmi_nas_network_name_display_condition_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_name_display_condition_values[i].value)
            return qmi_nas_network_name_display_condition_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_IS_FLAGS__
gchar *
qmi_nas_network_name_display_condition_build_string_from_mask (QmiNasNetworkNameDisplayCondition mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_name_display_condition_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_name_display_condition_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_name_display_condition_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_name_display_condition_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_name_display_condition_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_name_display_condition_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_IS_FLAGS__ */
static const GEnumValue qmi_nas_plmn_name_country_initials_values[] = {
    { QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_DO_NOT_ADD, "QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_DO_NOT_ADD", "initials-do-not-add" },
    { QMI_NAS_PLMN_NAME_COUNTRY_INIITALS_ADD, "QMI_NAS_PLMN_NAME_COUNTRY_INIITALS_ADD", "iniitals-add" },
    { QMI_NAS_PLMN_NAME_COUNTRY_INIITALS_UNSPECIFIED, "QMI_NAS_PLMN_NAME_COUNTRY_INIITALS_UNSPECIFIED", "iniitals-unspecified" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_plmn_name_country_initials_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasPlmnNameCountryInitials"),
                                      qmi_nas_plmn_name_country_initials_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_ENUM__
const gchar *
qmi_nas_plmn_name_country_initials_get_string (QmiNasPlmnNameCountryInitials val)
{
    guint i;

    for (i = 0; qmi_nas_plmn_name_country_initials_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_plmn_name_country_initials_values[i].value)
            return qmi_nas_plmn_name_country_initials_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_FLAGS__
gchar *
qmi_nas_plmn_name_country_initials_build_string_from_mask (QmiNasPlmnNameCountryInitials mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_plmn_name_country_initials_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_plmn_name_country_initials_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_plmn_name_country_initials_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_plmn_name_country_initials_values[i].value) {
            guint c;
            gulong number = qmi_nas_plmn_name_country_initials_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_plmn_name_country_initials_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_FLAGS__ */
static const GEnumValue qmi_nas_network_name_source_values[] = {
    { QMI_NAS_NETWORK_NAME_SOURCE_UNKNOWN, "QMI_NAS_NETWORK_NAME_SOURCE_UNKNOWN", "unknown" },
    { QMI_NAS_NETWORK_NAME_SOURCE_OPERATOR_PLMN_LIST_AND_PLMN_NETWORK_NAME, "QMI_NAS_NETWORK_NAME_SOURCE_OPERATOR_PLMN_LIST_AND_PLMN_NETWORK_NAME", "operator-plmn-list-and-plmn-network-name" },
    { QMI_NAS_NETWORK_NAME_SOURCE_COMMON_PCN_HANDSET_SPECIFICATION_AND_OPERATOR_NAME_STRING, "QMI_NAS_NETWORK_NAME_SOURCE_COMMON_PCN_HANDSET_SPECIFICATION_AND_OPERATOR_NAME_STRING", "common-pcn-handset-specification-and-operator-name-string" },
    { QMI_NAS_NETWORK_NAME_SOURCE_NITZ, "QMI_NAS_NETWORK_NAME_SOURCE_NITZ", "nitz" },
    { QMI_NAS_NETWORK_NAME_SOURCE_SE13, "QMI_NAS_NETWORK_NAME_SOURCE_SE13", "se13" },
    { QMI_NAS_NETWORK_NAME_SOURCE_MCC_MNC, "QMI_NAS_NETWORK_NAME_SOURCE_MCC_MNC", "mcc-mnc" },
    { QMI_NAS_NETWORK_NAME_SOURCE_SERVICE_PROVIDER_NAME, "QMI_NAS_NETWORK_NAME_SOURCE_SERVICE_PROVIDER_NAME", "service-provider-name" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_network_name_source_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasNetworkNameSource"),
                                      qmi_nas_network_name_source_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_NETWORK_NAME_SOURCE_IS_ENUM__
const gchar *
qmi_nas_network_name_source_get_string (QmiNasNetworkNameSource val)
{
    guint i;

    for (i = 0; qmi_nas_network_name_source_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_network_name_source_values[i].value)
            return qmi_nas_network_name_source_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_NETWORK_NAME_SOURCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_NETWORK_NAME_SOURCE_IS_FLAGS__
gchar *
qmi_nas_network_name_source_build_string_from_mask (QmiNasNetworkNameSource mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_network_name_source_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_network_name_source_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_network_name_source_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_network_name_source_values[i].value) {
            guint c;
            gulong number = qmi_nas_network_name_source_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_network_name_source_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_NETWORK_NAME_SOURCE_IS_FLAGS__ */
static const GEnumValue qmi_nas_plmn_name_spare_bits_values[] = {
    { QMI_NAS_PLMN_NAME_SPARE_BITS_UNKNOWN, "QMI_NAS_PLMN_NAME_SPARE_BITS_UNKNOWN", "unknown" },
    { QMI_NAS_PLMN_NAME_SPARE_BITS_BIT_8, "QMI_NAS_PLMN_NAME_SPARE_BITS_BIT_8", "bit-8" },
    { QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_78, "QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_78", "bits-78" },
    { QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_68, "QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_68", "bits-68" },
    { QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_58, "QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_58", "bits-58" },
    { QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_48, "QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_48", "bits-48" },
    { QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_38, "QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_38", "bits-38" },
    { QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_28, "QMI_NAS_PLMN_NAME_SPARE_BITS_BITS_28", "bits-28" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_plmn_name_spare_bits_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasPlmnNameSpareBits"),
                                      qmi_nas_plmn_name_spare_bits_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__
const gchar *
qmi_nas_plmn_name_spare_bits_get_string (QmiNasPlmnNameSpareBits val)
{
    guint i;

    for (i = 0; qmi_nas_plmn_name_spare_bits_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_plmn_name_spare_bits_values[i].value)
            return qmi_nas_plmn_name_spare_bits_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__
gchar *
qmi_nas_plmn_name_spare_bits_build_string_from_mask (QmiNasPlmnNameSpareBits mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_plmn_name_spare_bits_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_plmn_name_spare_bits_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_plmn_name_spare_bits_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_plmn_name_spare_bits_values[i].value) {
            guint c;
            gulong number = qmi_nas_plmn_name_spare_bits_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_plmn_name_spare_bits_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__ */
static const GEnumValue qmi_nas_usage_preference_values[] = {
    { QMI_NAS_USAGE_PREFERENCE_UNKNOWN, "QMI_NAS_USAGE_PREFERENCE_UNKNOWN", "unknown" },
    { QMI_NAS_USAGE_PREFERENCE_VOICE_CENTRIC, "QMI_NAS_USAGE_PREFERENCE_VOICE_CENTRIC", "voice-centric" },
    { QMI_NAS_USAGE_PREFERENCE_DATA_CENTRIC, "QMI_NAS_USAGE_PREFERENCE_DATA_CENTRIC", "data-centric" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_usage_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasUsagePreference"),
                                      qmi_nas_usage_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_USAGE_PREFERENCE_IS_ENUM__
const gchar *
qmi_nas_usage_preference_get_string (QmiNasUsagePreference val)
{
    guint i;

    for (i = 0; qmi_nas_usage_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_usage_preference_values[i].value)
            return qmi_nas_usage_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_USAGE_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_USAGE_PREFERENCE_IS_FLAGS__
gchar *
qmi_nas_usage_preference_build_string_from_mask (QmiNasUsagePreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_usage_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_usage_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_usage_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_usage_preference_values[i].value) {
            guint c;
            gulong number = qmi_nas_usage_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_usage_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_USAGE_PREFERENCE_IS_FLAGS__ */
static const GEnumValue qmi_nas_swi_modem_mode_values[] = {
    { QMI_NAS_SWI_MODEM_MODE_POWERING_OFF, "QMI_NAS_SWI_MODEM_MODE_POWERING_OFF", "powering-off" },
    { QMI_NAS_SWI_MODEM_MODE_FACTORY_TEST, "QMI_NAS_SWI_MODEM_MODE_FACTORY_TEST", "factory-test" },
    { QMI_NAS_SWI_MODEM_MODE_OFFLINE, "QMI_NAS_SWI_MODEM_MODE_OFFLINE", "offline" },
    { QMI_NAS_SWI_MODEM_MODE_OFFLINE_AMPS, "QMI_NAS_SWI_MODEM_MODE_OFFLINE_AMPS", "offline-amps" },
    { QMI_NAS_SWI_MODEM_MODE_OFFLINE_CDMA, "QMI_NAS_SWI_MODEM_MODE_OFFLINE_CDMA", "offline-cdma" },
    { QMI_NAS_SWI_MODEM_MODE_ONLINE, "QMI_NAS_SWI_MODEM_MODE_ONLINE", "online" },
    { QMI_NAS_SWI_MODEM_MODE_LOW_POWER, "QMI_NAS_SWI_MODEM_MODE_LOW_POWER", "low-power" },
    { QMI_NAS_SWI_MODEM_MODE_RESETTING, "QMI_NAS_SWI_MODEM_MODE_RESETTING", "resetting" },
    { QMI_NAS_SWI_MODEM_MODE_NETWORK_TEST, "QMI_NAS_SWI_MODEM_MODE_NETWORK_TEST", "network-test" },
    { QMI_NAS_SWI_MODEM_MODE_OFFLINE_REQUEST, "QMI_NAS_SWI_MODEM_MODE_OFFLINE_REQUEST", "offline-request" },
    { QMI_NAS_SWI_MODEM_MODE_PSEUDO_ONLINE, "QMI_NAS_SWI_MODEM_MODE_PSEUDO_ONLINE", "pseudo-online" },
    { QMI_NAS_SWI_MODEM_MODE_RESETTING_MODEM, "QMI_NAS_SWI_MODEM_MODE_RESETTING_MODEM", "resetting-modem" },
    { QMI_NAS_SWI_MODEM_MODE_UNKNOWN, "QMI_NAS_SWI_MODEM_MODE_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_swi_modem_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasSwiModemMode"),
                                      qmi_nas_swi_modem_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_SWI_MODEM_MODE_IS_ENUM__
const gchar *
qmi_nas_swi_modem_mode_get_string (QmiNasSwiModemMode val)
{
    guint i;

    for (i = 0; qmi_nas_swi_modem_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_swi_modem_mode_values[i].value)
            return qmi_nas_swi_modem_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_SWI_MODEM_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_SWI_MODEM_MODE_IS_FLAGS__
gchar *
qmi_nas_swi_modem_mode_build_string_from_mask (QmiNasSwiModemMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_swi_modem_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_swi_modem_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_swi_modem_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_swi_modem_mode_values[i].value) {
            guint c;
            gulong number = qmi_nas_swi_modem_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_swi_modem_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_SWI_MODEM_MODE_IS_FLAGS__ */
static const GEnumValue qmi_nas_swi_system_mode_values[] = {
    { QMI_NAS_SWI_SYSTEM_MODE_NO_SERVICE, "QMI_NAS_SWI_SYSTEM_MODE_NO_SERVICE", "no-service" },
    { QMI_NAS_SWI_SYSTEM_MODE_AMPS, "QMI_NAS_SWI_SYSTEM_MODE_AMPS", "amps" },
    { QMI_NAS_SWI_SYSTEM_MODE_CDMA, "QMI_NAS_SWI_SYSTEM_MODE_CDMA", "cdma" },
    { QMI_NAS_SWI_SYSTEM_MODE_GSM, "QMI_NAS_SWI_SYSTEM_MODE_GSM", "gsm" },
    { QMI_NAS_SWI_SYSTEM_MODE_HDR, "QMI_NAS_SWI_SYSTEM_MODE_HDR", "hdr" },
    { QMI_NAS_SWI_SYSTEM_MODE_WCDMA, "QMI_NAS_SWI_SYSTEM_MODE_WCDMA", "wcdma" },
    { QMI_NAS_SWI_SYSTEM_MODE_GPS, "QMI_NAS_SWI_SYSTEM_MODE_GPS", "gps" },
    { QMI_NAS_SWI_SYSTEM_MODE_WLAN, "QMI_NAS_SWI_SYSTEM_MODE_WLAN", "wlan" },
    { QMI_NAS_SWI_SYSTEM_MODE_LTE, "QMI_NAS_SWI_SYSTEM_MODE_LTE", "lte" },
    { QMI_NAS_SWI_SYSTEM_MODE_UNKNOWN, "QMI_NAS_SWI_SYSTEM_MODE_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_swi_system_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasSwiSystemMode"),
                                      qmi_nas_swi_system_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_SWI_SYSTEM_MODE_IS_ENUM__
const gchar *
qmi_nas_swi_system_mode_get_string (QmiNasSwiSystemMode val)
{
    guint i;

    for (i = 0; qmi_nas_swi_system_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_swi_system_mode_values[i].value)
            return qmi_nas_swi_system_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_SWI_SYSTEM_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_SWI_SYSTEM_MODE_IS_FLAGS__
gchar *
qmi_nas_swi_system_mode_build_string_from_mask (QmiNasSwiSystemMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_swi_system_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_swi_system_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_swi_system_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_swi_system_mode_values[i].value) {
            guint c;
            gulong number = qmi_nas_swi_system_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_swi_system_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_SWI_SYSTEM_MODE_IS_FLAGS__ */
static const GEnumValue qmi_nas_swi_ims_reg_state_values[] = {
    { QMI_NAS_SWI_IMS_REG_NO_SRV, "QMI_NAS_SWI_IMS_REG_NO_SRV", "no-srv" },
    { QMI_NAS_SWI_IMS_REG_IN_PROG, "QMI_NAS_SWI_IMS_REG_IN_PROG", "in-prog" },
    { QMI_NAS_SWI_IMS_REG_FAILED, "QMI_NAS_SWI_IMS_REG_FAILED", "failed" },
    { QMI_NAS_SWI_IMS_REG_LIMITED, "QMI_NAS_SWI_IMS_REG_LIMITED", "limited" },
    { QMI_NAS_SWI_IMS_REG_FULL_SRV, "QMI_NAS_SWI_IMS_REG_FULL_SRV", "full-srv" },
    { QMI_NAS_SWI_IMS_REG__UNKNOWN, "QMI_NAS_SWI_IMS_REG__UNKNOWN", "-unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_swi_ims_reg_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasSwiImsRegState"),
                                      qmi_nas_swi_ims_reg_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_SWI_IMS_REG_STATE_IS_ENUM__
const gchar *
qmi_nas_swi_ims_reg_state_get_string (QmiNasSwiImsRegState val)
{
    guint i;

    for (i = 0; qmi_nas_swi_ims_reg_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_swi_ims_reg_state_values[i].value)
            return qmi_nas_swi_ims_reg_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_SWI_IMS_REG_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_SWI_IMS_REG_STATE_IS_FLAGS__
gchar *
qmi_nas_swi_ims_reg_state_build_string_from_mask (QmiNasSwiImsRegState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_swi_ims_reg_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_swi_ims_reg_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_swi_ims_reg_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_swi_ims_reg_state_values[i].value) {
            guint c;
            gulong number = qmi_nas_swi_ims_reg_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_swi_ims_reg_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_SWI_IMS_REG_STATE_IS_FLAGS__ */
static const GEnumValue qmi_nas_swi_ps_state_values[] = {
    { QMI_NAS_SWI_PS_STATE_ATTACHED, "QMI_NAS_SWI_PS_STATE_ATTACHED", "attached" },
    { QMI_NAS_SWI_PS_STATE_DETACHED, "QMI_NAS_SWI_PS_STATE_DETACHED", "detached" },
    { QMI_NAS_SWI_PS_STATE_UNKNOWN, "QMI_NAS_SWI_PS_STATE_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_swi_ps_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasSwiPsState"),
                                      qmi_nas_swi_ps_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_SWI_PS_STATE_IS_ENUM__
const gchar *
qmi_nas_swi_ps_state_get_string (QmiNasSwiPsState val)
{
    guint i;

    for (i = 0; qmi_nas_swi_ps_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_swi_ps_state_values[i].value)
            return qmi_nas_swi_ps_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_SWI_PS_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_SWI_PS_STATE_IS_FLAGS__
gchar *
qmi_nas_swi_ps_state_build_string_from_mask (QmiNasSwiPsState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_swi_ps_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_swi_ps_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_swi_ps_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_swi_ps_state_values[i].value) {
            guint c;
            gulong number = qmi_nas_swi_ps_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_swi_ps_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_SWI_PS_STATE_IS_FLAGS__ */
static const GEnumValue qmi_nas_swi_emm_state_values[] = {
    { QMI_NAS_SWI_EMM_STATE_DEREGISTERED, "QMI_NAS_SWI_EMM_STATE_DEREGISTERED", "deregistered" },
    { QMI_NAS_SWI_EMM_STATE_REG_INITIATED, "QMI_NAS_SWI_EMM_STATE_REG_INITIATED", "reg-initiated" },
    { QMI_NAS_SWI_EMM_STATE_REGISTERED, "QMI_NAS_SWI_EMM_STATE_REGISTERED", "registered" },
    { QMI_NAS_SWI_EMM_STATE_TAU_INITIATED, "QMI_NAS_SWI_EMM_STATE_TAU_INITIATED", "tau-initiated" },
    { QMI_NAS_SWI_EMM_STATE_SR_INITIATED, "QMI_NAS_SWI_EMM_STATE_SR_INITIATED", "sr-initiated" },
    { QMI_NAS_SWI_EMM_STATE_DEREG_INITIATED, "QMI_NAS_SWI_EMM_STATE_DEREG_INITIATED", "dereg-initiated" },
    { QMI_NAS_SWI_EMM_STATE_INVALID, "QMI_NAS_SWI_EMM_STATE_INVALID", "invalid" },
    { QMI_NAS_SWI_EMM_STATE_UNKNOWN, "QMI_NAS_SWI_EMM_STATE_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_swi_emm_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasSwiEmmState"),
                                      qmi_nas_swi_emm_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_SWI_EMM_STATE_IS_ENUM__
const gchar *
qmi_nas_swi_emm_state_get_string (QmiNasSwiEmmState val)
{
    guint i;

    for (i = 0; qmi_nas_swi_emm_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_swi_emm_state_values[i].value)
            return qmi_nas_swi_emm_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_SWI_EMM_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_SWI_EMM_STATE_IS_FLAGS__
gchar *
qmi_nas_swi_emm_state_build_string_from_mask (QmiNasSwiEmmState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_swi_emm_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_swi_emm_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_swi_emm_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_swi_emm_state_values[i].value) {
            guint c;
            gulong number = qmi_nas_swi_emm_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_swi_emm_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_SWI_EMM_STATE_IS_FLAGS__ */
static const GEnumValue qmi_nas_swi_emm_connection_state_values[] = {
    { QMI_NAS_SWI_EMM_CONN_STATE_RRC_IDLE, "QMI_NAS_SWI_EMM_CONN_STATE_RRC_IDLE", "rrc-idle" },
    { QMI_NAS_SWI_EMM_CONN_STATE_WAITING_RRC_CFM, "QMI_NAS_SWI_EMM_CONN_STATE_WAITING_RRC_CFM", "waiting-rrc-cfm" },
    { QMI_NAS_SWI_EMM_CONN_STATE_RRC_CONNECTING, "QMI_NAS_SWI_EMM_CONN_STATE_RRC_CONNECTING", "rrc-connecting" },
    { QMI_NAS_SWI_EMM_CONN_STATE_RRC_RELEASING, "QMI_NAS_SWI_EMM_CONN_STATE_RRC_RELEASING", "rrc-releasing" },
    { QMI_NAS_SWI_EMM_CONN_STATE_UNKNOWN, "QMI_NAS_SWI_EMM_CONN_STATE_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_swi_emm_connection_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasSwiEmmConnectionState"),
                                      qmi_nas_swi_emm_connection_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_SWI_EMM_CONNECTION_STATE_IS_ENUM__
const gchar *
qmi_nas_swi_emm_connection_state_get_string (QmiNasSwiEmmConnectionState val)
{
    guint i;

    for (i = 0; qmi_nas_swi_emm_connection_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_swi_emm_connection_state_values[i].value)
            return qmi_nas_swi_emm_connection_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_SWI_EMM_CONNECTION_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_SWI_EMM_CONNECTION_STATE_IS_FLAGS__
gchar *
qmi_nas_swi_emm_connection_state_build_string_from_mask (QmiNasSwiEmmConnectionState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_swi_emm_connection_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_swi_emm_connection_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_swi_emm_connection_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_swi_emm_connection_state_values[i].value) {
            guint c;
            gulong number = qmi_nas_swi_emm_connection_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_swi_emm_connection_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_SWI_EMM_CONNECTION_STATE_IS_FLAGS__ */
static const GEnumValue qmi_nas_drx_values[] = {
    { QMI_NAS_DRX_UNKNOWN, "QMI_NAS_DRX_UNKNOWN", "unknown" },
    { QMI_NAS_DRX_CN6_T32, "QMI_NAS_DRX_CN6_T32", "cn6-t32" },
    { QMI_NAS_DRX_CN7_T64, "QMI_NAS_DRX_CN7_T64", "cn7-t64" },
    { QMI_NAS_DRX_CN8_T128, "QMI_NAS_DRX_CN8_T128", "cn8-t128" },
    { QMI_NAS_DRX_CN9_T256, "QMI_NAS_DRX_CN9_T256", "cn9-t256" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_drx_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasDrx"),
                                      qmi_nas_drx_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_DRX_IS_ENUM__
const gchar *
qmi_nas_drx_get_string (QmiNasDrx val)
{
    guint i;

    for (i = 0; qmi_nas_drx_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_drx_values[i].value)
            return qmi_nas_drx_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_DRX_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_DRX_IS_FLAGS__
gchar *
qmi_nas_drx_build_string_from_mask (QmiNasDrx mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_drx_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_drx_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_drx_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_drx_values[i].value) {
            guint c;
            gulong number = qmi_nas_drx_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_drx_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_DRX_IS_FLAGS__ */
static const GEnumValue qmi_nas_boolean_values[] = {
    { QMI_NAS_BOOLEAN_FALSE, "QMI_NAS_BOOLEAN_FALSE", "false" },
    { QMI_NAS_BOOLEAN_TRUE, "QMI_NAS_BOOLEAN_TRUE", "true" },
    { QMI_NAS_BOOLEAN_UNKNOWN, "QMI_NAS_BOOLEAN_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_boolean_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasBoolean"),
                                      qmi_nas_boolean_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_BOOLEAN_IS_ENUM__
const gchar *
qmi_nas_boolean_get_string (QmiNasBoolean val)
{
    guint i;

    for (i = 0; qmi_nas_boolean_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_boolean_values[i].value)
            return qmi_nas_boolean_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_BOOLEAN_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_BOOLEAN_IS_FLAGS__
gchar *
qmi_nas_boolean_build_string_from_mask (QmiNasBoolean mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_boolean_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_boolean_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_boolean_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_boolean_values[i].value) {
            guint c;
            gulong number = qmi_nas_boolean_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_boolean_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_BOOLEAN_IS_FLAGS__ */
static const GEnumValue qmi_nas_plmn_language_id_values[] = {
    { QMI_NAS_PLMN_LANGUAGE_ID_UNKNOWN, "QMI_NAS_PLMN_LANGUAGE_ID_UNKNOWN", "unknown" },
    { QMI_NAS_PLMN_LANGUAGE_ID_ZH_TRAD, "QMI_NAS_PLMN_LANGUAGE_ID_ZH_TRAD", "zh-trad" },
    { QMI_NAS_PLMN_LANGUAGE_ID_ZH_SIMP, "QMI_NAS_PLMN_LANGUAGE_ID_ZH_SIMP", "zh-simp" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_plmn_language_id_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasPlmnLanguageId"),
                                      qmi_nas_plmn_language_id_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_PLMN_LANGUAGE_ID_IS_ENUM__
const gchar *
qmi_nas_plmn_language_id_get_string (QmiNasPlmnLanguageId val)
{
    guint i;

    for (i = 0; qmi_nas_plmn_language_id_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_plmn_language_id_values[i].value)
            return qmi_nas_plmn_language_id_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_PLMN_LANGUAGE_ID_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_PLMN_LANGUAGE_ID_IS_FLAGS__
gchar *
qmi_nas_plmn_language_id_build_string_from_mask (QmiNasPlmnLanguageId mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_plmn_language_id_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_plmn_language_id_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_plmn_language_id_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_plmn_language_id_values[i].value) {
            guint c;
            gulong number = qmi_nas_plmn_language_id_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_plmn_language_id_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_PLMN_LANGUAGE_ID_IS_FLAGS__ */
static const GEnumValue qmi_nas_lte_voice_domain_values[] = {
    { QMI_NAS_LTE_VOICE_DOMAIN_NONE, "QMI_NAS_LTE_VOICE_DOMAIN_NONE", "none" },
    { QMI_NAS_LTE_VOICE_DOMAIN_IMS, "QMI_NAS_LTE_VOICE_DOMAIN_IMS", "ims" },
    { QMI_NAS_LTE_VOICE_DOMAIN_1X, "QMI_NAS_LTE_VOICE_DOMAIN_1X", "1x" },
    { QMI_NAS_LTE_VOICE_DOMAIN_3GPP, "QMI_NAS_LTE_VOICE_DOMAIN_3GPP", "3gpp" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_lte_voice_domain_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasLteVoiceDomain"),
                                      qmi_nas_lte_voice_domain_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_LTE_VOICE_DOMAIN_IS_ENUM__
const gchar *
qmi_nas_lte_voice_domain_get_string (QmiNasLteVoiceDomain val)
{
    guint i;

    for (i = 0; qmi_nas_lte_voice_domain_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_lte_voice_domain_values[i].value)
            return qmi_nas_lte_voice_domain_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_LTE_VOICE_DOMAIN_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_LTE_VOICE_DOMAIN_IS_FLAGS__
gchar *
qmi_nas_lte_voice_domain_build_string_from_mask (QmiNasLteVoiceDomain mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_lte_voice_domain_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_lte_voice_domain_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_lte_voice_domain_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_lte_voice_domain_values[i].value) {
            guint c;
            gulong number = qmi_nas_lte_voice_domain_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_lte_voice_domain_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_LTE_VOICE_DOMAIN_IS_FLAGS__ */
static const GEnumValue qmi_nas_reject_cause_values[] = {
    { QMI_NAS_REJECT_CAUSE_NONE, "QMI_NAS_REJECT_CAUSE_NONE", "none" },
    { QMI_NAS_REJECT_CAUSE_IMSI_UNKNOWN_IN_HLR, "QMI_NAS_REJECT_CAUSE_IMSI_UNKNOWN_IN_HLR", "imsi-unknown-in-hlr" },
    { QMI_NAS_REJECT_CAUSE_ILLEGAL_UE, "QMI_NAS_REJECT_CAUSE_ILLEGAL_UE", "illegal-ue" },
    { QMI_NAS_REJECT_CAUSE_IMSI_UNKNOWN_IN_VLR, "QMI_NAS_REJECT_CAUSE_IMSI_UNKNOWN_IN_VLR", "imsi-unknown-in-vlr" },
    { QMI_NAS_REJECT_CAUSE_IMEI_NOT_ACCEPTED, "QMI_NAS_REJECT_CAUSE_IMEI_NOT_ACCEPTED", "imei-not-accepted" },
    { QMI_NAS_REJECT_CAUSE_ILLEGAL_ME, "QMI_NAS_REJECT_CAUSE_ILLEGAL_ME", "illegal-me" },
    { QMI_NAS_REJECT_CAUSE_PS_SERVICES_NOT_ALLOWED, "QMI_NAS_REJECT_CAUSE_PS_SERVICES_NOT_ALLOWED", "ps-services-not-allowed" },
    { QMI_NAS_REJECT_CAUSE_PS_AND_NON_PS_SERVICES_NOT_ALLOWED, "QMI_NAS_REJECT_CAUSE_PS_AND_NON_PS_SERVICES_NOT_ALLOWED", "ps-and-non-ps-services-not-allowed" },
    { QMI_NAS_REJECT_CAUSE_UE_IDENTITY_NOT_DERIVED_BY_NETWORK, "QMI_NAS_REJECT_CAUSE_UE_IDENTITY_NOT_DERIVED_BY_NETWORK", "ue-identity-not-derived-by-network" },
    { QMI_NAS_REJECT_CAUSE_IMPLICITLY_DETACHED, "QMI_NAS_REJECT_CAUSE_IMPLICITLY_DETACHED", "implicitly-detached" },
    { QMI_NAS_REJECT_CAUSE_PLMN_NOT_ALLOWED, "QMI_NAS_REJECT_CAUSE_PLMN_NOT_ALLOWED", "plmn-not-allowed" },
    { QMI_NAS_REJECT_CAUSE_LOCATION_AREA_NOT_ALLOWED, "QMI_NAS_REJECT_CAUSE_LOCATION_AREA_NOT_ALLOWED", "location-area-not-allowed" },
    { QMI_NAS_REJECT_CAUSE_ROAMING_IN_LOCATION_AREA_NOT_ALLOWED, "QMI_NAS_REJECT_CAUSE_ROAMING_IN_LOCATION_AREA_NOT_ALLOWED", "roaming-in-location-area-not-allowed" },
    { QMI_NAS_REJECT_CAUSE_PS_SERVICES_IN_LOCATION_AREA_NOT_ALLOWED, "QMI_NAS_REJECT_CAUSE_PS_SERVICES_IN_LOCATION_AREA_NOT_ALLOWED", "ps-services-in-location-area-not-allowed" },
    { QMI_NAS_REJECT_CAUSE_NO_SUITABLE_CELLS_IN_LOCATION_AREA, "QMI_NAS_REJECT_CAUSE_NO_SUITABLE_CELLS_IN_LOCATION_AREA", "no-suitable-cells-in-location-area" },
    { QMI_NAS_REJECT_CAUSE_MSC_TEMPORARILY_NOT_REACHABLE, "QMI_NAS_REJECT_CAUSE_MSC_TEMPORARILY_NOT_REACHABLE", "msc-temporarily-not-reachable" },
    { QMI_NAS_REJECT_CAUSE_NETWORK_FAILURE, "QMI_NAS_REJECT_CAUSE_NETWORK_FAILURE", "network-failure" },
    { QMI_NAS_REJECT_CAUSE_CS_DOMAIN_NOT_AVAILABLE, "QMI_NAS_REJECT_CAUSE_CS_DOMAIN_NOT_AVAILABLE", "cs-domain-not-available" },
    { QMI_NAS_REJECT_CAUSE_ESM_FAILURE, "QMI_NAS_REJECT_CAUSE_ESM_FAILURE", "esm-failure" },
    { QMI_NAS_REJECT_CAUSE_MAC_FAILURE, "QMI_NAS_REJECT_CAUSE_MAC_FAILURE", "mac-failure" },
    { QMI_NAS_REJECT_CAUSE_SYNCH_FAILURE, "QMI_NAS_REJECT_CAUSE_SYNCH_FAILURE", "synch-failure" },
    { QMI_NAS_REJECT_CAUSE_CONGESTION, "QMI_NAS_REJECT_CAUSE_CONGESTION", "congestion" },
    { QMI_NAS_REJECT_CAUSE_UE_SECURITY_CAPABILITIES_MISMATCH, "QMI_NAS_REJECT_CAUSE_UE_SECURITY_CAPABILITIES_MISMATCH", "ue-security-capabilities-mismatch" },
    { QMI_NAS_REJECT_CAUSE_SECURITY_MODE_REJECTED_UNSPECIFIED, "QMI_NAS_REJECT_CAUSE_SECURITY_MODE_REJECTED_UNSPECIFIED", "security-mode-rejected-unspecified" },
    { QMI_NAS_REJECT_CAUSE_CSG_NOT_AUTHORIZED, "QMI_NAS_REJECT_CAUSE_CSG_NOT_AUTHORIZED", "csg-not-authorized" },
    { QMI_NAS_REJECT_CAUSE_NON_EPS_AUTHENTICATION_UNACCEPTABLE, "QMI_NAS_REJECT_CAUSE_NON_EPS_AUTHENTICATION_UNACCEPTABLE", "non-eps-authentication-unacceptable" },
    { QMI_NAS_REJECT_CAUSE_SMS_PROVIDED_BY_GPRS_IN_ROUTING_AREA, "QMI_NAS_REJECT_CAUSE_SMS_PROVIDED_BY_GPRS_IN_ROUTING_AREA", "sms-provided-by-gprs-in-routing-area" },
    { QMI_NAS_REJECT_CAUSE_REDIRECTION_TO_5GCN_REQUIRED, "QMI_NAS_REJECT_CAUSE_REDIRECTION_TO_5GCN_REQUIRED", "redirection-to-5gcn-required" },
    { QMI_NAS_REJECT_CAUSE_SERVICE_OPTION_NOT_SUPPORTED, "QMI_NAS_REJECT_CAUSE_SERVICE_OPTION_NOT_SUPPORTED", "service-option-not-supported" },
    { QMI_NAS_REJECT_CAUSE_REQUESTED_SERVICE_OPTION_NOT_SUBSCRIBED, "QMI_NAS_REJECT_CAUSE_REQUESTED_SERVICE_OPTION_NOT_SUBSCRIBED", "requested-service-option-not-subscribed" },
    { QMI_NAS_REJECT_CAUSE_SERVICE_OPTION_TEMPORARILY_OUT_OF_ORDER, "QMI_NAS_REJECT_CAUSE_SERVICE_OPTION_TEMPORARILY_OUT_OF_ORDER", "service-option-temporarily-out-of-order" },
    { QMI_NAS_REJECT_CAUSE_REQUESTED_SERVICE_OPTION_NOT_AUTHORIZED, "QMI_NAS_REJECT_CAUSE_REQUESTED_SERVICE_OPTION_NOT_AUTHORIZED", "requested-service-option-not-authorized" },
    { QMI_NAS_REJECT_CAUSE_CALL_CANNOT_BE_IDENTIFIED, "QMI_NAS_REJECT_CAUSE_CALL_CANNOT_BE_IDENTIFIED", "call-cannot-be-identified" },
    { QMI_NAS_REJECT_CAUSE_CS_SERVICE_TEMPORARILY_NOT_AVAILABLE, "QMI_NAS_REJECT_CAUSE_CS_SERVICE_TEMPORARILY_NOT_AVAILABLE", "cs-service-temporarily-not-available" },
    { QMI_NAS_REJECT_CAUSE_NO_EPS_BEARER_CONTEXT_ACTIVATED, "QMI_NAS_REJECT_CAUSE_NO_EPS_BEARER_CONTEXT_ACTIVATED", "no-eps-bearer-context-activated" },
    { QMI_NAS_REJECT_CAUSE_SEVERE_NETWORK_FAILURE, "QMI_NAS_REJECT_CAUSE_SEVERE_NETWORK_FAILURE", "severe-network-failure" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_0, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_0", "retry-upon-entry-into-new-cell-0" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_1, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_1", "retry-upon-entry-into-new-cell-1" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_2, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_2", "retry-upon-entry-into-new-cell-2" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_3, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_3", "retry-upon-entry-into-new-cell-3" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_4, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_4", "retry-upon-entry-into-new-cell-4" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_5, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_5", "retry-upon-entry-into-new-cell-5" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_6, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_6", "retry-upon-entry-into-new-cell-6" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_7, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_7", "retry-upon-entry-into-new-cell-7" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_8, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_8", "retry-upon-entry-into-new-cell-8" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_9, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_9", "retry-upon-entry-into-new-cell-9" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_10, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_10", "retry-upon-entry-into-new-cell-10" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_11, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_11", "retry-upon-entry-into-new-cell-11" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_12, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_12", "retry-upon-entry-into-new-cell-12" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_13, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_13", "retry-upon-entry-into-new-cell-13" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_14, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_14", "retry-upon-entry-into-new-cell-14" },
    { QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_15, "QMI_NAS_REJECT_CAUSE_RETRY_UPON_ENTRY_INTO_NEW_CELL_15", "retry-upon-entry-into-new-cell-15" },
    { QMI_NAS_REJECT_CAUSE_SEMANTICALLY_INCORRECT_MESSAGE, "QMI_NAS_REJECT_CAUSE_SEMANTICALLY_INCORRECT_MESSAGE", "semantically-incorrect-message" },
    { QMI_NAS_REJECT_CAUSE_INVALID_MANDATORY_INFORMATION, "QMI_NAS_REJECT_CAUSE_INVALID_MANDATORY_INFORMATION", "invalid-mandatory-information" },
    { QMI_NAS_REJECT_CAUSE_MESSAGE_TYPE_NON_EXISTENT, "QMI_NAS_REJECT_CAUSE_MESSAGE_TYPE_NON_EXISTENT", "message-type-non-existent" },
    { QMI_NAS_REJECT_CAUSE_MESSAGE_TYPE_NOT_COMPATIBLE, "QMI_NAS_REJECT_CAUSE_MESSAGE_TYPE_NOT_COMPATIBLE", "message-type-not-compatible" },
    { QMI_NAS_REJECT_CAUSE_INFORMATION_ELEMENT_NON_EXISTENT, "QMI_NAS_REJECT_CAUSE_INFORMATION_ELEMENT_NON_EXISTENT", "information-element-non-existent" },
    { QMI_NAS_REJECT_CAUSE_CONDITIONAL_INFORMATION_ELEMENT_ERROR, "QMI_NAS_REJECT_CAUSE_CONDITIONAL_INFORMATION_ELEMENT_ERROR", "conditional-information-element-error" },
    { QMI_NAS_REJECT_CAUSE_MESSAGE_NOT_COMPATIBLE, "QMI_NAS_REJECT_CAUSE_MESSAGE_NOT_COMPATIBLE", "message-not-compatible" },
    { QMI_NAS_REJECT_CAUSE_UNSPECIFIED_PROTOCOL_ERROR, "QMI_NAS_REJECT_CAUSE_UNSPECIFIED_PROTOCOL_ERROR", "unspecified-protocol-error" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_nas_reject_cause_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiNasRejectCause"),
                                      qmi_nas_reject_cause_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_NAS_REJECT_CAUSE_IS_ENUM__
const gchar *
qmi_nas_reject_cause_get_string (QmiNasRejectCause val)
{
    guint i;

    for (i = 0; qmi_nas_reject_cause_values[i].value_nick; i++) {
      if ((gint)val == qmi_nas_reject_cause_values[i].value)
            return qmi_nas_reject_cause_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_NAS_REJECT_CAUSE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_NAS_REJECT_CAUSE_IS_FLAGS__
gchar *
qmi_nas_reject_cause_build_string_from_mask (QmiNasRejectCause mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_nas_reject_cause_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_nas_reject_cause_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_nas_reject_cause_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_nas_reject_cause_values[i].value) {
            guint c;
            gulong number = qmi_nas_reject_cause_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_nas_reject_cause_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_NAS_REJECT_CAUSE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-oma.h" */
static const GEnumValue qmi_oma_session_type_values[] = {
    { QMI_OMA_SESSION_TYPE_CLIENT_INITIATED_DEVICE_CONFIGURE, "QMI_OMA_SESSION_TYPE_CLIENT_INITIATED_DEVICE_CONFIGURE", "client-initiated-device-configure" },
    { QMI_OMA_SESSION_TYPE_CLIENT_INITIATED_PRL_UPDATE, "QMI_OMA_SESSION_TYPE_CLIENT_INITIATED_PRL_UPDATE", "client-initiated-prl-update" },
    { QMI_OMA_SESSION_TYPE_CLIENT_INITIATED_HANDS_FREE_ACTIVATION, "QMI_OMA_SESSION_TYPE_CLIENT_INITIATED_HANDS_FREE_ACTIVATION", "client-initiated-hands-free-activation" },
    { QMI_OMA_SESSION_TYPE_DEVICE_INITIATED_HANDS_FREE_ACTIVATION, "QMI_OMA_SESSION_TYPE_DEVICE_INITIATED_HANDS_FREE_ACTIVATION", "device-initiated-hands-free-activation" },
    { QMI_OMA_SESSION_TYPE_NETWORK_INITIATED_PRL_UPDATE, "QMI_OMA_SESSION_TYPE_NETWORK_INITIATED_PRL_UPDATE", "network-initiated-prl-update" },
    { QMI_OMA_SESSION_TYPE_NETWORK_INITIATED_DEVICE_CONFIGURE, "QMI_OMA_SESSION_TYPE_NETWORK_INITIATED_DEVICE_CONFIGURE", "network-initiated-device-configure" },
    { QMI_OMA_SESSION_TYPE_DEVICE_INITIATED_PRL_UPDATE, "QMI_OMA_SESSION_TYPE_DEVICE_INITIATED_PRL_UPDATE", "device-initiated-prl-update" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_oma_session_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiOmaSessionType"),
                                      qmi_oma_session_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_OMA_SESSION_TYPE_IS_ENUM__
const gchar *
qmi_oma_session_type_get_string (QmiOmaSessionType val)
{
    guint i;

    for (i = 0; qmi_oma_session_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_oma_session_type_values[i].value)
            return qmi_oma_session_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_OMA_SESSION_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_OMA_SESSION_TYPE_IS_FLAGS__
gchar *
qmi_oma_session_type_build_string_from_mask (QmiOmaSessionType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_oma_session_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_oma_session_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_oma_session_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_oma_session_type_values[i].value) {
            guint c;
            gulong number = qmi_oma_session_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_oma_session_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_OMA_SESSION_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_oma_session_state_values[] = {
    { QMI_OMA_SESSION_STATE_COMPLETE_INFORMATION_UPDATED, "QMI_OMA_SESSION_STATE_COMPLETE_INFORMATION_UPDATED", "complete-information-updated" },
    { QMI_OMA_SESSION_STATE_COMPLETE_UPDATED_INFORMATION_UNAVAILABLE, "QMI_OMA_SESSION_STATE_COMPLETE_UPDATED_INFORMATION_UNAVAILABLE", "complete-updated-information-unavailable" },
    { QMI_OMA_SESSION_STATE_FAILED, "QMI_OMA_SESSION_STATE_FAILED", "failed" },
    { QMI_OMA_SESSION_STATE_RETRYING, "QMI_OMA_SESSION_STATE_RETRYING", "retrying" },
    { QMI_OMA_SESSION_STATE_CONNECTING, "QMI_OMA_SESSION_STATE_CONNECTING", "connecting" },
    { QMI_OMA_SESSION_STATE_CONNECTED, "QMI_OMA_SESSION_STATE_CONNECTED", "connected" },
    { QMI_OMA_SESSION_STATE_AUTHENTICATED, "QMI_OMA_SESSION_STATE_AUTHENTICATED", "authenticated" },
    { QMI_OMA_SESSION_STATE_MDN_DOWNLOADED, "QMI_OMA_SESSION_STATE_MDN_DOWNLOADED", "mdn-downloaded" },
    { QMI_OMA_SESSION_STATE_MSID_DOWNLOADED, "QMI_OMA_SESSION_STATE_MSID_DOWNLOADED", "msid-downloaded" },
    { QMI_OMA_SESSION_STATE_PRL_DOWNLOADED, "QMI_OMA_SESSION_STATE_PRL_DOWNLOADED", "prl-downloaded" },
    { QMI_OMA_SESSION_STATE_MIP_PROFILE_DOWNLOADED, "QMI_OMA_SESSION_STATE_MIP_PROFILE_DOWNLOADED", "mip-profile-downloaded" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_oma_session_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiOmaSessionState"),
                                      qmi_oma_session_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_OMA_SESSION_STATE_IS_ENUM__
const gchar *
qmi_oma_session_state_get_string (QmiOmaSessionState val)
{
    guint i;

    for (i = 0; qmi_oma_session_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_oma_session_state_values[i].value)
            return qmi_oma_session_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_OMA_SESSION_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_OMA_SESSION_STATE_IS_FLAGS__
gchar *
qmi_oma_session_state_build_string_from_mask (QmiOmaSessionState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_oma_session_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_oma_session_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_oma_session_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_oma_session_state_values[i].value) {
            guint c;
            gulong number = qmi_oma_session_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_oma_session_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_OMA_SESSION_STATE_IS_FLAGS__ */
static const GEnumValue qmi_oma_session_failed_reason_values[] = {
    { QMI_OMA_SESSION_FAILED_REASON_UNKNOWN, "QMI_OMA_SESSION_FAILED_REASON_UNKNOWN", "unknown" },
    { QMI_OMA_SESSION_FAILED_REASON_NETWORK_UNAVAILABLE, "QMI_OMA_SESSION_FAILED_REASON_NETWORK_UNAVAILABLE", "network-unavailable" },
    { QMI_OMA_SESSION_FAILED_REASON_SERVER_UNAVAILABLE, "QMI_OMA_SESSION_FAILED_REASON_SERVER_UNAVAILABLE", "server-unavailable" },
    { QMI_OMA_SESSION_FAILED_REASON_AUTHENTICATION_FAILED, "QMI_OMA_SESSION_FAILED_REASON_AUTHENTICATION_FAILED", "authentication-failed" },
    { QMI_OMA_SESSION_FAILED_REASON_MAX_RETRY_EXCEEDED, "QMI_OMA_SESSION_FAILED_REASON_MAX_RETRY_EXCEEDED", "max-retry-exceeded" },
    { QMI_OMA_SESSION_FAILED_REASON_SESSION_CANCELLED, "QMI_OMA_SESSION_FAILED_REASON_SESSION_CANCELLED", "session-cancelled" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_oma_session_failed_reason_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiOmaSessionFailedReason"),
                                      qmi_oma_session_failed_reason_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_OMA_SESSION_FAILED_REASON_IS_ENUM__
const gchar *
qmi_oma_session_failed_reason_get_string (QmiOmaSessionFailedReason val)
{
    guint i;

    for (i = 0; qmi_oma_session_failed_reason_values[i].value_nick; i++) {
      if ((gint)val == qmi_oma_session_failed_reason_values[i].value)
            return qmi_oma_session_failed_reason_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_OMA_SESSION_FAILED_REASON_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_OMA_SESSION_FAILED_REASON_IS_FLAGS__
gchar *
qmi_oma_session_failed_reason_build_string_from_mask (QmiOmaSessionFailedReason mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_oma_session_failed_reason_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_oma_session_failed_reason_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_oma_session_failed_reason_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_oma_session_failed_reason_values[i].value) {
            guint c;
            gulong number = qmi_oma_session_failed_reason_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_oma_session_failed_reason_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_OMA_SESSION_FAILED_REASON_IS_FLAGS__ */
static const GEnumValue qmi_oma_hfa_feature_done_state_values[] = {
    { QMI_OMA_HFA_FEATURE_DONE_STATE_NONE, "QMI_OMA_HFA_FEATURE_DONE_STATE_NONE", "none" },
    { QMI_OMA_HFA_FEATURE_DONE_STATE_SUCCEEDED, "QMI_OMA_HFA_FEATURE_DONE_STATE_SUCCEEDED", "succeeded" },
    { QMI_OMA_HFA_FEATURE_DONE_STATE_FAILED, "QMI_OMA_HFA_FEATURE_DONE_STATE_FAILED", "failed" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_oma_hfa_feature_done_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiOmaHfaFeatureDoneState"),
                                      qmi_oma_hfa_feature_done_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_OMA_HFA_FEATURE_DONE_STATE_IS_ENUM__
const gchar *
qmi_oma_hfa_feature_done_state_get_string (QmiOmaHfaFeatureDoneState val)
{
    guint i;

    for (i = 0; qmi_oma_hfa_feature_done_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_oma_hfa_feature_done_state_values[i].value)
            return qmi_oma_hfa_feature_done_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_OMA_HFA_FEATURE_DONE_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_OMA_HFA_FEATURE_DONE_STATE_IS_FLAGS__
gchar *
qmi_oma_hfa_feature_done_state_build_string_from_mask (QmiOmaHfaFeatureDoneState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_oma_hfa_feature_done_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_oma_hfa_feature_done_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_oma_hfa_feature_done_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_oma_hfa_feature_done_state_values[i].value) {
            guint c;
            gulong number = qmi_oma_hfa_feature_done_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_oma_hfa_feature_done_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_OMA_HFA_FEATURE_DONE_STATE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-pbm.h" */
static const GFlagsValue qmi_pbm_event_registration_flag_values[] = {
    { QMI_PBM_EVENT_REGISTRATION_FLAG_RECORD_UPDATE, "QMI_PBM_EVENT_REGISTRATION_FLAG_RECORD_UPDATE", "record-update" },
    { QMI_PBM_EVENT_REGISTRATION_FLAG_PHONEBOOK_READY, "QMI_PBM_EVENT_REGISTRATION_FLAG_PHONEBOOK_READY", "phonebook-ready" },
    { QMI_PBM_EVENT_REGISTRATION_FLAG_EMERGENCY_NUMBER_LIST, "QMI_PBM_EVENT_REGISTRATION_FLAG_EMERGENCY_NUMBER_LIST", "emergency-number-list" },
    { QMI_PBM_EVENT_REGISTRATION_FLAG_HIDDEN_RECORD_STATUS, "QMI_PBM_EVENT_REGISTRATION_FLAG_HIDDEN_RECORD_STATUS", "hidden-record-status" },
    { QMI_PBM_EVENT_REGISTRATION_FLAG_AAS_UPDATE, "QMI_PBM_EVENT_REGISTRATION_FLAG_AAS_UPDATE", "aas-update" },
    { QMI_PBM_EVENT_REGISTRATION_FLAG_GAS_UPDATE, "QMI_PBM_EVENT_REGISTRATION_FLAG_GAS_UPDATE", "gas-update" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_pbm_event_registration_flag_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiPbmEventRegistrationFlag"),
                                      qmi_pbm_event_registration_flag_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_PBM_EVENT_REGISTRATION_FLAG_IS_ENUM__
const gchar *
qmi_pbm_event_registration_flag_get_string (QmiPbmEventRegistrationFlag val)
{
    guint i;

    for (i = 0; qmi_pbm_event_registration_flag_values[i].value_nick; i++) {
      if ((gint)val == qmi_pbm_event_registration_flag_values[i].value)
            return qmi_pbm_event_registration_flag_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_PBM_EVENT_REGISTRATION_FLAG_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_PBM_EVENT_REGISTRATION_FLAG_IS_FLAGS__
gchar *
qmi_pbm_event_registration_flag_build_string_from_mask (QmiPbmEventRegistrationFlag mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_pbm_event_registration_flag_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_pbm_event_registration_flag_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_pbm_event_registration_flag_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_pbm_event_registration_flag_values[i].value) {
            guint c;
            gulong number = qmi_pbm_event_registration_flag_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_pbm_event_registration_flag_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_PBM_EVENT_REGISTRATION_FLAG_IS_FLAGS__ */
static const GFlagsValue qmi_pbm_phonebook_type_values[] = {
    { QMI_PBM_PHONEBOOK_TYPE_ADN, "QMI_PBM_PHONEBOOK_TYPE_ADN", "adn" },
    { QMI_PBM_PHONEBOOK_TYPE_FDN, "QMI_PBM_PHONEBOOK_TYPE_FDN", "fdn" },
    { QMI_PBM_PHONEBOOK_TYPE_MSISDN, "QMI_PBM_PHONEBOOK_TYPE_MSISDN", "msisdn" },
    { QMI_PBM_PHONEBOOK_TYPE_MBDN, "QMI_PBM_PHONEBOOK_TYPE_MBDN", "mbdn" },
    { QMI_PBM_PHONEBOOK_TYPE_SDN, "QMI_PBM_PHONEBOOK_TYPE_SDN", "sdn" },
    { QMI_PBM_PHONEBOOK_TYPE_BDN, "QMI_PBM_PHONEBOOK_TYPE_BDN", "bdn" },
    { QMI_PBM_PHONEBOOK_TYPE_LND, "QMI_PBM_PHONEBOOK_TYPE_LND", "lnd" },
    { QMI_PBM_PHONEBOOK_TYPE_MBN, "QMI_PBM_PHONEBOOK_TYPE_MBN", "mbn" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_pbm_phonebook_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiPbmPhonebookType"),
                                      qmi_pbm_phonebook_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_PBM_PHONEBOOK_TYPE_IS_ENUM__
const gchar *
qmi_pbm_phonebook_type_get_string (QmiPbmPhonebookType val)
{
    guint i;

    for (i = 0; qmi_pbm_phonebook_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_pbm_phonebook_type_values[i].value)
            return qmi_pbm_phonebook_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_PBM_PHONEBOOK_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_PBM_PHONEBOOK_TYPE_IS_FLAGS__
gchar *
qmi_pbm_phonebook_type_build_string_from_mask (QmiPbmPhonebookType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_pbm_phonebook_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_pbm_phonebook_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_pbm_phonebook_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_pbm_phonebook_type_values[i].value) {
            guint c;
            gulong number = qmi_pbm_phonebook_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_pbm_phonebook_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_PBM_PHONEBOOK_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_pbm_session_type_values[] = {
    { QMI_PBM_SESSION_TYPE_GW_PRIMARY, "QMI_PBM_SESSION_TYPE_GW_PRIMARY", "gw-primary" },
    { QMI_PBM_SESSION_TYPE_1X_PRIMARY, "QMI_PBM_SESSION_TYPE_1X_PRIMARY", "1x-primary" },
    { QMI_PBM_SESSION_TYPE_GW_SECONDARY, "QMI_PBM_SESSION_TYPE_GW_SECONDARY", "gw-secondary" },
    { QMI_PBM_SESSION_TYPE_1X_SECONDARY, "QMI_PBM_SESSION_TYPE_1X_SECONDARY", "1x-secondary" },
    { QMI_PBM_SESSION_TYPE_NONPROVISIONING_SLOT_1, "QMI_PBM_SESSION_TYPE_NONPROVISIONING_SLOT_1", "nonprovisioning-slot-1" },
    { QMI_PBM_SESSION_TYPE_NONPROVISIONING_SLOT_2, "QMI_PBM_SESSION_TYPE_NONPROVISIONING_SLOT_2", "nonprovisioning-slot-2" },
    { QMI_PBM_SESSION_TYPE_GLOBAL_PHONEBOOK_SLOT_1, "QMI_PBM_SESSION_TYPE_GLOBAL_PHONEBOOK_SLOT_1", "global-phonebook-slot-1" },
    { QMI_PBM_SESSION_TYPE_GLOBAL_PHONEBOOK_SLOT_2, "QMI_PBM_SESSION_TYPE_GLOBAL_PHONEBOOK_SLOT_2", "global-phonebook-slot-2" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_pbm_session_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiPbmSessionType"),
                                      qmi_pbm_session_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_PBM_SESSION_TYPE_IS_ENUM__
const gchar *
qmi_pbm_session_type_get_string (QmiPbmSessionType val)
{
    guint i;

    for (i = 0; qmi_pbm_session_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_pbm_session_type_values[i].value)
            return qmi_pbm_session_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_PBM_SESSION_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_PBM_SESSION_TYPE_IS_FLAGS__
gchar *
qmi_pbm_session_type_build_string_from_mask (QmiPbmSessionType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_pbm_session_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_pbm_session_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_pbm_session_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_pbm_session_type_values[i].value) {
            guint c;
            gulong number = qmi_pbm_session_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_pbm_session_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_PBM_SESSION_TYPE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-pdc.h" */
static const GEnumValue qmi_pdc_configuration_type_values[] = {
    { QMI_PDC_CONFIGURATION_TYPE_PLATFORM, "QMI_PDC_CONFIGURATION_TYPE_PLATFORM", "platform" },
    { QMI_PDC_CONFIGURATION_TYPE_SOFTWARE, "QMI_PDC_CONFIGURATION_TYPE_SOFTWARE", "software" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_pdc_configuration_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiPdcConfigurationType"),
                                      qmi_pdc_configuration_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_PDC_CONFIGURATION_TYPE_IS_ENUM__
const gchar *
qmi_pdc_configuration_type_get_string (QmiPdcConfigurationType val)
{
    guint i;

    for (i = 0; qmi_pdc_configuration_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_pdc_configuration_type_values[i].value)
            return qmi_pdc_configuration_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_PDC_CONFIGURATION_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_PDC_CONFIGURATION_TYPE_IS_FLAGS__
gchar *
qmi_pdc_configuration_type_build_string_from_mask (QmiPdcConfigurationType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_pdc_configuration_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_pdc_configuration_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_pdc_configuration_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_pdc_configuration_type_values[i].value) {
            guint c;
            gulong number = qmi_pdc_configuration_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_pdc_configuration_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_PDC_CONFIGURATION_TYPE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-pds.h" */
static const GEnumValue qmi_pds_operation_mode_values[] = {
    { QMI_PDS_OPERATION_MODE_UNKNOWN, "QMI_PDS_OPERATION_MODE_UNKNOWN", "unknown" },
    { QMI_PDS_OPERATION_MODE_STANDALONE, "QMI_PDS_OPERATION_MODE_STANDALONE", "standalone" },
    { QMI_PDS_OPERATION_MODE_MS_BASED, "QMI_PDS_OPERATION_MODE_MS_BASED", "ms-based" },
    { QMI_PDS_OPERATION_MODE_MS_ASSISTED, "QMI_PDS_OPERATION_MODE_MS_ASSISTED", "ms-assisted" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_pds_operation_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiPdsOperationMode"),
                                      qmi_pds_operation_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_PDS_OPERATION_MODE_IS_ENUM__
const gchar *
qmi_pds_operation_mode_get_string (QmiPdsOperationMode val)
{
    guint i;

    for (i = 0; qmi_pds_operation_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_pds_operation_mode_values[i].value)
            return qmi_pds_operation_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_PDS_OPERATION_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_PDS_OPERATION_MODE_IS_FLAGS__
gchar *
qmi_pds_operation_mode_build_string_from_mask (QmiPdsOperationMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_pds_operation_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_pds_operation_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_pds_operation_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_pds_operation_mode_values[i].value) {
            guint c;
            gulong number = qmi_pds_operation_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_pds_operation_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_PDS_OPERATION_MODE_IS_FLAGS__ */
static const GEnumValue qmi_pds_position_session_status_values[] = {
    { QMI_PDS_POSITION_SESSION_STATUS_SUCCESS, "QMI_PDS_POSITION_SESSION_STATUS_SUCCESS", "success" },
    { QMI_PDS_POSITION_SESSION_STATUS_IN_PROGRESS, "QMI_PDS_POSITION_SESSION_STATUS_IN_PROGRESS", "in-progress" },
    { QMI_PDS_POSITION_SESSION_STATUS_GENERAL_FAILURE, "QMI_PDS_POSITION_SESSION_STATUS_GENERAL_FAILURE", "general-failure" },
    { QMI_PDS_POSITION_SESSION_STATUS_TIMEOUT, "QMI_PDS_POSITION_SESSION_STATUS_TIMEOUT", "timeout" },
    { QMI_PDS_POSITION_SESSION_STATUS_USER_ENDED_SESSION, "QMI_PDS_POSITION_SESSION_STATUS_USER_ENDED_SESSION", "user-ended-session" },
    { QMI_PDS_POSITION_SESSION_STATUS_BAD_PARAMETER, "QMI_PDS_POSITION_SESSION_STATUS_BAD_PARAMETER", "bad-parameter" },
    { QMI_PDS_POSITION_SESSION_STATUS_PHONE_OFFLINE, "QMI_PDS_POSITION_SESSION_STATUS_PHONE_OFFLINE", "phone-offline" },
    { QMI_PDS_POSITION_SESSION_STATUS_ENGINE_LOCKED, "QMI_PDS_POSITION_SESSION_STATUS_ENGINE_LOCKED", "engine-locked" },
    { QMI_PDS_POSITION_SESSION_STATUS_E911_SESSION_IN_PROGRESS, "QMI_PDS_POSITION_SESSION_STATUS_E911_SESSION_IN_PROGRESS", "e911-session-in-progress" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_pds_position_session_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiPdsPositionSessionStatus"),
                                      qmi_pds_position_session_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_PDS_POSITION_SESSION_STATUS_IS_ENUM__
const gchar *
qmi_pds_position_session_status_get_string (QmiPdsPositionSessionStatus val)
{
    guint i;

    for (i = 0; qmi_pds_position_session_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_pds_position_session_status_values[i].value)
            return qmi_pds_position_session_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_PDS_POSITION_SESSION_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_PDS_POSITION_SESSION_STATUS_IS_FLAGS__
gchar *
qmi_pds_position_session_status_build_string_from_mask (QmiPdsPositionSessionStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_pds_position_session_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_pds_position_session_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_pds_position_session_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_pds_position_session_status_values[i].value) {
            guint c;
            gulong number = qmi_pds_position_session_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_pds_position_session_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_PDS_POSITION_SESSION_STATUS_IS_FLAGS__ */
static const GFlagsValue qmi_pds_data_valid_values[] = {
    { QMI_PDS_DATA_VALID_TIMESTAMP_CALENDAR, "QMI_PDS_DATA_VALID_TIMESTAMP_CALENDAR", "timestamp-calendar" },
    { QMI_PDS_DATA_VALID_TIMESTAMP_UTC, "QMI_PDS_DATA_VALID_TIMESTAMP_UTC", "timestamp-utc" },
    { QMI_PDS_DATA_VALID_LEAP_SECONDS, "QMI_PDS_DATA_VALID_LEAP_SECONDS", "leap-seconds" },
    { QMI_PDS_DATA_VALID_TIME_UNCERTAINTY, "QMI_PDS_DATA_VALID_TIME_UNCERTAINTY", "time-uncertainty" },
    { QMI_PDS_DATA_VALID_LATITUDE, "QMI_PDS_DATA_VALID_LATITUDE", "latitude" },
    { QMI_PDS_DATA_VALID_LONGITUDE, "QMI_PDS_DATA_VALID_LONGITUDE", "longitude" },
    { QMI_PDS_DATA_VALID_ELLIPSOID_ALTITUDE, "QMI_PDS_DATA_VALID_ELLIPSOID_ALTITUDE", "ellipsoid-altitude" },
    { QMI_PDS_DATA_VALID_MEAN_SEA_LEVEL_ALTITUDE, "QMI_PDS_DATA_VALID_MEAN_SEA_LEVEL_ALTITUDE", "mean-sea-level-altitude" },
    { QMI_PDS_DATA_VALID_HORIZONTAL_SPEED, "QMI_PDS_DATA_VALID_HORIZONTAL_SPEED", "horizontal-speed" },
    { QMI_PDS_DATA_VALID_VERTICAL_SPEED, "QMI_PDS_DATA_VALID_VERTICAL_SPEED", "vertical-speed" },
    { QMI_PDS_DATA_VALID_HEADING, "QMI_PDS_DATA_VALID_HEADING", "heading" },
    { QMI_PDS_DATA_VALID_HORIZONTAL_UNCERTAINTY_CIRCULAR, "QMI_PDS_DATA_VALID_HORIZONTAL_UNCERTAINTY_CIRCULAR", "horizontal-uncertainty-circular" },
    { QMI_PDS_DATA_VALID_HORIZONTAL_UNCERTAINTY_ELLIPSE_SEMI_MAJOR, "QMI_PDS_DATA_VALID_HORIZONTAL_UNCERTAINTY_ELLIPSE_SEMI_MAJOR", "horizontal-uncertainty-ellipse-semi-major" },
    { QMI_PDS_DATA_VALID_HORIZONTAL_UNCERTAINTY_ELLIPSE_SEMI_MINOR, "QMI_PDS_DATA_VALID_HORIZONTAL_UNCERTAINTY_ELLIPSE_SEMI_MINOR", "horizontal-uncertainty-ellipse-semi-minor" },
    { QMI_PDS_DATA_VALID_HORIZONTAL_UNCERTAINTY_ELLIPSE_ORIENT_AZIMUTH, "QMI_PDS_DATA_VALID_HORIZONTAL_UNCERTAINTY_ELLIPSE_ORIENT_AZIMUTH", "horizontal-uncertainty-ellipse-orient-azimuth" },
    { QMI_PDS_DATA_VALID_VERTICAL_UNCERTAINTY, "QMI_PDS_DATA_VALID_VERTICAL_UNCERTAINTY", "vertical-uncertainty" },
    { QMI_PDS_DATA_VALID_HORIZONTAL_VELOCITY_UNCERTAINTY, "QMI_PDS_DATA_VALID_HORIZONTAL_VELOCITY_UNCERTAINTY", "horizontal-velocity-uncertainty" },
    { QMI_PDS_DATA_VALID_VERTICAL_VELOCITY_UNCERTAINTY, "QMI_PDS_DATA_VALID_VERTICAL_VELOCITY_UNCERTAINTY", "vertical-velocity-uncertainty" },
    { QMI_PDS_DATA_VALID_HORIZONTAL_CONFIDENCE, "QMI_PDS_DATA_VALID_HORIZONTAL_CONFIDENCE", "horizontal-confidence" },
    { QMI_PDS_DATA_VALID_POSITION_DOP, "QMI_PDS_DATA_VALID_POSITION_DOP", "position-dop" },
    { QMI_PDS_DATA_VALID_HORIZONTAL_DOP, "QMI_PDS_DATA_VALID_HORIZONTAL_DOP", "horizontal-dop" },
    { QMI_PDS_DATA_VALID_VERTICAL_DOP, "QMI_PDS_DATA_VALID_VERTICAL_DOP", "vertical-dop" },
    { QMI_PDS_DATA_VALID_OPERATING_MODE, "QMI_PDS_DATA_VALID_OPERATING_MODE", "operating-mode" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_pds_data_valid_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiPdsDataValid"),
                                      qmi_pds_data_valid_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_PDS_DATA_VALID_IS_ENUM__
const gchar *
qmi_pds_data_valid_get_string (QmiPdsDataValid val)
{
    guint i;

    for (i = 0; qmi_pds_data_valid_values[i].value_nick; i++) {
      if ((gint)val == qmi_pds_data_valid_values[i].value)
            return qmi_pds_data_valid_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_PDS_DATA_VALID_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_PDS_DATA_VALID_IS_FLAGS__
gchar *
qmi_pds_data_valid_build_string_from_mask (QmiPdsDataValid mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_pds_data_valid_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_pds_data_valid_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_pds_data_valid_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_pds_data_valid_values[i].value) {
            guint c;
            gulong number = qmi_pds_data_valid_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_pds_data_valid_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_PDS_DATA_VALID_IS_FLAGS__ */
static const GEnumValue qmi_pds_tracking_session_state_values[] = {
    { QMI_PDS_TRACKING_SESSION_STATE_UNKNOWN, "QMI_PDS_TRACKING_SESSION_STATE_UNKNOWN", "unknown" },
    { QMI_PDS_TRACKING_SESSION_STATE_INACTIVE, "QMI_PDS_TRACKING_SESSION_STATE_INACTIVE", "inactive" },
    { QMI_PDS_TRACKING_SESSION_STATE_ACTIVE, "QMI_PDS_TRACKING_SESSION_STATE_ACTIVE", "active" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_pds_tracking_session_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiPdsTrackingSessionState"),
                                      qmi_pds_tracking_session_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_PDS_TRACKING_SESSION_STATE_IS_ENUM__
const gchar *
qmi_pds_tracking_session_state_get_string (QmiPdsTrackingSessionState val)
{
    guint i;

    for (i = 0; qmi_pds_tracking_session_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_pds_tracking_session_state_values[i].value)
            return qmi_pds_tracking_session_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_PDS_TRACKING_SESSION_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_PDS_TRACKING_SESSION_STATE_IS_FLAGS__
gchar *
qmi_pds_tracking_session_state_build_string_from_mask (QmiPdsTrackingSessionState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_pds_tracking_session_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_pds_tracking_session_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_pds_tracking_session_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_pds_tracking_session_state_values[i].value) {
            guint c;
            gulong number = qmi_pds_tracking_session_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_pds_tracking_session_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_PDS_TRACKING_SESSION_STATE_IS_FLAGS__ */
static const GEnumValue qmi_pds_operating_mode_values[] = {
    { QMI_PDS_OPERATING_MODE_STANDALONE, "QMI_PDS_OPERATING_MODE_STANDALONE", "standalone" },
    { QMI_PDS_OPERATING_MODE_MS_BASED, "QMI_PDS_OPERATING_MODE_MS_BASED", "ms-based" },
    { QMI_PDS_OPERATING_MODE_MS_ASSISTED, "QMI_PDS_OPERATING_MODE_MS_ASSISTED", "ms-assisted" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_pds_operating_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiPdsOperatingMode"),
                                      qmi_pds_operating_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_PDS_OPERATING_MODE_IS_ENUM__
const gchar *
qmi_pds_operating_mode_get_string (QmiPdsOperatingMode val)
{
    guint i;

    for (i = 0; qmi_pds_operating_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_pds_operating_mode_values[i].value)
            return qmi_pds_operating_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_PDS_OPERATING_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_PDS_OPERATING_MODE_IS_FLAGS__
gchar *
qmi_pds_operating_mode_build_string_from_mask (QmiPdsOperatingMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_pds_operating_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_pds_operating_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_pds_operating_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_pds_operating_mode_values[i].value) {
            guint c;
            gulong number = qmi_pds_operating_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_pds_operating_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_PDS_OPERATING_MODE_IS_FLAGS__ */
static const GEnumValue qmi_pds_network_mode_values[] = {
    { QMI_PDS_NETWORK_MODE_UMTS, "QMI_PDS_NETWORK_MODE_UMTS", "umts" },
    { QMI_PDS_NETWORK_MODE_CDMA, "QMI_PDS_NETWORK_MODE_CDMA", "cdma" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_pds_network_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiPdsNetworkMode"),
                                      qmi_pds_network_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_PDS_NETWORK_MODE_IS_ENUM__
const gchar *
qmi_pds_network_mode_get_string (QmiPdsNetworkMode val)
{
    guint i;

    for (i = 0; qmi_pds_network_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_pds_network_mode_values[i].value)
            return qmi_pds_network_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_PDS_NETWORK_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_PDS_NETWORK_MODE_IS_FLAGS__
gchar *
qmi_pds_network_mode_build_string_from_mask (QmiPdsNetworkMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_pds_network_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_pds_network_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_pds_network_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_pds_network_mode_values[i].value) {
            guint c;
            gulong number = qmi_pds_network_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_pds_network_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_PDS_NETWORK_MODE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-qos.h" */
static const GEnumValue qmi_qos_status_values[] = {
    { QMI_QOS_STATUS_UNKNOWN, "QMI_QOS_STATUS_UNKNOWN", "unknown" },
    { QMI_QOS_STATUS_ACTIVATED, "QMI_QOS_STATUS_ACTIVATED", "activated" },
    { QMI_QOS_STATUS_SUSPENDED, "QMI_QOS_STATUS_SUSPENDED", "suspended" },
    { QMI_QOS_STATUS_GONE, "QMI_QOS_STATUS_GONE", "gone" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_qos_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiQosStatus"),
                                      qmi_qos_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_QOS_STATUS_IS_ENUM__
const gchar *
qmi_qos_status_get_string (QmiQosStatus val)
{
    guint i;

    for (i = 0; qmi_qos_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_qos_status_values[i].value)
            return qmi_qos_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_QOS_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_QOS_STATUS_IS_FLAGS__
gchar *
qmi_qos_status_build_string_from_mask (QmiQosStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_qos_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_qos_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_qos_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_qos_status_values[i].value) {
            guint c;
            gulong number = qmi_qos_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_qos_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_QOS_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_qos_event_values[] = {
    { QMI_QOS_EVENT_UNKNOWN, "QMI_QOS_EVENT_UNKNOWN", "unknown" },
    { QMI_QOS_EVENT_ACTIVATED, "QMI_QOS_EVENT_ACTIVATED", "activated" },
    { QMI_QOS_EVENT_SUSPENDED, "QMI_QOS_EVENT_SUSPENDED", "suspended" },
    { QMI_QOS_EVENT_GONE, "QMI_QOS_EVENT_GONE", "gone" },
    { QMI_QOS_EVENT_MODIFY_ACCEPTED, "QMI_QOS_EVENT_MODIFY_ACCEPTED", "modify-accepted" },
    { QMI_QOS_EVENT_MODIFY_REJECTED, "QMI_QOS_EVENT_MODIFY_REJECTED", "modify-rejected" },
    { QMI_QOS_EVENT_INFO_CODE_UPDATED, "QMI_QOS_EVENT_INFO_CODE_UPDATED", "info-code-updated" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_qos_event_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiQosEvent"),
                                      qmi_qos_event_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_QOS_EVENT_IS_ENUM__
const gchar *
qmi_qos_event_get_string (QmiQosEvent val)
{
    guint i;

    for (i = 0; qmi_qos_event_values[i].value_nick; i++) {
      if ((gint)val == qmi_qos_event_values[i].value)
            return qmi_qos_event_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_QOS_EVENT_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_QOS_EVENT_IS_FLAGS__
gchar *
qmi_qos_event_build_string_from_mask (QmiQosEvent mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_qos_event_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_qos_event_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_qos_event_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_qos_event_values[i].value) {
            guint c;
            gulong number = qmi_qos_event_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_qos_event_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_QOS_EVENT_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-sar.h" */
static const GEnumValue qmi_sar_rf_state_values[] = {
    { QMI_SAR_RF_STATE_0, "QMI_SAR_RF_STATE_0", "0" },
    { QMI_SAR_RF_STATE_1, "QMI_SAR_RF_STATE_1", "1" },
    { QMI_SAR_RF_STATE_2, "QMI_SAR_RF_STATE_2", "2" },
    { QMI_SAR_RF_STATE_3, "QMI_SAR_RF_STATE_3", "3" },
    { QMI_SAR_RF_STATE_4, "QMI_SAR_RF_STATE_4", "4" },
    { QMI_SAR_RF_STATE_5, "QMI_SAR_RF_STATE_5", "5" },
    { QMI_SAR_RF_STATE_6, "QMI_SAR_RF_STATE_6", "6" },
    { QMI_SAR_RF_STATE_7, "QMI_SAR_RF_STATE_7", "7" },
    { QMI_SAR_RF_STATE_8, "QMI_SAR_RF_STATE_8", "8" },
    { QMI_SAR_RF_STATE_9, "QMI_SAR_RF_STATE_9", "9" },
    { QMI_SAR_RF_STATE_10, "QMI_SAR_RF_STATE_10", "10" },
    { QMI_SAR_RF_STATE_11, "QMI_SAR_RF_STATE_11", "11" },
    { QMI_SAR_RF_STATE_12, "QMI_SAR_RF_STATE_12", "12" },
    { QMI_SAR_RF_STATE_13, "QMI_SAR_RF_STATE_13", "13" },
    { QMI_SAR_RF_STATE_14, "QMI_SAR_RF_STATE_14", "14" },
    { QMI_SAR_RF_STATE_15, "QMI_SAR_RF_STATE_15", "15" },
    { QMI_SAR_RF_STATE_16, "QMI_SAR_RF_STATE_16", "16" },
    { QMI_SAR_RF_STATE_17, "QMI_SAR_RF_STATE_17", "17" },
    { QMI_SAR_RF_STATE_18, "QMI_SAR_RF_STATE_18", "18" },
    { QMI_SAR_RF_STATE_19, "QMI_SAR_RF_STATE_19", "19" },
    { QMI_SAR_RF_STATE_20, "QMI_SAR_RF_STATE_20", "20" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_sar_rf_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiSarRfState"),
                                      qmi_sar_rf_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_SAR_RF_STATE_IS_ENUM__
const gchar *
qmi_sar_rf_state_get_string (QmiSarRfState val)
{
    guint i;

    for (i = 0; qmi_sar_rf_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_sar_rf_state_values[i].value)
            return qmi_sar_rf_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_SAR_RF_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_SAR_RF_STATE_IS_FLAGS__
gchar *
qmi_sar_rf_state_build_string_from_mask (QmiSarRfState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_sar_rf_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_sar_rf_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_sar_rf_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_sar_rf_state_values[i].value) {
            guint c;
            gulong number = qmi_sar_rf_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_sar_rf_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_SAR_RF_STATE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-uim.h" */
static const GFlagsValue qmi_uim_event_registration_flag_values[] = {
    { QMI_UIM_EVENT_REGISTRATION_FLAG_CARD_STATUS, "QMI_UIM_EVENT_REGISTRATION_FLAG_CARD_STATUS", "card-status" },
    { QMI_UIM_EVENT_REGISTRATION_FLAG_SAP_CONNECTION, "QMI_UIM_EVENT_REGISTRATION_FLAG_SAP_CONNECTION", "sap-connection" },
    { QMI_UIM_EVENT_REGISTRATION_FLAG_EXTENDED_CARD_STATUS, "QMI_UIM_EVENT_REGISTRATION_FLAG_EXTENDED_CARD_STATUS", "extended-card-status" },
    { QMI_UIM_EVENT_REGISTRATION_FLAG_PHYSICAL_SLOT_STATUS, "QMI_UIM_EVENT_REGISTRATION_FLAG_PHYSICAL_SLOT_STATUS", "physical-slot-status" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_event_registration_flag_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiUimEventRegistrationFlag"),
                                      qmi_uim_event_registration_flag_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_EVENT_REGISTRATION_FLAG_IS_ENUM__
const gchar *
qmi_uim_event_registration_flag_get_string (QmiUimEventRegistrationFlag val)
{
    guint i;

    for (i = 0; qmi_uim_event_registration_flag_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_event_registration_flag_values[i].value)
            return qmi_uim_event_registration_flag_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_EVENT_REGISTRATION_FLAG_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_EVENT_REGISTRATION_FLAG_IS_FLAGS__
gchar *
qmi_uim_event_registration_flag_build_string_from_mask (QmiUimEventRegistrationFlag mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_event_registration_flag_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_event_registration_flag_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_event_registration_flag_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_event_registration_flag_values[i].value) {
            guint c;
            gulong number = qmi_uim_event_registration_flag_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_event_registration_flag_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_EVENT_REGISTRATION_FLAG_IS_FLAGS__ */
static const GEnumValue qmi_uim_session_type_values[] = {
    { QMI_UIM_SESSION_TYPE_PRIMARY_GW_PROVISIONING, "QMI_UIM_SESSION_TYPE_PRIMARY_GW_PROVISIONING", "primary-gw-provisioning" },
    { QMI_UIM_SESSION_TYPE_PRIMARY_1X_PROVISIONING, "QMI_UIM_SESSION_TYPE_PRIMARY_1X_PROVISIONING", "primary-1x-provisioning" },
    { QMI_UIM_SESSION_TYPE_SECONDARY_GW_PROVISIONING, "QMI_UIM_SESSION_TYPE_SECONDARY_GW_PROVISIONING", "secondary-gw-provisioning" },
    { QMI_UIM_SESSION_TYPE_SECONDARY_1X_PROVISIONING, "QMI_UIM_SESSION_TYPE_SECONDARY_1X_PROVISIONING", "secondary-1x-provisioning" },
    { QMI_UIM_SESSION_TYPE_NONPROVISIONING_SLOT_1, "QMI_UIM_SESSION_TYPE_NONPROVISIONING_SLOT_1", "nonprovisioning-slot-1" },
    { QMI_UIM_SESSION_TYPE_NONPROVISIONING_SLOT_2, "QMI_UIM_SESSION_TYPE_NONPROVISIONING_SLOT_2", "nonprovisioning-slot-2" },
    { QMI_UIM_SESSION_TYPE_CARD_SLOT_1, "QMI_UIM_SESSION_TYPE_CARD_SLOT_1", "card-slot-1" },
    { QMI_UIM_SESSION_TYPE_CARD_SLOT_2, "QMI_UIM_SESSION_TYPE_CARD_SLOT_2", "card-slot-2" },
    { QMI_UIM_SESSION_TYPE_LOGICAL_CHANNEL_SLOT_1, "QMI_UIM_SESSION_TYPE_LOGICAL_CHANNEL_SLOT_1", "logical-channel-slot-1" },
    { QMI_UIM_SESSION_TYPE_LOGICAL_CHANNEL_SLOT_2, "QMI_UIM_SESSION_TYPE_LOGICAL_CHANNEL_SLOT_2", "logical-channel-slot-2" },
    { QMI_UIM_SESSION_TYPE_TERTIARY_GW_PROVISIONING, "QMI_UIM_SESSION_TYPE_TERTIARY_GW_PROVISIONING", "tertiary-gw-provisioning" },
    { QMI_UIM_SESSION_TYPE_TERTIARY_1X_PROVISIONING, "QMI_UIM_SESSION_TYPE_TERTIARY_1X_PROVISIONING", "tertiary-1x-provisioning" },
    { QMI_UIM_SESSION_TYPE_QUATERNARY_GW_PROVISIONING, "QMI_UIM_SESSION_TYPE_QUATERNARY_GW_PROVISIONING", "quaternary-gw-provisioning" },
    { QMI_UIM_SESSION_TYPE_QUATERNARY_1X_PROVISIONING, "QMI_UIM_SESSION_TYPE_QUATERNARY_1X_PROVISIONING", "quaternary-1x-provisioning" },
    { QMI_UIM_SESSION_TYPE_QUINARY_GW_PROVISIONING, "QMI_UIM_SESSION_TYPE_QUINARY_GW_PROVISIONING", "quinary-gw-provisioning" },
    { QMI_UIM_SESSION_TYPE_QUINARY_1X_PROVISIONING, "QMI_UIM_SESSION_TYPE_QUINARY_1X_PROVISIONING", "quinary-1x-provisioning" },
    { QMI_UIM_SESSION_TYPE_NONPROVISIONING_SLOT_3, "QMI_UIM_SESSION_TYPE_NONPROVISIONING_SLOT_3", "nonprovisioning-slot-3" },
    { QMI_UIM_SESSION_TYPE_NONPROVISIONING_SLOT_4, "QMI_UIM_SESSION_TYPE_NONPROVISIONING_SLOT_4", "nonprovisioning-slot-4" },
    { QMI_UIM_SESSION_TYPE_NONPROVISIONING_SLOT_5, "QMI_UIM_SESSION_TYPE_NONPROVISIONING_SLOT_5", "nonprovisioning-slot-5" },
    { QMI_UIM_SESSION_TYPE_CARD_SLOT_3, "QMI_UIM_SESSION_TYPE_CARD_SLOT_3", "card-slot-3" },
    { QMI_UIM_SESSION_TYPE_CARD_SLOT_4, "QMI_UIM_SESSION_TYPE_CARD_SLOT_4", "card-slot-4" },
    { QMI_UIM_SESSION_TYPE_CARD_SLOT_5, "QMI_UIM_SESSION_TYPE_CARD_SLOT_5", "card-slot-5" },
    { QMI_UIM_SESSION_TYPE_LOGICAL_CHANNEL_SLOT_3, "QMI_UIM_SESSION_TYPE_LOGICAL_CHANNEL_SLOT_3", "logical-channel-slot-3" },
    { QMI_UIM_SESSION_TYPE_LOGICAL_CHANNEL_SLOT_4, "QMI_UIM_SESSION_TYPE_LOGICAL_CHANNEL_SLOT_4", "logical-channel-slot-4" },
    { QMI_UIM_SESSION_TYPE_LOGICAL_CHANNEL_SLOT_5, "QMI_UIM_SESSION_TYPE_LOGICAL_CHANNEL_SLOT_5", "logical-channel-slot-5" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_session_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimSessionType"),
                                      qmi_uim_session_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_SESSION_TYPE_IS_ENUM__
const gchar *
qmi_uim_session_type_get_string (QmiUimSessionType val)
{
    guint i;

    for (i = 0; qmi_uim_session_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_session_type_values[i].value)
            return qmi_uim_session_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_SESSION_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_SESSION_TYPE_IS_FLAGS__
gchar *
qmi_uim_session_type_build_string_from_mask (QmiUimSessionType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_session_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_session_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_session_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_session_type_values[i].value) {
            guint c;
            gulong number = qmi_uim_session_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_session_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_SESSION_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_uim_file_type_values[] = {
    { QMI_UIM_FILE_TYPE_TRANSPARENT, "QMI_UIM_FILE_TYPE_TRANSPARENT", "transparent" },
    { QMI_UIM_FILE_TYPE_CYCLIC, "QMI_UIM_FILE_TYPE_CYCLIC", "cyclic" },
    { QMI_UIM_FILE_TYPE_LINEAR_FIXED, "QMI_UIM_FILE_TYPE_LINEAR_FIXED", "linear-fixed" },
    { QMI_UIM_FILE_TYPE_DEDICATED_FILE, "QMI_UIM_FILE_TYPE_DEDICATED_FILE", "dedicated-file" },
    { QMI_UIM_FILE_TYPE_MASTER_FILE, "QMI_UIM_FILE_TYPE_MASTER_FILE", "master-file" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_file_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimFileType"),
                                      qmi_uim_file_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_FILE_TYPE_IS_ENUM__
const gchar *
qmi_uim_file_type_get_string (QmiUimFileType val)
{
    guint i;

    for (i = 0; qmi_uim_file_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_file_type_values[i].value)
            return qmi_uim_file_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_FILE_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_FILE_TYPE_IS_FLAGS__
gchar *
qmi_uim_file_type_build_string_from_mask (QmiUimFileType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_file_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_file_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_file_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_file_type_values[i].value) {
            guint c;
            gulong number = qmi_uim_file_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_file_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_FILE_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_uim_security_attribute_logic_values[] = {
    { QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_ALWAYS, "QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_ALWAYS", "always" },
    { QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_NEVER, "QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_NEVER", "never" },
    { QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_AND, "QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_AND", "and" },
    { QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_OR, "QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_OR", "or" },
    { QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_SINGLE, "QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_SINGLE", "single" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_security_attribute_logic_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimSecurityAttributeLogic"),
                                      qmi_uim_security_attribute_logic_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_IS_ENUM__
const gchar *
qmi_uim_security_attribute_logic_get_string (QmiUimSecurityAttributeLogic val)
{
    guint i;

    for (i = 0; qmi_uim_security_attribute_logic_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_security_attribute_logic_values[i].value)
            return qmi_uim_security_attribute_logic_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_IS_FLAGS__
gchar *
qmi_uim_security_attribute_logic_build_string_from_mask (QmiUimSecurityAttributeLogic mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_security_attribute_logic_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_security_attribute_logic_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_security_attribute_logic_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_security_attribute_logic_values[i].value) {
            guint c;
            gulong number = qmi_uim_security_attribute_logic_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_security_attribute_logic_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_SECURITY_ATTRIBUTE_LOGIC_IS_FLAGS__ */
static const GFlagsValue qmi_uim_security_attribute_values[] = {
    { QMI_UIM_SECURITY_ATTRIBUTE_PIN1, "QMI_UIM_SECURITY_ATTRIBUTE_PIN1", "pin1" },
    { QMI_UIM_SECURITY_ATTRIBUTE_PIN2, "QMI_UIM_SECURITY_ATTRIBUTE_PIN2", "pin2" },
    { QMI_UIM_SECURITY_ATTRIBUTE_UPIN, "QMI_UIM_SECURITY_ATTRIBUTE_UPIN", "upin" },
    { QMI_UIM_SECURITY_ATTRIBUTE_ADM, "QMI_UIM_SECURITY_ATTRIBUTE_ADM", "adm" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_security_attribute_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiUimSecurityAttribute"),
                                      qmi_uim_security_attribute_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_SECURITY_ATTRIBUTE_IS_ENUM__
const gchar *
qmi_uim_security_attribute_get_string (QmiUimSecurityAttribute val)
{
    guint i;

    for (i = 0; qmi_uim_security_attribute_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_security_attribute_values[i].value)
            return qmi_uim_security_attribute_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_SECURITY_ATTRIBUTE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_SECURITY_ATTRIBUTE_IS_FLAGS__
gchar *
qmi_uim_security_attribute_build_string_from_mask (QmiUimSecurityAttribute mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_security_attribute_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_security_attribute_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_security_attribute_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_security_attribute_values[i].value) {
            guint c;
            gulong number = qmi_uim_security_attribute_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_security_attribute_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_SECURITY_ATTRIBUTE_IS_FLAGS__ */
static const GEnumValue qmi_uim_pin_id_values[] = {
    { QMI_UIM_PIN_ID_UNKNOWN, "QMI_UIM_PIN_ID_UNKNOWN", "unknown" },
    { QMI_UIM_PIN_ID_PIN1, "QMI_UIM_PIN_ID_PIN1", "pin1" },
    { QMI_UIM_PIN_ID_PIN2, "QMI_UIM_PIN_ID_PIN2", "pin2" },
    { QMI_UIM_PIN_ID_UPIN, "QMI_UIM_PIN_ID_UPIN", "upin" },
    { QMI_UIM_PIN_ID_HIDDEN_KEY, "QMI_UIM_PIN_ID_HIDDEN_KEY", "hidden-key" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_pin_id_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimPinId"),
                                      qmi_uim_pin_id_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_PIN_ID_IS_ENUM__
const gchar *
qmi_uim_pin_id_get_string (QmiUimPinId val)
{
    guint i;

    for (i = 0; qmi_uim_pin_id_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_pin_id_values[i].value)
            return qmi_uim_pin_id_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_PIN_ID_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_PIN_ID_IS_FLAGS__
gchar *
qmi_uim_pin_id_build_string_from_mask (QmiUimPinId mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_pin_id_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_pin_id_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_pin_id_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_pin_id_values[i].value) {
            guint c;
            gulong number = qmi_uim_pin_id_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_pin_id_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_PIN_ID_IS_FLAGS__ */
static const GEnumValue qmi_uim_card_state_values[] = {
    { QMI_UIM_CARD_STATE_ABSENT, "QMI_UIM_CARD_STATE_ABSENT", "absent" },
    { QMI_UIM_CARD_STATE_PRESENT, "QMI_UIM_CARD_STATE_PRESENT", "present" },
    { QMI_UIM_CARD_STATE_ERROR, "QMI_UIM_CARD_STATE_ERROR", "error" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_card_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimCardState"),
                                      qmi_uim_card_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_CARD_STATE_IS_ENUM__
const gchar *
qmi_uim_card_state_get_string (QmiUimCardState val)
{
    guint i;

    for (i = 0; qmi_uim_card_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_card_state_values[i].value)
            return qmi_uim_card_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_CARD_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_CARD_STATE_IS_FLAGS__
gchar *
qmi_uim_card_state_build_string_from_mask (QmiUimCardState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_card_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_card_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_card_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_card_state_values[i].value) {
            guint c;
            gulong number = qmi_uim_card_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_card_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_CARD_STATE_IS_FLAGS__ */
static const GEnumValue qmi_uim_pin_state_values[] = {
    { QMI_UIM_PIN_STATE_NOT_INITIALIZED, "QMI_UIM_PIN_STATE_NOT_INITIALIZED", "not-initialized" },
    { QMI_UIM_PIN_STATE_ENABLED_NOT_VERIFIED, "QMI_UIM_PIN_STATE_ENABLED_NOT_VERIFIED", "enabled-not-verified" },
    { QMI_UIM_PIN_STATE_ENABLED_VERIFIED, "QMI_UIM_PIN_STATE_ENABLED_VERIFIED", "enabled-verified" },
    { QMI_UIM_PIN_STATE_DISABLED, "QMI_UIM_PIN_STATE_DISABLED", "disabled" },
    { QMI_UIM_PIN_STATE_BLOCKED, "QMI_UIM_PIN_STATE_BLOCKED", "blocked" },
    { QMI_UIM_PIN_STATE_PERMANENTLY_BLOCKED, "QMI_UIM_PIN_STATE_PERMANENTLY_BLOCKED", "permanently-blocked" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_pin_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimPinState"),
                                      qmi_uim_pin_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_PIN_STATE_IS_ENUM__
const gchar *
qmi_uim_pin_state_get_string (QmiUimPinState val)
{
    guint i;

    for (i = 0; qmi_uim_pin_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_pin_state_values[i].value)
            return qmi_uim_pin_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_PIN_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_PIN_STATE_IS_FLAGS__
gchar *
qmi_uim_pin_state_build_string_from_mask (QmiUimPinState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_pin_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_pin_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_pin_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_pin_state_values[i].value) {
            guint c;
            gulong number = qmi_uim_pin_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_pin_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_PIN_STATE_IS_FLAGS__ */
static const GEnumValue qmi_uim_card_error_values[] = {
    { QMI_UIM_CARD_ERROR_UNKNOWN, "QMI_UIM_CARD_ERROR_UNKNOWN", "unknown" },
    { QMI_UIM_CARD_ERROR_POWER_DOWN, "QMI_UIM_CARD_ERROR_POWER_DOWN", "power-down" },
    { QMI_UIM_CARD_ERROR_POLL, "QMI_UIM_CARD_ERROR_POLL", "poll" },
    { QMI_UIM_CARD_ERROR_NO_ATR_RECEIVED, "QMI_UIM_CARD_ERROR_NO_ATR_RECEIVED", "no-atr-received" },
    { QMI_UIM_CARD_ERROR_VOLTAGE_MISMATCH, "QMI_UIM_CARD_ERROR_VOLTAGE_MISMATCH", "voltage-mismatch" },
    { QMI_UIM_CARD_ERROR_PARITY, "QMI_UIM_CARD_ERROR_PARITY", "parity" },
    { QMI_UIM_CARD_ERROR_POSSIBLY_REMOVED, "QMI_UIM_CARD_ERROR_POSSIBLY_REMOVED", "possibly-removed" },
    { QMI_UIM_CARD_ERROR_TECHNICAL, "QMI_UIM_CARD_ERROR_TECHNICAL", "technical" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_card_error_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimCardError"),
                                      qmi_uim_card_error_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_CARD_ERROR_IS_ENUM__
const gchar *
qmi_uim_card_error_get_string (QmiUimCardError val)
{
    guint i;

    for (i = 0; qmi_uim_card_error_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_card_error_values[i].value)
            return qmi_uim_card_error_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_CARD_ERROR_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_CARD_ERROR_IS_FLAGS__
gchar *
qmi_uim_card_error_build_string_from_mask (QmiUimCardError mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_card_error_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_card_error_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_card_error_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_card_error_values[i].value) {
            guint c;
            gulong number = qmi_uim_card_error_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_card_error_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_CARD_ERROR_IS_FLAGS__ */
static const GEnumValue qmi_uim_card_application_type_values[] = {
    { QMI_UIM_CARD_APPLICATION_TYPE_UNKNOWN, "QMI_UIM_CARD_APPLICATION_TYPE_UNKNOWN", "unknown" },
    { QMI_UIM_CARD_APPLICATION_TYPE_SIM, "QMI_UIM_CARD_APPLICATION_TYPE_SIM", "sim" },
    { QMI_UIM_CARD_APPLICATION_TYPE_USIM, "QMI_UIM_CARD_APPLICATION_TYPE_USIM", "usim" },
    { QMI_UIM_CARD_APPLICATION_TYPE_RUIM, "QMI_UIM_CARD_APPLICATION_TYPE_RUIM", "ruim" },
    { QMI_UIM_CARD_APPLICATION_TYPE_CSIM, "QMI_UIM_CARD_APPLICATION_TYPE_CSIM", "csim" },
    { QMI_UIM_CARD_APPLICATION_TYPE_ISIM, "QMI_UIM_CARD_APPLICATION_TYPE_ISIM", "isim" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_card_application_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimCardApplicationType"),
                                      qmi_uim_card_application_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_CARD_APPLICATION_TYPE_IS_ENUM__
const gchar *
qmi_uim_card_application_type_get_string (QmiUimCardApplicationType val)
{
    guint i;

    for (i = 0; qmi_uim_card_application_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_card_application_type_values[i].value)
            return qmi_uim_card_application_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_CARD_APPLICATION_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_CARD_APPLICATION_TYPE_IS_FLAGS__
gchar *
qmi_uim_card_application_type_build_string_from_mask (QmiUimCardApplicationType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_card_application_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_card_application_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_card_application_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_card_application_type_values[i].value) {
            guint c;
            gulong number = qmi_uim_card_application_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_card_application_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_CARD_APPLICATION_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_uim_card_application_state_values[] = {
    { QMI_UIM_CARD_APPLICATION_STATE_UNKNOWN, "QMI_UIM_CARD_APPLICATION_STATE_UNKNOWN", "unknown" },
    { QMI_UIM_CARD_APPLICATION_STATE_DETECTED, "QMI_UIM_CARD_APPLICATION_STATE_DETECTED", "detected" },
    { QMI_UIM_CARD_APPLICATION_STATE_PIN1_OR_UPIN_PIN_REQUIRED, "QMI_UIM_CARD_APPLICATION_STATE_PIN1_OR_UPIN_PIN_REQUIRED", "pin1-or-upin-pin-required" },
    { QMI_UIM_CARD_APPLICATION_STATE_PUK1_OR_UPIN_PUK_REQUIRED, "QMI_UIM_CARD_APPLICATION_STATE_PUK1_OR_UPIN_PUK_REQUIRED", "puk1-or-upin-puk-required" },
    { QMI_UIM_CARD_APPLICATION_STATE_CHECK_PERSONALIZATION_STATE, "QMI_UIM_CARD_APPLICATION_STATE_CHECK_PERSONALIZATION_STATE", "check-personalization-state" },
    { QMI_UIM_CARD_APPLICATION_STATE_PIN1_BLOCKED, "QMI_UIM_CARD_APPLICATION_STATE_PIN1_BLOCKED", "pin1-blocked" },
    { QMI_UIM_CARD_APPLICATION_STATE_ILLEGAL, "QMI_UIM_CARD_APPLICATION_STATE_ILLEGAL", "illegal" },
    { QMI_UIM_CARD_APPLICATION_STATE_READY, "QMI_UIM_CARD_APPLICATION_STATE_READY", "ready" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_card_application_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimCardApplicationState"),
                                      qmi_uim_card_application_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_CARD_APPLICATION_STATE_IS_ENUM__
const gchar *
qmi_uim_card_application_state_get_string (QmiUimCardApplicationState val)
{
    guint i;

    for (i = 0; qmi_uim_card_application_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_card_application_state_values[i].value)
            return qmi_uim_card_application_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_CARD_APPLICATION_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_CARD_APPLICATION_STATE_IS_FLAGS__
gchar *
qmi_uim_card_application_state_build_string_from_mask (QmiUimCardApplicationState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_card_application_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_card_application_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_card_application_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_card_application_state_values[i].value) {
            guint c;
            gulong number = qmi_uim_card_application_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_card_application_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_CARD_APPLICATION_STATE_IS_FLAGS__ */
static const GEnumValue qmi_uim_card_application_personalization_state_values[] = {
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_UNKNOWN, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_UNKNOWN", "unknown" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_IN_PROGRESS, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_IN_PROGRESS", "in-progress" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_READY, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_READY", "ready" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_CODE_REQUIRED, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_CODE_REQUIRED", "code-required" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_PUK_CODE_REQUIRED, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_PUK_CODE_REQUIRED", "puk-code-required" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_PERMANENTLY_BLOCKED, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_PERMANENTLY_BLOCKED", "permanently-blocked" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_card_application_personalization_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimCardApplicationPersonalizationState"),
                                      qmi_uim_card_application_personalization_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_IS_ENUM__
const gchar *
qmi_uim_card_application_personalization_state_get_string (QmiUimCardApplicationPersonalizationState val)
{
    guint i;

    for (i = 0; qmi_uim_card_application_personalization_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_card_application_personalization_state_values[i].value)
            return qmi_uim_card_application_personalization_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_IS_FLAGS__
gchar *
qmi_uim_card_application_personalization_state_build_string_from_mask (QmiUimCardApplicationPersonalizationState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_card_application_personalization_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_card_application_personalization_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_card_application_personalization_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_card_application_personalization_state_values[i].value) {
            guint c;
            gulong number = qmi_uim_card_application_personalization_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_card_application_personalization_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_CARD_APPLICATION_PERSONALIZATION_STATE_IS_FLAGS__ */
static const GEnumValue qmi_uim_card_application_personalization_feature_values[] = {
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_GW_NETWORK, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_GW_NETWORK", "gw-network" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_GW_NETWORK_SUBSET, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_GW_NETWORK_SUBSET", "gw-network-subset" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_GW_SERVICE_PROVIDER, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_GW_SERVICE_PROVIDER", "gw-service-provider" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_GW_CORPORATE, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_GW_CORPORATE", "gw-corporate" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_GW_UIM, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_GW_UIM", "gw-uim" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_NETWORK_TYPE_1, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_NETWORK_TYPE_1", "1x-network-type-1" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_NETWORK_TYPE_2, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_NETWORK_TYPE_2", "1x-network-type-2" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_HRPD, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_HRPD", "1x-hrpd" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_SERVICE_PROVIDER, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_SERVICE_PROVIDER", "1x-service-provider" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_CORPORATE, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_CORPORATE", "1x-corporate" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_RUIM, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_1X_RUIM", "1x-ruim" },
    { QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_UNKNOWN, "QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_card_application_personalization_feature_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimCardApplicationPersonalizationFeature"),
                                      qmi_uim_card_application_personalization_feature_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_IS_ENUM__
const gchar *
qmi_uim_card_application_personalization_feature_get_string (QmiUimCardApplicationPersonalizationFeature val)
{
    guint i;

    for (i = 0; qmi_uim_card_application_personalization_feature_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_card_application_personalization_feature_values[i].value)
            return qmi_uim_card_application_personalization_feature_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_IS_FLAGS__
gchar *
qmi_uim_card_application_personalization_feature_build_string_from_mask (QmiUimCardApplicationPersonalizationFeature mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_card_application_personalization_feature_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_card_application_personalization_feature_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_card_application_personalization_feature_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_card_application_personalization_feature_values[i].value) {
            guint c;
            gulong number = qmi_uim_card_application_personalization_feature_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_card_application_personalization_feature_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_CARD_APPLICATION_PERSONALIZATION_FEATURE_IS_FLAGS__ */
static const GEnumValue qmi_uim_refresh_stage_values[] = {
    { QMI_UIM_REFRESH_STAGE_WAIT_FOR_OK, "QMI_UIM_REFRESH_STAGE_WAIT_FOR_OK", "wait-for-ok" },
    { QMI_UIM_REFRESH_STAGE_START, "QMI_UIM_REFRESH_STAGE_START", "start" },
    { QMI_UIM_REFRESH_STAGE_END_WITH_SUCCESS, "QMI_UIM_REFRESH_STAGE_END_WITH_SUCCESS", "end-with-success" },
    { QMI_UIM_REFRESH_STAGE_END_WITH_FAILURE, "QMI_UIM_REFRESH_STAGE_END_WITH_FAILURE", "end-with-failure" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_refresh_stage_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimRefreshStage"),
                                      qmi_uim_refresh_stage_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_REFRESH_STAGE_IS_ENUM__
const gchar *
qmi_uim_refresh_stage_get_string (QmiUimRefreshStage val)
{
    guint i;

    for (i = 0; qmi_uim_refresh_stage_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_refresh_stage_values[i].value)
            return qmi_uim_refresh_stage_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_REFRESH_STAGE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_REFRESH_STAGE_IS_FLAGS__
gchar *
qmi_uim_refresh_stage_build_string_from_mask (QmiUimRefreshStage mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_refresh_stage_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_refresh_stage_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_refresh_stage_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_refresh_stage_values[i].value) {
            guint c;
            gulong number = qmi_uim_refresh_stage_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_refresh_stage_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_REFRESH_STAGE_IS_FLAGS__ */
static const GEnumValue qmi_uim_refresh_mode_values[] = {
    { QMI_UIM_REFRESH_MODE_RESET, "QMI_UIM_REFRESH_MODE_RESET", "reset" },
    { QMI_UIM_REFRESH_MODE_INIT, "QMI_UIM_REFRESH_MODE_INIT", "init" },
    { QMI_UIM_REFRESH_MODE_INIT_FCN, "QMI_UIM_REFRESH_MODE_INIT_FCN", "init-fcn" },
    { QMI_UIM_REFRESH_MODE_FCN, "QMI_UIM_REFRESH_MODE_FCN", "fcn" },
    { QMI_UIM_REFRESH_MODE_INIT_FULL_FCN, "QMI_UIM_REFRESH_MODE_INIT_FULL_FCN", "init-full-fcn" },
    { QMI_UIM_REFRESH_MODE_APP_RESET, "QMI_UIM_REFRESH_MODE_APP_RESET", "app-reset" },
    { QMI_UIM_REFRESH_MODE_3G_RESET, "QMI_UIM_REFRESH_MODE_3G_RESET", "3g-reset" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_refresh_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimRefreshMode"),
                                      qmi_uim_refresh_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_REFRESH_MODE_IS_ENUM__
const gchar *
qmi_uim_refresh_mode_get_string (QmiUimRefreshMode val)
{
    guint i;

    for (i = 0; qmi_uim_refresh_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_refresh_mode_values[i].value)
            return qmi_uim_refresh_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_REFRESH_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_REFRESH_MODE_IS_FLAGS__
gchar *
qmi_uim_refresh_mode_build_string_from_mask (QmiUimRefreshMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_refresh_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_refresh_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_refresh_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_refresh_mode_values[i].value) {
            guint c;
            gulong number = qmi_uim_refresh_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_refresh_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_REFRESH_MODE_IS_FLAGS__ */
static const GEnumValue qmi_uim_physical_card_state_values[] = {
    { QMI_UIM_PHYSICAL_CARD_STATE_UNKNOWN, "QMI_UIM_PHYSICAL_CARD_STATE_UNKNOWN", "unknown" },
    { QMI_UIM_PHYSICAL_CARD_STATE_ABSENT, "QMI_UIM_PHYSICAL_CARD_STATE_ABSENT", "absent" },
    { QMI_UIM_PHYSICAL_CARD_STATE_PRESENT, "QMI_UIM_PHYSICAL_CARD_STATE_PRESENT", "present" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_physical_card_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimPhysicalCardState"),
                                      qmi_uim_physical_card_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_PHYSICAL_CARD_STATE_IS_ENUM__
const gchar *
qmi_uim_physical_card_state_get_string (QmiUimPhysicalCardState val)
{
    guint i;

    for (i = 0; qmi_uim_physical_card_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_physical_card_state_values[i].value)
            return qmi_uim_physical_card_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_PHYSICAL_CARD_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_PHYSICAL_CARD_STATE_IS_FLAGS__
gchar *
qmi_uim_physical_card_state_build_string_from_mask (QmiUimPhysicalCardState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_physical_card_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_physical_card_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_physical_card_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_physical_card_state_values[i].value) {
            guint c;
            gulong number = qmi_uim_physical_card_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_physical_card_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_PHYSICAL_CARD_STATE_IS_FLAGS__ */
static const GEnumValue qmi_uim_slot_state_values[] = {
    { QMI_UIM_SLOT_STATE_INACTIVE, "QMI_UIM_SLOT_STATE_INACTIVE", "inactive" },
    { QMI_UIM_SLOT_STATE_ACTIVE, "QMI_UIM_SLOT_STATE_ACTIVE", "active" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_slot_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimSlotState"),
                                      qmi_uim_slot_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_SLOT_STATE_IS_ENUM__
const gchar *
qmi_uim_slot_state_get_string (QmiUimSlotState val)
{
    guint i;

    for (i = 0; qmi_uim_slot_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_slot_state_values[i].value)
            return qmi_uim_slot_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_SLOT_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_SLOT_STATE_IS_FLAGS__
gchar *
qmi_uim_slot_state_build_string_from_mask (QmiUimSlotState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_slot_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_slot_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_slot_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_slot_state_values[i].value) {
            guint c;
            gulong number = qmi_uim_slot_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_slot_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_SLOT_STATE_IS_FLAGS__ */
static const GEnumValue qmi_uim_card_protocol_values[] = {
    { QMI_UIM_CARD_PROTOCOL_UNKNOWN, "QMI_UIM_CARD_PROTOCOL_UNKNOWN", "unknown" },
    { QMI_UIM_CARD_PROTOCOL_ICC, "QMI_UIM_CARD_PROTOCOL_ICC", "icc" },
    { QMI_UIM_CARD_PROTOCOL_UICC, "QMI_UIM_CARD_PROTOCOL_UICC", "uicc" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_card_protocol_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimCardProtocol"),
                                      qmi_uim_card_protocol_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_CARD_PROTOCOL_IS_ENUM__
const gchar *
qmi_uim_card_protocol_get_string (QmiUimCardProtocol val)
{
    guint i;

    for (i = 0; qmi_uim_card_protocol_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_card_protocol_values[i].value)
            return qmi_uim_card_protocol_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_CARD_PROTOCOL_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_CARD_PROTOCOL_IS_FLAGS__
gchar *
qmi_uim_card_protocol_build_string_from_mask (QmiUimCardProtocol mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_card_protocol_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_card_protocol_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_card_protocol_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_card_protocol_values[i].value) {
            guint c;
            gulong number = qmi_uim_card_protocol_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_card_protocol_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_CARD_PROTOCOL_IS_FLAGS__ */
static const GFlagsValue qmi_uim_configuration_values[] = {
    { QMI_UIM_CONFIGURATION_AUTOMATIC_SELECTION, "QMI_UIM_CONFIGURATION_AUTOMATIC_SELECTION", "automatic-selection" },
    { QMI_UIM_CONFIGURATION_PERSONALIZATION_STATUS, "QMI_UIM_CONFIGURATION_PERSONALIZATION_STATUS", "personalization-status" },
    { QMI_UIM_CONFIGURATION_HALT_SUBSCRIPTION, "QMI_UIM_CONFIGURATION_HALT_SUBSCRIPTION", "halt-subscription" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_configuration_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiUimConfiguration"),
                                      qmi_uim_configuration_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_CONFIGURATION_IS_ENUM__
const gchar *
qmi_uim_configuration_get_string (QmiUimConfiguration val)
{
    guint i;

    for (i = 0; qmi_uim_configuration_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_configuration_values[i].value)
            return qmi_uim_configuration_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_CONFIGURATION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_CONFIGURATION_IS_FLAGS__
gchar *
qmi_uim_configuration_build_string_from_mask (QmiUimConfiguration mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_configuration_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_configuration_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_configuration_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_configuration_values[i].value) {
            guint c;
            gulong number = qmi_uim_configuration_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_configuration_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_CONFIGURATION_IS_FLAGS__ */
static const GEnumValue qmi_uim_depersonalization_operation_values[] = {
    { QMI_UIM_DEPERSONALIZATION_OPERATION_DEACTIVATE, "QMI_UIM_DEPERSONALIZATION_OPERATION_DEACTIVATE", "deactivate" },
    { QMI_UIM_DEPERSONALIZATION_OPERATION_UNBLOCK, "QMI_UIM_DEPERSONALIZATION_OPERATION_UNBLOCK", "unblock" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_uim_depersonalization_operation_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiUimDepersonalizationOperation"),
                                      qmi_uim_depersonalization_operation_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_UIM_DEPERSONALIZATION_OPERATION_IS_ENUM__
const gchar *
qmi_uim_depersonalization_operation_get_string (QmiUimDepersonalizationOperation val)
{
    guint i;

    for (i = 0; qmi_uim_depersonalization_operation_values[i].value_nick; i++) {
      if ((gint)val == qmi_uim_depersonalization_operation_values[i].value)
            return qmi_uim_depersonalization_operation_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_UIM_DEPERSONALIZATION_OPERATION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_UIM_DEPERSONALIZATION_OPERATION_IS_FLAGS__
gchar *
qmi_uim_depersonalization_operation_build_string_from_mask (QmiUimDepersonalizationOperation mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_uim_depersonalization_operation_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_uim_depersonalization_operation_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_uim_depersonalization_operation_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_uim_depersonalization_operation_values[i].value) {
            guint c;
            gulong number = qmi_uim_depersonalization_operation_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_uim_depersonalization_operation_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_UIM_DEPERSONALIZATION_OPERATION_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-voice.h" */
static const GEnumValue qmi_voice_call_state_values[] = {
    { QMI_VOICE_CALL_STATE_UNKNOWN, "QMI_VOICE_CALL_STATE_UNKNOWN", "unknown" },
    { QMI_VOICE_CALL_STATE_ORIGINATION, "QMI_VOICE_CALL_STATE_ORIGINATION", "origination" },
    { QMI_VOICE_CALL_STATE_INCOMING, "QMI_VOICE_CALL_STATE_INCOMING", "incoming" },
    { QMI_VOICE_CALL_STATE_CONVERSATION, "QMI_VOICE_CALL_STATE_CONVERSATION", "conversation" },
    { QMI_VOICE_CALL_STATE_CC_IN_PROGRESS, "QMI_VOICE_CALL_STATE_CC_IN_PROGRESS", "cc-in-progress" },
    { QMI_VOICE_CALL_STATE_ALERTING, "QMI_VOICE_CALL_STATE_ALERTING", "alerting" },
    { QMI_VOICE_CALL_STATE_HOLD, "QMI_VOICE_CALL_STATE_HOLD", "hold" },
    { QMI_VOICE_CALL_STATE_WAITING, "QMI_VOICE_CALL_STATE_WAITING", "waiting" },
    { QMI_VOICE_CALL_STATE_DISCONNECTING, "QMI_VOICE_CALL_STATE_DISCONNECTING", "disconnecting" },
    { QMI_VOICE_CALL_STATE_END, "QMI_VOICE_CALL_STATE_END", "end" },
    { QMI_VOICE_CALL_STATE_SETUP, "QMI_VOICE_CALL_STATE_SETUP", "setup" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_call_state_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceCallState"),
                                      qmi_voice_call_state_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_CALL_STATE_IS_ENUM__
const gchar *
qmi_voice_call_state_get_string (QmiVoiceCallState val)
{
    guint i;

    for (i = 0; qmi_voice_call_state_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_call_state_values[i].value)
            return qmi_voice_call_state_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_CALL_STATE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_CALL_STATE_IS_FLAGS__
gchar *
qmi_voice_call_state_build_string_from_mask (QmiVoiceCallState mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_call_state_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_call_state_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_call_state_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_call_state_values[i].value) {
            guint c;
            gulong number = qmi_voice_call_state_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_call_state_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_CALL_STATE_IS_FLAGS__ */
static const GEnumValue qmi_voice_call_type_values[] = {
    { QMI_VOICE_CALL_TYPE_VOICE, "QMI_VOICE_CALL_TYPE_VOICE", "voice" },
    { QMI_VOICE_CALL_TYPE_VOICE_IP, "QMI_VOICE_CALL_TYPE_VOICE_IP", "voice-ip" },
    { QMI_VOICE_CALL_TYPE_OTAPA, "QMI_VOICE_CALL_TYPE_OTAPA", "otapa" },
    { QMI_VOICE_CALL_TYPE_NON_STD_OTASP, "QMI_VOICE_CALL_TYPE_NON_STD_OTASP", "non-std-otasp" },
    { QMI_VOICE_CALL_TYPE_EMERGENCY, "QMI_VOICE_CALL_TYPE_EMERGENCY", "emergency" },
    { QMI_VOICE_CALL_TYPE_SUPS, "QMI_VOICE_CALL_TYPE_SUPS", "sups" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_call_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceCallType"),
                                      qmi_voice_call_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_CALL_TYPE_IS_ENUM__
const gchar *
qmi_voice_call_type_get_string (QmiVoiceCallType val)
{
    guint i;

    for (i = 0; qmi_voice_call_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_call_type_values[i].value)
            return qmi_voice_call_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_CALL_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_CALL_TYPE_IS_FLAGS__
gchar *
qmi_voice_call_type_build_string_from_mask (QmiVoiceCallType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_call_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_call_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_call_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_call_type_values[i].value) {
            guint c;
            gulong number = qmi_voice_call_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_call_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_CALL_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_voice_call_direction_values[] = {
    { QMI_VOICE_CALL_DIRECTION_UNKNOWN, "QMI_VOICE_CALL_DIRECTION_UNKNOWN", "unknown" },
    { QMI_VOICE_CALL_DIRECTION_MO, "QMI_VOICE_CALL_DIRECTION_MO", "mo" },
    { QMI_VOICE_CALL_DIRECTION_MT, "QMI_VOICE_CALL_DIRECTION_MT", "mt" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_call_direction_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceCallDirection"),
                                      qmi_voice_call_direction_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_CALL_DIRECTION_IS_ENUM__
const gchar *
qmi_voice_call_direction_get_string (QmiVoiceCallDirection val)
{
    guint i;

    for (i = 0; qmi_voice_call_direction_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_call_direction_values[i].value)
            return qmi_voice_call_direction_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_CALL_DIRECTION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_CALL_DIRECTION_IS_FLAGS__
gchar *
qmi_voice_call_direction_build_string_from_mask (QmiVoiceCallDirection mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_call_direction_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_call_direction_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_call_direction_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_call_direction_values[i].value) {
            guint c;
            gulong number = qmi_voice_call_direction_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_call_direction_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_CALL_DIRECTION_IS_FLAGS__ */
static const GEnumValue qmi_voice_call_mode_values[] = {
    { QMI_VOICE_CALL_MODE_UNKNOWN, "QMI_VOICE_CALL_MODE_UNKNOWN", "unknown" },
    { QMI_VOICE_CALL_MODE_CDMA, "QMI_VOICE_CALL_MODE_CDMA", "cdma" },
    { QMI_VOICE_CALL_MODE_GSM, "QMI_VOICE_CALL_MODE_GSM", "gsm" },
    { QMI_VOICE_CALL_MODE_UMTS, "QMI_VOICE_CALL_MODE_UMTS", "umts" },
    { QMI_VOICE_CALL_MODE_LTE, "QMI_VOICE_CALL_MODE_LTE", "lte" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_call_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceCallMode"),
                                      qmi_voice_call_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_CALL_MODE_IS_ENUM__
const gchar *
qmi_voice_call_mode_get_string (QmiVoiceCallMode val)
{
    guint i;

    for (i = 0; qmi_voice_call_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_call_mode_values[i].value)
            return qmi_voice_call_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_CALL_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_CALL_MODE_IS_FLAGS__
gchar *
qmi_voice_call_mode_build_string_from_mask (QmiVoiceCallMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_call_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_call_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_call_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_call_mode_values[i].value) {
            guint c;
            gulong number = qmi_voice_call_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_call_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_CALL_MODE_IS_FLAGS__ */
static const GEnumValue qmi_voice_als_values[] = {
    { QMI_VOICE_ALS_LINE_1, "QMI_VOICE_ALS_LINE_1", "1" },
    { QMI_VOICE_ALS_LINE_2, "QMI_VOICE_ALS_LINE_2", "2" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_als_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceAls"),
                                      qmi_voice_als_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_ALS_IS_ENUM__
const gchar *
qmi_voice_als_get_string (QmiVoiceAls val)
{
    guint i;

    for (i = 0; qmi_voice_als_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_als_values[i].value)
            return qmi_voice_als_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_ALS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_ALS_IS_FLAGS__
gchar *
qmi_voice_als_build_string_from_mask (QmiVoiceAls mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_als_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_als_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_als_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_als_values[i].value) {
            guint c;
            gulong number = qmi_voice_als_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_als_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_ALS_IS_FLAGS__ */
static const GEnumValue qmi_voice_presentation_values[] = {
    { QMI_VOICE_PRESENTATION_ALLOWED, "QMI_VOICE_PRESENTATION_ALLOWED", "allowed" },
    { QMI_VOICE_PRESENTATION_RESTRICTED, "QMI_VOICE_PRESENTATION_RESTRICTED", "restricted" },
    { QMI_VOICE_PRESENTATION_UNAVAILABLE, "QMI_VOICE_PRESENTATION_UNAVAILABLE", "unavailable" },
    { QMI_VOICE_PRESENTATION_PAYPHONE, "QMI_VOICE_PRESENTATION_PAYPHONE", "payphone" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_presentation_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoicePresentation"),
                                      qmi_voice_presentation_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_PRESENTATION_IS_ENUM__
const gchar *
qmi_voice_presentation_get_string (QmiVoicePresentation val)
{
    guint i;

    for (i = 0; qmi_voice_presentation_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_presentation_values[i].value)
            return qmi_voice_presentation_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_PRESENTATION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_PRESENTATION_IS_FLAGS__
gchar *
qmi_voice_presentation_build_string_from_mask (QmiVoicePresentation mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_presentation_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_presentation_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_presentation_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_presentation_values[i].value) {
            guint c;
            gulong number = qmi_voice_presentation_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_presentation_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_PRESENTATION_IS_FLAGS__ */
static const GEnumValue qmi_voice_tty_mode_values[] = {
    { QMI_VOICE_TTY_MODE_FULL, "QMI_VOICE_TTY_MODE_FULL", "full" },
    { QMI_VOICE_TTY_MODE_VCO, "QMI_VOICE_TTY_MODE_VCO", "vco" },
    { QMI_VOICE_TTY_MODE_HCO, "QMI_VOICE_TTY_MODE_HCO", "hco" },
    { QMI_VOICE_TTY_MODE_OFF, "QMI_VOICE_TTY_MODE_OFF", "off" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_tty_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceTtyMode"),
                                      qmi_voice_tty_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_TTY_MODE_IS_ENUM__
const gchar *
qmi_voice_tty_mode_get_string (QmiVoiceTtyMode val)
{
    guint i;

    for (i = 0; qmi_voice_tty_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_tty_mode_values[i].value)
            return qmi_voice_tty_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_TTY_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_TTY_MODE_IS_FLAGS__
gchar *
qmi_voice_tty_mode_build_string_from_mask (QmiVoiceTtyMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_tty_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_tty_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_tty_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_tty_mode_values[i].value) {
            guint c;
            gulong number = qmi_voice_tty_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_tty_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_TTY_MODE_IS_FLAGS__ */
static const GEnumValue qmi_voice_service_option_values[] = {
    { QMI_VOICE_SERVICE_OPTION_WILD, "QMI_VOICE_SERVICE_OPTION_WILD", "wild" },
    { QMI_VOICE_SERVICE_OPTION_IS_96A, "QMI_VOICE_SERVICE_OPTION_IS_96A", "is-96a" },
    { QMI_VOICE_SERVICE_OPTION_EVRC, "QMI_VOICE_SERVICE_OPTION_EVRC", "evrc" },
    { QMI_VOICE_SERVICE_OPTION_13K_IS733, "QMI_VOICE_SERVICE_OPTION_13K_IS733", "13k-is733" },
    { QMI_VOICE_SERVICE_OPTION_SELECTABLE_MODE_VOCODER, "QMI_VOICE_SERVICE_OPTION_SELECTABLE_MODE_VOCODER", "selectable-mode-vocoder" },
    { QMI_VOICE_SERVICE_OPTION_4GV_NARROW_BAND, "QMI_VOICE_SERVICE_OPTION_4GV_NARROW_BAND", "4gv-narrow-band" },
    { QMI_VOICE_SERVICE_OPTION_4GV_WIDE_BAND, "QMI_VOICE_SERVICE_OPTION_4GV_WIDE_BAND", "4gv-wide-band" },
    { QMI_VOICE_SERVICE_OPTION_13K, "QMI_VOICE_SERVICE_OPTION_13K", "13k" },
    { QMI_VOICE_SERVICE_OPTION_IS_96, "QMI_VOICE_SERVICE_OPTION_IS_96", "is-96" },
    { QMI_VOICE_SERVICE_OPTION_WVRC, "QMI_VOICE_SERVICE_OPTION_WVRC", "wvrc" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_service_option_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceServiceOption"),
                                      qmi_voice_service_option_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_SERVICE_OPTION_IS_ENUM__
const gchar *
qmi_voice_service_option_get_string (QmiVoiceServiceOption val)
{
    guint i;

    for (i = 0; qmi_voice_service_option_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_service_option_values[i].value)
            return qmi_voice_service_option_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_SERVICE_OPTION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_SERVICE_OPTION_IS_FLAGS__
gchar *
qmi_voice_service_option_build_string_from_mask (QmiVoiceServiceOption mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_service_option_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_service_option_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_service_option_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_service_option_values[i].value) {
            guint c;
            gulong number = qmi_voice_service_option_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_service_option_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_SERVICE_OPTION_IS_FLAGS__ */
static const GFlagsValue qmi_voice_wcdma_amr_status_values[] = {
    { QMI_VOICE_WCDMA_AMR_STATUS_NOT_SUPPORTED, "QMI_VOICE_WCDMA_AMR_STATUS_NOT_SUPPORTED", "not-supported" },
    { QMI_VOICE_WCDMA_AMR_STATUS_WCDMA_AMR_WB, "QMI_VOICE_WCDMA_AMR_STATUS_WCDMA_AMR_WB", "wcdma-amr-wb" },
    { QMI_VOICE_WCDMA_AMR_STATUS_GSM_HR_AMR, "QMI_VOICE_WCDMA_AMR_STATUS_GSM_HR_AMR", "gsm-hr-amr" },
    { QMI_VOICE_WCDMA_AMR_STATUS_GSM_AMR_WB, "QMI_VOICE_WCDMA_AMR_STATUS_GSM_AMR_WB", "gsm-amr-wb" },
    { QMI_VOICE_WCDMA_AMR_STATUS_GSM_AMR_NB, "QMI_VOICE_WCDMA_AMR_STATUS_GSM_AMR_NB", "gsm-amr-nb" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_wcdma_amr_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiVoiceWcdmaAmrStatus"),
                                      qmi_voice_wcdma_amr_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_WCDMA_AMR_STATUS_IS_ENUM__
const gchar *
qmi_voice_wcdma_amr_status_get_string (QmiVoiceWcdmaAmrStatus val)
{
    guint i;

    for (i = 0; qmi_voice_wcdma_amr_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_wcdma_amr_status_values[i].value)
            return qmi_voice_wcdma_amr_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_WCDMA_AMR_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_WCDMA_AMR_STATUS_IS_FLAGS__
gchar *
qmi_voice_wcdma_amr_status_build_string_from_mask (QmiVoiceWcdmaAmrStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_wcdma_amr_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_wcdma_amr_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_wcdma_amr_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_wcdma_amr_status_values[i].value) {
            guint c;
            gulong number = qmi_voice_wcdma_amr_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_wcdma_amr_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_WCDMA_AMR_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_voice_privacy_values[] = {
    { QMI_VOICE_PRIVACY_STANDARD, "QMI_VOICE_PRIVACY_STANDARD", "standard" },
    { QMI_VOICE_PRIVACY_ENHANCED, "QMI_VOICE_PRIVACY_ENHANCED", "enhanced" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_privacy_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoicePrivacy"),
                                      qmi_voice_privacy_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_PRIVACY_IS_ENUM__
const gchar *
qmi_voice_privacy_get_string (QmiVoicePrivacy val)
{
    guint i;

    for (i = 0; qmi_voice_privacy_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_privacy_values[i].value)
            return qmi_voice_privacy_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_PRIVACY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_PRIVACY_IS_FLAGS__
gchar *
qmi_voice_privacy_build_string_from_mask (QmiVoicePrivacy mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_privacy_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_privacy_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_privacy_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_privacy_values[i].value) {
            guint c;
            gulong number = qmi_voice_privacy_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_privacy_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_PRIVACY_IS_FLAGS__ */
static const GEnumValue qmi_voice_domain_values[] = {
    { QMI_VOICE_DOMAIN_CS_ONLY, "QMI_VOICE_DOMAIN_CS_ONLY", "cs-only" },
    { QMI_VOICE_DOMAIN_PS_ONLY, "QMI_VOICE_DOMAIN_PS_ONLY", "ps-only" },
    { QMI_VOICE_DOMAIN_CS_PREFERRED, "QMI_VOICE_DOMAIN_CS_PREFERRED", "cs-preferred" },
    { QMI_VOICE_DOMAIN_PS_PREFERRED, "QMI_VOICE_DOMAIN_PS_PREFERRED", "ps-preferred" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_domain_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceDomain"),
                                      qmi_voice_domain_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_DOMAIN_IS_ENUM__
const gchar *
qmi_voice_domain_get_string (QmiVoiceDomain val)
{
    guint i;

    for (i = 0; qmi_voice_domain_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_domain_values[i].value)
            return qmi_voice_domain_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_DOMAIN_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_DOMAIN_IS_FLAGS__
gchar *
qmi_voice_domain_build_string_from_mask (QmiVoiceDomain mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_domain_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_domain_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_domain_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_domain_values[i].value) {
            guint c;
            gulong number = qmi_voice_domain_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_domain_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_DOMAIN_IS_FLAGS__ */
static const GEnumValue qmi_voice_user_action_values[] = {
    { QMI_VOICE_USER_ACTION_UNKNOWN, "QMI_VOICE_USER_ACTION_UNKNOWN", "unknown" },
    { QMI_VOICE_USER_ACTION_NOT_REQUIRED, "QMI_VOICE_USER_ACTION_NOT_REQUIRED", "not-required" },
    { QMI_VOICE_USER_ACTION_REQUIRED, "QMI_VOICE_USER_ACTION_REQUIRED", "required" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_user_action_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceUserAction"),
                                      qmi_voice_user_action_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_USER_ACTION_IS_ENUM__
const gchar *
qmi_voice_user_action_get_string (QmiVoiceUserAction val)
{
    guint i;

    for (i = 0; qmi_voice_user_action_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_user_action_values[i].value)
            return qmi_voice_user_action_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_USER_ACTION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_USER_ACTION_IS_FLAGS__
gchar *
qmi_voice_user_action_build_string_from_mask (QmiVoiceUserAction mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_user_action_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_user_action_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_user_action_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_user_action_values[i].value) {
            guint c;
            gulong number = qmi_voice_user_action_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_user_action_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_USER_ACTION_IS_FLAGS__ */
static const GEnumValue qmi_voice_uss_data_coding_scheme_values[] = {
    { QMI_VOICE_USS_DATA_CODING_SCHEME_UNKNOWN, "QMI_VOICE_USS_DATA_CODING_SCHEME_UNKNOWN", "unknown" },
    { QMI_VOICE_USS_DATA_CODING_SCHEME_ASCII, "QMI_VOICE_USS_DATA_CODING_SCHEME_ASCII", "ascii" },
    { QMI_VOICE_USS_DATA_CODING_SCHEME_8BIT, "QMI_VOICE_USS_DATA_CODING_SCHEME_8BIT", "8bit" },
    { QMI_VOICE_USS_DATA_CODING_SCHEME_UCS2, "QMI_VOICE_USS_DATA_CODING_SCHEME_UCS2", "ucs2" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_uss_data_coding_scheme_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceUssDataCodingScheme"),
                                      qmi_voice_uss_data_coding_scheme_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_USS_DATA_CODING_SCHEME_IS_ENUM__
const gchar *
qmi_voice_uss_data_coding_scheme_get_string (QmiVoiceUssDataCodingScheme val)
{
    guint i;

    for (i = 0; qmi_voice_uss_data_coding_scheme_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_uss_data_coding_scheme_values[i].value)
            return qmi_voice_uss_data_coding_scheme_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_USS_DATA_CODING_SCHEME_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_USS_DATA_CODING_SCHEME_IS_FLAGS__
gchar *
qmi_voice_uss_data_coding_scheme_build_string_from_mask (QmiVoiceUssDataCodingScheme mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_uss_data_coding_scheme_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_uss_data_coding_scheme_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_uss_data_coding_scheme_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_uss_data_coding_scheme_values[i].value) {
            guint c;
            gulong number = qmi_voice_uss_data_coding_scheme_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_uss_data_coding_scheme_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_USS_DATA_CODING_SCHEME_IS_FLAGS__ */
static const GEnumValue qmi_voice_alpha_data_coding_scheme_values[] = {
    { QMI_VOICE_ALPHA_DATA_CODING_SCHEME_GSM, "QMI_VOICE_ALPHA_DATA_CODING_SCHEME_GSM", "gsm" },
    { QMI_VOICE_ALPHA_DATA_CODING_SCHEME_UCS2, "QMI_VOICE_ALPHA_DATA_CODING_SCHEME_UCS2", "ucs2" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_alpha_data_coding_scheme_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceAlphaDataCodingScheme"),
                                      qmi_voice_alpha_data_coding_scheme_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_ALPHA_DATA_CODING_SCHEME_IS_ENUM__
const gchar *
qmi_voice_alpha_data_coding_scheme_get_string (QmiVoiceAlphaDataCodingScheme val)
{
    guint i;

    for (i = 0; qmi_voice_alpha_data_coding_scheme_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_alpha_data_coding_scheme_values[i].value)
            return qmi_voice_alpha_data_coding_scheme_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_ALPHA_DATA_CODING_SCHEME_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_ALPHA_DATA_CODING_SCHEME_IS_FLAGS__
gchar *
qmi_voice_alpha_data_coding_scheme_build_string_from_mask (QmiVoiceAlphaDataCodingScheme mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_alpha_data_coding_scheme_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_alpha_data_coding_scheme_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_alpha_data_coding_scheme_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_alpha_data_coding_scheme_values[i].value) {
            guint c;
            gulong number = qmi_voice_alpha_data_coding_scheme_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_alpha_data_coding_scheme_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_ALPHA_DATA_CODING_SCHEME_IS_FLAGS__ */
static const GEnumValue qmi_voice_call_end_reason_values[] = {
    { QMI_VOICE_CALL_END_REASON_OFFLINE, "QMI_VOICE_CALL_END_REASON_OFFLINE", "offline" },
    { QMI_VOICE_CALL_END_REASON_CDMA_LOCK, "QMI_VOICE_CALL_END_REASON_CDMA_LOCK", "cdma-lock" },
    { QMI_VOICE_CALL_END_REASON_NO_SERVICE, "QMI_VOICE_CALL_END_REASON_NO_SERVICE", "no-service" },
    { QMI_VOICE_CALL_END_REASON_FADE, "QMI_VOICE_CALL_END_REASON_FADE", "fade" },
    { QMI_VOICE_CALL_END_REASON_INTERCEPT, "QMI_VOICE_CALL_END_REASON_INTERCEPT", "intercept" },
    { QMI_VOICE_CALL_END_REASON_REORDER, "QMI_VOICE_CALL_END_REASON_REORDER", "reorder" },
    { QMI_VOICE_CALL_END_REASON_RELEASE_NORMAL, "QMI_VOICE_CALL_END_REASON_RELEASE_NORMAL", "release-normal" },
    { QMI_VOICE_CALL_END_REASON_RELEASE_SO_REJECT, "QMI_VOICE_CALL_END_REASON_RELEASE_SO_REJECT", "release-so-reject" },
    { QMI_VOICE_CALL_END_REASON_INCOMING_CALL, "QMI_VOICE_CALL_END_REASON_INCOMING_CALL", "incoming-call" },
    { QMI_VOICE_CALL_END_REASON_ALERT_STOP, "QMI_VOICE_CALL_END_REASON_ALERT_STOP", "alert-stop" },
    { QMI_VOICE_CALL_END_REASON_CLIENT_END, "QMI_VOICE_CALL_END_REASON_CLIENT_END", "client-end" },
    { QMI_VOICE_CALL_END_REASON_ACTIVATION, "QMI_VOICE_CALL_END_REASON_ACTIVATION", "activation" },
    { QMI_VOICE_CALL_END_REASON_MC_ABORT, "QMI_VOICE_CALL_END_REASON_MC_ABORT", "mc-abort" },
    { QMI_VOICE_CALL_END_REASON_MAX_ACCESS_PROBE, "QMI_VOICE_CALL_END_REASON_MAX_ACCESS_PROBE", "max-access-probe" },
    { QMI_VOICE_CALL_END_REASON_PSIST_N, "QMI_VOICE_CALL_END_REASON_PSIST_N", "psist-n" },
    { QMI_VOICE_CALL_END_REASON_UIM_NOT_PRESENT, "QMI_VOICE_CALL_END_REASON_UIM_NOT_PRESENT", "uim-not-present" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_ATTEMPT_IN_PROGRESS, "QMI_VOICE_CALL_END_REASON_ACCESS_ATTEMPT_IN_PROGRESS", "access-attempt-in-progress" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_FAILURE, "QMI_VOICE_CALL_END_REASON_ACCESS_FAILURE", "access-failure" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_RETRY_ORDER, "QMI_VOICE_CALL_END_REASON_ACCESS_RETRY_ORDER", "access-retry-order" },
    { QMI_VOICE_CALL_END_REASON_CCS_NOT_SUPPORTED_BY_BS, "QMI_VOICE_CALL_END_REASON_CCS_NOT_SUPPORTED_BY_BS", "ccs-not-supported-by-bs" },
    { QMI_VOICE_CALL_END_REASON_NO_RESPONSE_FROM_BS, "QMI_VOICE_CALL_END_REASON_NO_RESPONSE_FROM_BS", "no-response-from-bs" },
    { QMI_VOICE_CALL_END_REASON_REJECTED_BY_BS, "QMI_VOICE_CALL_END_REASON_REJECTED_BY_BS", "rejected-by-bs" },
    { QMI_VOICE_CALL_END_REASON_INCOMPATIBLE, "QMI_VOICE_CALL_END_REASON_INCOMPATIBLE", "incompatible" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_BLOCK, "QMI_VOICE_CALL_END_REASON_ACCESS_BLOCK", "access-block" },
    { QMI_VOICE_CALL_END_REASON_ALREADY_IN_TC, "QMI_VOICE_CALL_END_REASON_ALREADY_IN_TC", "already-in-tc" },
    { QMI_VOICE_CALL_END_REASON_EMERGENCY_FLASHED, "QMI_VOICE_CALL_END_REASON_EMERGENCY_FLASHED", "emergency-flashed" },
    { QMI_VOICE_CALL_END_REASON_USER_CALL_ORIGINATED_DURING_GPS, "QMI_VOICE_CALL_END_REASON_USER_CALL_ORIGINATED_DURING_GPS", "user-call-originated-during-gps" },
    { QMI_VOICE_CALL_END_REASON_USER_CALL_ORIGINATED_DURING_SMS, "QMI_VOICE_CALL_END_REASON_USER_CALL_ORIGINATED_DURING_SMS", "user-call-originated-during-sms" },
    { QMI_VOICE_CALL_END_REASON_USER_CALL_ORIGINATED_DURING_DATA, "QMI_VOICE_CALL_END_REASON_USER_CALL_ORIGINATED_DURING_DATA", "user-call-originated-during-data" },
    { QMI_VOICE_CALL_END_REASON_REDIRECTION_OR_HANDOFF, "QMI_VOICE_CALL_END_REASON_REDIRECTION_OR_HANDOFF", "redirection-or-handoff" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_BLOCK_ALL, "QMI_VOICE_CALL_END_REASON_ACCESS_BLOCK_ALL", "access-block-all" },
    { QMI_VOICE_CALL_END_REASON_OTASP_SPC_ERR, "QMI_VOICE_CALL_END_REASON_OTASP_SPC_ERR", "otasp-spc-err" },
    { QMI_VOICE_CALL_END_REASON_IS707B_MAX_ACCESS_PROBES, "QMI_VOICE_CALL_END_REASON_IS707B_MAX_ACCESS_PROBES", "is707b-max-access-probes" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_FAILURE_REJECT_ORDER, "QMI_VOICE_CALL_END_REASON_ACCESS_FAILURE_REJECT_ORDER", "access-failure-reject-order" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_FAILURE_RETRY_ORDER, "QMI_VOICE_CALL_END_REASON_ACCESS_FAILURE_RETRY_ORDER", "access-failure-retry-order" },
    { QMI_VOICE_CALL_END_REASON_TIMEOUT_T42, "QMI_VOICE_CALL_END_REASON_TIMEOUT_T42", "timeout-t42" },
    { QMI_VOICE_CALL_END_REASON_TIMEOUT_T40, "QMI_VOICE_CALL_END_REASON_TIMEOUT_T40", "timeout-t40" },
    { QMI_VOICE_CALL_END_REASON_SERVICE_INIT_FAILURE, "QMI_VOICE_CALL_END_REASON_SERVICE_INIT_FAILURE", "service-init-failure" },
    { QMI_VOICE_CALL_END_REASON_TIMEOUT_T50, "QMI_VOICE_CALL_END_REASON_TIMEOUT_T50", "timeout-t50" },
    { QMI_VOICE_CALL_END_REASON_TIMEOUT_T51, "QMI_VOICE_CALL_END_REASON_TIMEOUT_T51", "timeout-t51" },
    { QMI_VOICE_CALL_END_REASON_RL_ACK_TIMEOUT, "QMI_VOICE_CALL_END_REASON_RL_ACK_TIMEOUT", "rl-ack-timeout" },
    { QMI_VOICE_CALL_END_REASON_BAD_FORWARD_LINK, "QMI_VOICE_CALL_END_REASON_BAD_FORWARD_LINK", "bad-forward-link" },
    { QMI_VOICE_CALL_END_REASON_TRM_REQUEST_FAILED, "QMI_VOICE_CALL_END_REASON_TRM_REQUEST_FAILED", "trm-request-failed" },
    { QMI_VOICE_CALL_END_REASON_TIMEOUT_T41, "QMI_VOICE_CALL_END_REASON_TIMEOUT_T41", "timeout-t41" },
    { QMI_VOICE_CALL_END_REASON_INCOMING_REJECTED, "QMI_VOICE_CALL_END_REASON_INCOMING_REJECTED", "incoming-rejected" },
    { QMI_VOICE_CALL_END_REASON_SETUP_REJECTED, "QMI_VOICE_CALL_END_REASON_SETUP_REJECTED", "setup-rejected" },
    { QMI_VOICE_CALL_END_REASON_NETWORK_END, "QMI_VOICE_CALL_END_REASON_NETWORK_END", "network-end" },
    { QMI_VOICE_CALL_END_REASON_NO_FUNDS, "QMI_VOICE_CALL_END_REASON_NO_FUNDS", "no-funds" },
    { QMI_VOICE_CALL_END_REASON_NO_GW_SERVICE, "QMI_VOICE_CALL_END_REASON_NO_GW_SERVICE", "no-gw-service" },
    { QMI_VOICE_CALL_END_REASON_NO_CDMA_SERVICE, "QMI_VOICE_CALL_END_REASON_NO_CDMA_SERVICE", "no-cdma-service" },
    { QMI_VOICE_CALL_END_REASON_NO_FULL_SERVICE, "QMI_VOICE_CALL_END_REASON_NO_FULL_SERVICE", "no-full-service" },
    { QMI_VOICE_CALL_END_REASON_MAX_PS_CALLS, "QMI_VOICE_CALL_END_REASON_MAX_PS_CALLS", "max-ps-calls" },
    { QMI_VOICE_CALL_END_REASON_UNKNOWN_SUBSCRIBER, "QMI_VOICE_CALL_END_REASON_UNKNOWN_SUBSCRIBER", "unknown-subscriber" },
    { QMI_VOICE_CALL_END_REASON_ILLEGAL_SUBSCRIBER, "QMI_VOICE_CALL_END_REASON_ILLEGAL_SUBSCRIBER", "illegal-subscriber" },
    { QMI_VOICE_CALL_END_REASON_BEARER_SERVICE_NOT_PROVISIONED, "QMI_VOICE_CALL_END_REASON_BEARER_SERVICE_NOT_PROVISIONED", "bearer-service-not-provisioned" },
    { QMI_VOICE_CALL_END_REASON_TELE_SERVICE_NOT_PROVISIONED, "QMI_VOICE_CALL_END_REASON_TELE_SERVICE_NOT_PROVISIONED", "tele-service-not-provisioned" },
    { QMI_VOICE_CALL_END_REASON_ILLEGAL_EQUIPMENT, "QMI_VOICE_CALL_END_REASON_ILLEGAL_EQUIPMENT", "illegal-equipment" },
    { QMI_VOICE_CALL_END_REASON_CALL_BARRED, "QMI_VOICE_CALL_END_REASON_CALL_BARRED", "call-barred" },
    { QMI_VOICE_CALL_END_REASON_ILLEGAL_SS_OPERATION, "QMI_VOICE_CALL_END_REASON_ILLEGAL_SS_OPERATION", "illegal-ss-operation" },
    { QMI_VOICE_CALL_END_REASON_SS_ERROR_STATUS, "QMI_VOICE_CALL_END_REASON_SS_ERROR_STATUS", "ss-error-status" },
    { QMI_VOICE_CALL_END_REASON_SS_NOT_AVAILABLE, "QMI_VOICE_CALL_END_REASON_SS_NOT_AVAILABLE", "ss-not-available" },
    { QMI_VOICE_CALL_END_REASON_SS_SUBSCRIPTION_VIOLATION, "QMI_VOICE_CALL_END_REASON_SS_SUBSCRIPTION_VIOLATION", "ss-subscription-violation" },
    { QMI_VOICE_CALL_END_REASON_SS_INCOMPATIBILITY, "QMI_VOICE_CALL_END_REASON_SS_INCOMPATIBILITY", "ss-incompatibility" },
    { QMI_VOICE_CALL_END_REASON_FACILITY_NOT_SUPPORTED, "QMI_VOICE_CALL_END_REASON_FACILITY_NOT_SUPPORTED", "facility-not-supported" },
    { QMI_VOICE_CALL_END_REASON_ABSENT_SUBSCRIBER, "QMI_VOICE_CALL_END_REASON_ABSENT_SUBSCRIBER", "absent-subscriber" },
    { QMI_VOICE_CALL_END_REASON_SHORT_TERM_DENIAL, "QMI_VOICE_CALL_END_REASON_SHORT_TERM_DENIAL", "short-term-denial" },
    { QMI_VOICE_CALL_END_REASON_LONG_TERM_DENIAL, "QMI_VOICE_CALL_END_REASON_LONG_TERM_DENIAL", "long-term-denial" },
    { QMI_VOICE_CALL_END_REASON_SYSTEM_FAILURE, "QMI_VOICE_CALL_END_REASON_SYSTEM_FAILURE", "system-failure" },
    { QMI_VOICE_CALL_END_REASON_DATA_MISSING, "QMI_VOICE_CALL_END_REASON_DATA_MISSING", "data-missing" },
    { QMI_VOICE_CALL_END_REASON_UNEXPECTED_DATA_VALUE, "QMI_VOICE_CALL_END_REASON_UNEXPECTED_DATA_VALUE", "unexpected-data-value" },
    { QMI_VOICE_CALL_END_REASON_PASSWORD_REGISTRATION_FAILURE, "QMI_VOICE_CALL_END_REASON_PASSWORD_REGISTRATION_FAILURE", "password-registration-failure" },
    { QMI_VOICE_CALL_END_REASON_NEGATIVE_PASSWORD_CHECK, "QMI_VOICE_CALL_END_REASON_NEGATIVE_PASSWORD_CHECK", "negative-password-check" },
    { QMI_VOICE_CALL_END_REASON_NUM_OF_PASSWORD_ATTEMPTS_VIOLATION, "QMI_VOICE_CALL_END_REASON_NUM_OF_PASSWORD_ATTEMPTS_VIOLATION", "num-of-password-attempts-violation" },
    { QMI_VOICE_CALL_END_REASON_POSITION_METHOD_FAILURE, "QMI_VOICE_CALL_END_REASON_POSITION_METHOD_FAILURE", "position-method-failure" },
    { QMI_VOICE_CALL_END_REASON_UNKNOWN_ALPHABET, "QMI_VOICE_CALL_END_REASON_UNKNOWN_ALPHABET", "unknown-alphabet" },
    { QMI_VOICE_CALL_END_REASON_USSD_BUSY, "QMI_VOICE_CALL_END_REASON_USSD_BUSY", "ussd-busy" },
    { QMI_VOICE_CALL_END_REASON_REJECTED_BY_USER, "QMI_VOICE_CALL_END_REASON_REJECTED_BY_USER", "rejected-by-user" },
    { QMI_VOICE_CALL_END_REASON_REJECTED_BY_NETWORK, "QMI_VOICE_CALL_END_REASON_REJECTED_BY_NETWORK", "rejected-by-network" },
    { QMI_VOICE_CALL_END_REASON_DEFLECTION_TO_SERVED_SUBSCRIBER, "QMI_VOICE_CALL_END_REASON_DEFLECTION_TO_SERVED_SUBSCRIBER", "deflection-to-served-subscriber" },
    { QMI_VOICE_CALL_END_REASON_SPECIAL_SERVICE_CODE, "QMI_VOICE_CALL_END_REASON_SPECIAL_SERVICE_CODE", "special-service-code" },
    { QMI_VOICE_CALL_END_REASON_INVALID_DEFLECTED_TO_NUMBER, "QMI_VOICE_CALL_END_REASON_INVALID_DEFLECTED_TO_NUMBER", "invalid-deflected-to-number" },
    { QMI_VOICE_CALL_END_REASON_MULTIPARTY_PARTICIPANTS_EXCEEDED, "QMI_VOICE_CALL_END_REASON_MULTIPARTY_PARTICIPANTS_EXCEEDED", "multiparty-participants-exceeded" },
    { QMI_VOICE_CALL_END_REASON_RESOURCES_NOT_AVAILABLE, "QMI_VOICE_CALL_END_REASON_RESOURCES_NOT_AVAILABLE", "resources-not-available" },
    { QMI_VOICE_CALL_END_REASON_UNASSIGNED_NUMBER, "QMI_VOICE_CALL_END_REASON_UNASSIGNED_NUMBER", "unassigned-number" },
    { QMI_VOICE_CALL_END_REASON_NO_ROUTE_TO_DESTINATION, "QMI_VOICE_CALL_END_REASON_NO_ROUTE_TO_DESTINATION", "no-route-to-destination" },
    { QMI_VOICE_CALL_END_REASON_CHANNEL_UNACCEPTABLE, "QMI_VOICE_CALL_END_REASON_CHANNEL_UNACCEPTABLE", "channel-unacceptable" },
    { QMI_VOICE_CALL_END_REASON_OPERATOR_DETERMINED_BARRING, "QMI_VOICE_CALL_END_REASON_OPERATOR_DETERMINED_BARRING", "operator-determined-barring" },
    { QMI_VOICE_CALL_END_REASON_NORMAL_CALL_CLEARING, "QMI_VOICE_CALL_END_REASON_NORMAL_CALL_CLEARING", "normal-call-clearing" },
    { QMI_VOICE_CALL_END_REASON_USER_BUSY, "QMI_VOICE_CALL_END_REASON_USER_BUSY", "user-busy" },
    { QMI_VOICE_CALL_END_REASON_NO_USER_RESPONDING, "QMI_VOICE_CALL_END_REASON_NO_USER_RESPONDING", "no-user-responding" },
    { QMI_VOICE_CALL_END_REASON_USER_ALERTING_NO_ANSWER, "QMI_VOICE_CALL_END_REASON_USER_ALERTING_NO_ANSWER", "user-alerting-no-answer" },
    { QMI_VOICE_CALL_END_REASON_CALL_REJECTED, "QMI_VOICE_CALL_END_REASON_CALL_REJECTED", "call-rejected" },
    { QMI_VOICE_CALL_END_REASON_NUMBER_CHANGED, "QMI_VOICE_CALL_END_REASON_NUMBER_CHANGED", "number-changed" },
    { QMI_VOICE_CALL_END_REASON_PREEMPTION, "QMI_VOICE_CALL_END_REASON_PREEMPTION", "preemption" },
    { QMI_VOICE_CALL_END_REASON_DESTINATION_OUT_OF_ORDER, "QMI_VOICE_CALL_END_REASON_DESTINATION_OUT_OF_ORDER", "destination-out-of-order" },
    { QMI_VOICE_CALL_END_REASON_INVALID_NUMBER_FORMAT, "QMI_VOICE_CALL_END_REASON_INVALID_NUMBER_FORMAT", "invalid-number-format" },
    { QMI_VOICE_CALL_END_REASON_FACILITY_REJECTED, "QMI_VOICE_CALL_END_REASON_FACILITY_REJECTED", "facility-rejected" },
    { QMI_VOICE_CALL_END_REASON_RESPONSE_TO_STATUS_ENQUIRY, "QMI_VOICE_CALL_END_REASON_RESPONSE_TO_STATUS_ENQUIRY", "response-to-status-enquiry" },
    { QMI_VOICE_CALL_END_REASON_NORMAL_UNSPECIFIED, "QMI_VOICE_CALL_END_REASON_NORMAL_UNSPECIFIED", "normal-unspecified" },
    { QMI_VOICE_CALL_END_REASON_NO_CIRCUIT_OR_CHANNEL_AVAILABLE, "QMI_VOICE_CALL_END_REASON_NO_CIRCUIT_OR_CHANNEL_AVAILABLE", "no-circuit-or-channel-available" },
    { QMI_VOICE_CALL_END_REASON_NETWORK_OUT_OF_ORDER, "QMI_VOICE_CALL_END_REASON_NETWORK_OUT_OF_ORDER", "network-out-of-order" },
    { QMI_VOICE_CALL_END_REASON_TEMPORARY_FAILURE, "QMI_VOICE_CALL_END_REASON_TEMPORARY_FAILURE", "temporary-failure" },
    { QMI_VOICE_CALL_END_REASON_SWITCHING_EQUIPMENT_CONGESTION, "QMI_VOICE_CALL_END_REASON_SWITCHING_EQUIPMENT_CONGESTION", "switching-equipment-congestion" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_INFORMATION_DISCARDED, "QMI_VOICE_CALL_END_REASON_ACCESS_INFORMATION_DISCARDED", "access-information-discarded" },
    { QMI_VOICE_CALL_END_REASON_REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE, "QMI_VOICE_CALL_END_REASON_REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE", "requested-circuit-or-channel-not-available" },
    { QMI_VOICE_CALL_END_REASON_RESOURCES_UNAVAILABLE_OR_UNSPECIFIED, "QMI_VOICE_CALL_END_REASON_RESOURCES_UNAVAILABLE_OR_UNSPECIFIED", "resources-unavailable-or-unspecified" },
    { QMI_VOICE_CALL_END_REASON_QOS_UNAVAILABLE, "QMI_VOICE_CALL_END_REASON_QOS_UNAVAILABLE", "qos-unavailable" },
    { QMI_VOICE_CALL_END_REASON_REQUESTED_FACILITY_NOT_SUBSCRIBED, "QMI_VOICE_CALL_END_REASON_REQUESTED_FACILITY_NOT_SUBSCRIBED", "requested-facility-not-subscribed" },
    { QMI_VOICE_CALL_END_REASON_INCOMING_CALLS_BARRED_WITHIN_CUG, "QMI_VOICE_CALL_END_REASON_INCOMING_CALLS_BARRED_WITHIN_CUG", "incoming-calls-barred-within-cug" },
    { QMI_VOICE_CALL_END_REASON_BEARER_CAPABILITY_NOT_AUTH, "QMI_VOICE_CALL_END_REASON_BEARER_CAPABILITY_NOT_AUTH", "bearer-capability-not-auth" },
    { QMI_VOICE_CALL_END_REASON_BEARER_CAPABILITY_UNAVAILABLE, "QMI_VOICE_CALL_END_REASON_BEARER_CAPABILITY_UNAVAILABLE", "bearer-capability-unavailable" },
    { QMI_VOICE_CALL_END_REASON_SERVICE_OPTION_NOT_AVAILABLE, "QMI_VOICE_CALL_END_REASON_SERVICE_OPTION_NOT_AVAILABLE", "service-option-not-available" },
    { QMI_VOICE_CALL_END_REASON_ACM_LIMIT_EXCEEDED, "QMI_VOICE_CALL_END_REASON_ACM_LIMIT_EXCEEDED", "acm-limit-exceeded" },
    { QMI_VOICE_CALL_END_REASON_BEARER_SERVICE_NOT_IMPLEMENTED, "QMI_VOICE_CALL_END_REASON_BEARER_SERVICE_NOT_IMPLEMENTED", "bearer-service-not-implemented" },
    { QMI_VOICE_CALL_END_REASON_REQUESTED_FACILITY_NOT_IMPLEMENTED, "QMI_VOICE_CALL_END_REASON_REQUESTED_FACILITY_NOT_IMPLEMENTED", "requested-facility-not-implemented" },
    { QMI_VOICE_CALL_END_REASON_ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE, "QMI_VOICE_CALL_END_REASON_ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE", "only-digital-information-bearer-available" },
    { QMI_VOICE_CALL_END_REASON_SERVICE_OR_OPTION_NOT_IMPLEMENTED, "QMI_VOICE_CALL_END_REASON_SERVICE_OR_OPTION_NOT_IMPLEMENTED", "service-or-option-not-implemented" },
    { QMI_VOICE_CALL_END_REASON_INVALID_TRANSACTION_IDENTIFIER, "QMI_VOICE_CALL_END_REASON_INVALID_TRANSACTION_IDENTIFIER", "invalid-transaction-identifier" },
    { QMI_VOICE_CALL_END_REASON_USER_NOT_MEMBER_OF_CUG, "QMI_VOICE_CALL_END_REASON_USER_NOT_MEMBER_OF_CUG", "user-not-member-of-cug" },
    { QMI_VOICE_CALL_END_REASON_INCOMPATIBLE_DESTINATION, "QMI_VOICE_CALL_END_REASON_INCOMPATIBLE_DESTINATION", "incompatible-destination" },
    { QMI_VOICE_CALL_END_REASON_INVALID_TRANSIT_NETWORK_SELECTION, "QMI_VOICE_CALL_END_REASON_INVALID_TRANSIT_NETWORK_SELECTION", "invalid-transit-network-selection" },
    { QMI_VOICE_CALL_END_REASON_SEMANTICALLY_INCORRECT_MESSAGE, "QMI_VOICE_CALL_END_REASON_SEMANTICALLY_INCORRECT_MESSAGE", "semantically-incorrect-message" },
    { QMI_VOICE_CALL_END_REASON_INVALID_MANDATORY_INFORMATION, "QMI_VOICE_CALL_END_REASON_INVALID_MANDATORY_INFORMATION", "invalid-mandatory-information" },
    { QMI_VOICE_CALL_END_REASON_MESSAGE_TYPE_NOT_IMPLEMENTED, "QMI_VOICE_CALL_END_REASON_MESSAGE_TYPE_NOT_IMPLEMENTED", "message-type-not-implemented" },
    { QMI_VOICE_CALL_END_REASON_MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE, "QMI_VOICE_CALL_END_REASON_MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE", "message-type-not-compatible-with-protocol-state" },
    { QMI_VOICE_CALL_END_REASON_INFORMATION_ELEMENT_NON_EXISTENT, "QMI_VOICE_CALL_END_REASON_INFORMATION_ELEMENT_NON_EXISTENT", "information-element-non-existent" },
    { QMI_VOICE_CALL_END_REASON_CONDITIONAL_IE_ERROR, "QMI_VOICE_CALL_END_REASON_CONDITIONAL_IE_ERROR", "conditional-ie-error" },
    { QMI_VOICE_CALL_END_REASON_MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE, "QMI_VOICE_CALL_END_REASON_MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE", "message-not-compatible-with-protocol-state" },
    { QMI_VOICE_CALL_END_REASON_RECOVERY_ON_TIMER_EXPIRED, "QMI_VOICE_CALL_END_REASON_RECOVERY_ON_TIMER_EXPIRED", "recovery-on-timer-expired" },
    { QMI_VOICE_CALL_END_REASON_PROTOCOL_ERROR_UNSPECIFIED, "QMI_VOICE_CALL_END_REASON_PROTOCOL_ERROR_UNSPECIFIED", "protocol-error-unspecified" },
    { QMI_VOICE_CALL_END_REASON_INTERWORKING_UNSPECIFIED, "QMI_VOICE_CALL_END_REASON_INTERWORKING_UNSPECIFIED", "interworking-unspecified" },
    { QMI_VOICE_CALL_END_REASON_OUTGOING_CALLS_BARRED_WITHIN_CUG, "QMI_VOICE_CALL_END_REASON_OUTGOING_CALLS_BARRED_WITHIN_CUG", "outgoing-calls-barred-within-cug" },
    { QMI_VOICE_CALL_END_REASON_NO_CUG_SELECTION, "QMI_VOICE_CALL_END_REASON_NO_CUG_SELECTION", "no-cug-selection" },
    { QMI_VOICE_CALL_END_REASON_UNKNOWN_CUG_INDEX, "QMI_VOICE_CALL_END_REASON_UNKNOWN_CUG_INDEX", "unknown-cug-index" },
    { QMI_VOICE_CALL_END_REASON_CUG_INDEX_INCOMPATIBLE, "QMI_VOICE_CALL_END_REASON_CUG_INDEX_INCOMPATIBLE", "cug-index-incompatible" },
    { QMI_VOICE_CALL_END_REASON_CUG_CALL_FAILURE_UNSPECIFIED, "QMI_VOICE_CALL_END_REASON_CUG_CALL_FAILURE_UNSPECIFIED", "cug-call-failure-unspecified" },
    { QMI_VOICE_CALL_END_REASON_CLIR_NOT_SUBSCRIBED, "QMI_VOICE_CALL_END_REASON_CLIR_NOT_SUBSCRIBED", "clir-not-subscribed" },
    { QMI_VOICE_CALL_END_REASON_CCBS_POSSIBLE, "QMI_VOICE_CALL_END_REASON_CCBS_POSSIBLE", "ccbs-possible" },
    { QMI_VOICE_CALL_END_REASON_CCBS_NOT_POSSIBLE, "QMI_VOICE_CALL_END_REASON_CCBS_NOT_POSSIBLE", "ccbs-not-possible" },
    { QMI_VOICE_CALL_END_REASON_IMSI_UNKNOWN_IN_HLR, "QMI_VOICE_CALL_END_REASON_IMSI_UNKNOWN_IN_HLR", "imsi-unknown-in-hlr" },
    { QMI_VOICE_CALL_END_REASON_ILLEGAL_MS, "QMI_VOICE_CALL_END_REASON_ILLEGAL_MS", "illegal-ms" },
    { QMI_VOICE_CALL_END_REASON_IMSI_UNKNOWN_IN_VLR, "QMI_VOICE_CALL_END_REASON_IMSI_UNKNOWN_IN_VLR", "imsi-unknown-in-vlr" },
    { QMI_VOICE_CALL_END_REASON_IMEI_NOT_ACCEPTED, "QMI_VOICE_CALL_END_REASON_IMEI_NOT_ACCEPTED", "imei-not-accepted" },
    { QMI_VOICE_CALL_END_REASON_ILLEGAL_ME, "QMI_VOICE_CALL_END_REASON_ILLEGAL_ME", "illegal-me" },
    { QMI_VOICE_CALL_END_REASON_PLMN_NOT_ALLOWED, "QMI_VOICE_CALL_END_REASON_PLMN_NOT_ALLOWED", "plmn-not-allowed" },
    { QMI_VOICE_CALL_END_REASON_LOCATION_AREA_NOT_ALLOWED, "QMI_VOICE_CALL_END_REASON_LOCATION_AREA_NOT_ALLOWED", "location-area-not-allowed" },
    { QMI_VOICE_CALL_END_REASON_ROAMING_NOT_ALLOWED_IN_THIS_LOCATION_AREA, "QMI_VOICE_CALL_END_REASON_ROAMING_NOT_ALLOWED_IN_THIS_LOCATION_AREA", "roaming-not-allowed-in-this-location-area" },
    { QMI_VOICE_CALL_END_REASON_NO_SUITABLE_CELLS_IN_LOCATION_AREA, "QMI_VOICE_CALL_END_REASON_NO_SUITABLE_CELLS_IN_LOCATION_AREA", "no-suitable-cells-in-location-area" },
    { QMI_VOICE_CALL_END_REASON_NETWORK_FAILURE, "QMI_VOICE_CALL_END_REASON_NETWORK_FAILURE", "network-failure" },
    { QMI_VOICE_CALL_END_REASON_MAC_FAILURE, "QMI_VOICE_CALL_END_REASON_MAC_FAILURE", "mac-failure" },
    { QMI_VOICE_CALL_END_REASON_SYNCH_FAILURE, "QMI_VOICE_CALL_END_REASON_SYNCH_FAILURE", "synch-failure" },
    { QMI_VOICE_CALL_END_REASON_NETWORK_CONGESTION, "QMI_VOICE_CALL_END_REASON_NETWORK_CONGESTION", "network-congestion" },
    { QMI_VOICE_CALL_END_REASON_GSM_AUTHENTICATION_UNACCEPTABLE, "QMI_VOICE_CALL_END_REASON_GSM_AUTHENTICATION_UNACCEPTABLE", "gsm-authentication-unacceptable" },
    { QMI_VOICE_CALL_END_REASON_SERVICE_NOT_SUBSCRIBED, "QMI_VOICE_CALL_END_REASON_SERVICE_NOT_SUBSCRIBED", "service-not-subscribed" },
    { QMI_VOICE_CALL_END_REASON_SERVICE_TEMPORARILY_OUT_OF_ORDER, "QMI_VOICE_CALL_END_REASON_SERVICE_TEMPORARILY_OUT_OF_ORDER", "service-temporarily-out-of-order" },
    { QMI_VOICE_CALL_END_REASON_CALL_CANNOT_BE_IDENTIFIED, "QMI_VOICE_CALL_END_REASON_CALL_CANNOT_BE_IDENTIFIED", "call-cannot-be-identified" },
    { QMI_VOICE_CALL_END_REASON_INCORRECT_SEMANTICS_IN_MESSAGE, "QMI_VOICE_CALL_END_REASON_INCORRECT_SEMANTICS_IN_MESSAGE", "incorrect-semantics-in-message" },
    { QMI_VOICE_CALL_END_REASON_MANDATORY_INFORMATION_INVALID, "QMI_VOICE_CALL_END_REASON_MANDATORY_INFORMATION_INVALID", "mandatory-information-invalid" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_FAILURE, "QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_FAILURE", "access-stratum-failure" },
    { QMI_VOICE_CALL_END_REASON_INVALID_SIM, "QMI_VOICE_CALL_END_REASON_INVALID_SIM", "invalid-sim" },
    { QMI_VOICE_CALL_END_REASON_WRONG_STATE, "QMI_VOICE_CALL_END_REASON_WRONG_STATE", "wrong-state" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_CLASS_BLOCKED, "QMI_VOICE_CALL_END_REASON_ACCESS_CLASS_BLOCKED", "access-class-blocked" },
    { QMI_VOICE_CALL_END_REASON_NO_RESOURCES, "QMI_VOICE_CALL_END_REASON_NO_RESOURCES", "no-resources" },
    { QMI_VOICE_CALL_END_REASON_INVALID_USER_DATA, "QMI_VOICE_CALL_END_REASON_INVALID_USER_DATA", "invalid-user-data" },
    { QMI_VOICE_CALL_END_REASON_TIMER_T3230_EXPIRED, "QMI_VOICE_CALL_END_REASON_TIMER_T3230_EXPIRED", "timer-t3230-expired" },
    { QMI_VOICE_CALL_END_REASON_NO_CELL_AVAILABLE, "QMI_VOICE_CALL_END_REASON_NO_CELL_AVAILABLE", "no-cell-available" },
    { QMI_VOICE_CALL_END_REASON_ABORT_MESSAGE_RECEIVED, "QMI_VOICE_CALL_END_REASON_ABORT_MESSAGE_RECEIVED", "abort-message-received" },
    { QMI_VOICE_CALL_END_REASON_RADIO_LINK_LOST, "QMI_VOICE_CALL_END_REASON_RADIO_LINK_LOST", "radio-link-lost" },
    { QMI_VOICE_CALL_END_REASON_TIMER_T303_EXPIRED, "QMI_VOICE_CALL_END_REASON_TIMER_T303_EXPIRED", "timer-t303-expired" },
    { QMI_VOICE_CALL_END_REASON_CNM_MM_RELEASE_PENDING, "QMI_VOICE_CALL_END_REASON_CNM_MM_RELEASE_PENDING", "cnm-mm-release-pending" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_RR_RELEASE_INDICATION, "QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_RR_RELEASE_INDICATION", "access-stratum-reject-rr-release-indication" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_RR_RANDOM_ACCESS_FAILURE, "QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_RR_RANDOM_ACCESS_FAILURE", "access-stratum-reject-rr-random-access-failure" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_RRC_RELEASE_INDICATION, "QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_RRC_RELEASE_INDICATION", "access-stratum-reject-rrc-release-indication" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_RRC_CLOSE_SESSION_INDICATION, "QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_RRC_CLOSE_SESSION_INDICATION", "access-stratum-reject-rrc-close-session-indication" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_RRC_OPEN_SESSION_FAILURE, "QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_RRC_OPEN_SESSION_FAILURE", "access-stratum-reject-rrc-open-session-failure" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_LOW_LEVEL_FAILURE, "QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_LOW_LEVEL_FAILURE", "access-stratum-reject-low-level-failure" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_LOW_LEVEL_FAILURE_REDIAL_NOT_ALLOWED, "QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_LOW_LEVEL_FAILURE_REDIAL_NOT_ALLOWED", "access-stratum-reject-low-level-failure-redial-not-allowed" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_LOW_LEVEL_IMMEDIATE_RETRY, "QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_LOW_LEVEL_IMMEDIATE_RETRY", "access-stratum-reject-low-level-immediate-retry" },
    { QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_ABORT_RADIO_UNAVAILABLE, "QMI_VOICE_CALL_END_REASON_ACCESS_STRATUM_REJECT_ABORT_RADIO_UNAVAILABLE", "access-stratum-reject-abort-radio-unavailable" },
    { QMI_VOICE_CALL_END_REASON_SERVICE_OPTION_NOT_SUPPORTED, "QMI_VOICE_CALL_END_REASON_SERVICE_OPTION_NOT_SUPPORTED", "service-option-not-supported" },
    { QMI_VOICE_CALL_END_REASON_BAD_REQUEST_WAIT_INVITE, "QMI_VOICE_CALL_END_REASON_BAD_REQUEST_WAIT_INVITE", "bad-request-wait-invite" },
    { QMI_VOICE_CALL_END_REASON_BAD_REQUEST_WAIT_REINVITE, "QMI_VOICE_CALL_END_REASON_BAD_REQUEST_WAIT_REINVITE", "bad-request-wait-reinvite" },
    { QMI_VOICE_CALL_END_REASON_INVALID_REMOTE_URI, "QMI_VOICE_CALL_END_REASON_INVALID_REMOTE_URI", "invalid-remote-uri" },
    { QMI_VOICE_CALL_END_REASON_REMOTE_UNSUPPORTED_MEDIA_TYPE, "QMI_VOICE_CALL_END_REASON_REMOTE_UNSUPPORTED_MEDIA_TYPE", "remote-unsupported-media-type" },
    { QMI_VOICE_CALL_END_REASON_PEER_NOT_REACHABLE, "QMI_VOICE_CALL_END_REASON_PEER_NOT_REACHABLE", "peer-not-reachable" },
    { QMI_VOICE_CALL_END_REASON_NETWORK_NO_RESPONSE_TIMEOUT, "QMI_VOICE_CALL_END_REASON_NETWORK_NO_RESPONSE_TIMEOUT", "network-no-response-timeout" },
    { QMI_VOICE_CALL_END_REASON_NETWORK_NO_RESPONSE_HOLD_FAILURE, "QMI_VOICE_CALL_END_REASON_NETWORK_NO_RESPONSE_HOLD_FAILURE", "network-no-response-hold-failure" },
    { QMI_VOICE_CALL_END_REASON_DATA_CONNECTION_LOST, "QMI_VOICE_CALL_END_REASON_DATA_CONNECTION_LOST", "data-connection-lost" },
    { QMI_VOICE_CALL_END_REASON_UPGRADE_DOWNGRADE_REJECTED, "QMI_VOICE_CALL_END_REASON_UPGRADE_DOWNGRADE_REJECTED", "upgrade-downgrade-rejected" },
    { QMI_VOICE_CALL_END_REASON_SIP_403_FORBIDDEN, "QMI_VOICE_CALL_END_REASON_SIP_403_FORBIDDEN", "sip-403-forbidden" },
    { QMI_VOICE_CALL_END_REASON_NO_NETWORK_RESPONSE, "QMI_VOICE_CALL_END_REASON_NO_NETWORK_RESPONSE", "no-network-response" },
    { QMI_VOICE_CALL_END_REASON_UPGRADE_DOWNGRADE_FAILED, "QMI_VOICE_CALL_END_REASON_UPGRADE_DOWNGRADE_FAILED", "upgrade-downgrade-failed" },
    { QMI_VOICE_CALL_END_REASON_UPGRADE_DOWNGRADE_CANCELLED, "QMI_VOICE_CALL_END_REASON_UPGRADE_DOWNGRADE_CANCELLED", "upgrade-downgrade-cancelled" },
    { QMI_VOICE_CALL_END_REASON_SSAC_REJECT, "QMI_VOICE_CALL_END_REASON_SSAC_REJECT", "ssac-reject" },
    { QMI_VOICE_CALL_END_REASON_THERMAL_EMERGENCY, "QMI_VOICE_CALL_END_REASON_THERMAL_EMERGENCY", "thermal-emergency" },
    { QMI_VOICE_CALL_END_REASON_1XCSFB_SOFT_FAILURE, "QMI_VOICE_CALL_END_REASON_1XCSFB_SOFT_FAILURE", "1xcsfb-soft-failure" },
    { QMI_VOICE_CALL_END_REASON_1XCSFB_HARD_FAILURE, "QMI_VOICE_CALL_END_REASON_1XCSFB_HARD_FAILURE", "1xcsfb-hard-failure" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_call_end_reason_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceCallEndReason"),
                                      qmi_voice_call_end_reason_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_CALL_END_REASON_IS_ENUM__
const gchar *
qmi_voice_call_end_reason_get_string (QmiVoiceCallEndReason val)
{
    guint i;

    for (i = 0; qmi_voice_call_end_reason_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_call_end_reason_values[i].value)
            return qmi_voice_call_end_reason_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_CALL_END_REASON_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_CALL_END_REASON_IS_FLAGS__
gchar *
qmi_voice_call_end_reason_build_string_from_mask (QmiVoiceCallEndReason mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_call_end_reason_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_call_end_reason_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_call_end_reason_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_call_end_reason_values[i].value) {
            guint c;
            gulong number = qmi_voice_call_end_reason_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_call_end_reason_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_CALL_END_REASON_IS_FLAGS__ */
static const GEnumValue qmi_voice_call_control_result_type_values[] = {
    { QMI_VOICE_CALL_CONTROL_RESULT_TYPE_VOICE, "QMI_VOICE_CALL_CONTROL_RESULT_TYPE_VOICE", "voice" },
    { QMI_VOICE_CALL_CONTROL_RESULT_TYPE_SUPS, "QMI_VOICE_CALL_CONTROL_RESULT_TYPE_SUPS", "sups" },
    { QMI_VOICE_CALL_CONTROL_RESULT_TYPE_USSD, "QMI_VOICE_CALL_CONTROL_RESULT_TYPE_USSD", "ussd" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_call_control_result_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceCallControlResultType"),
                                      qmi_voice_call_control_result_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_CALL_CONTROL_RESULT_TYPE_IS_ENUM__
const gchar *
qmi_voice_call_control_result_type_get_string (QmiVoiceCallControlResultType val)
{
    guint i;

    for (i = 0; qmi_voice_call_control_result_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_call_control_result_type_values[i].value)
            return qmi_voice_call_control_result_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_CALL_CONTROL_RESULT_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_CALL_CONTROL_RESULT_TYPE_IS_FLAGS__
gchar *
qmi_voice_call_control_result_type_build_string_from_mask (QmiVoiceCallControlResultType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_call_control_result_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_call_control_result_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_call_control_result_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_call_control_result_type_values[i].value) {
            guint c;
            gulong number = qmi_voice_call_control_result_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_call_control_result_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_CALL_CONTROL_RESULT_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_voice_call_control_supplementary_service_type_values[] = {
    { QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_ACTIVATE, "QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_ACTIVATE", "activate" },
    { QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_DEACTIVATE, "QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_DEACTIVATE", "deactivate" },
    { QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_REGISTER, "QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_REGISTER", "register" },
    { QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_ERASE, "QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_ERASE", "erase" },
    { QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_INTERROGATE, "QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_INTERROGATE", "interrogate" },
    { QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_REGISTER_PASSWORD, "QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_REGISTER_PASSWORD", "register-password" },
    { QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_USSD, "QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_USSD", "ussd" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_call_control_supplementary_service_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceCallControlSupplementaryServiceType"),
                                      qmi_voice_call_control_supplementary_service_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_IS_ENUM__
const gchar *
qmi_voice_call_control_supplementary_service_type_get_string (QmiVoiceCallControlSupplementaryServiceType val)
{
    guint i;

    for (i = 0; qmi_voice_call_control_supplementary_service_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_call_control_supplementary_service_type_values[i].value)
            return qmi_voice_call_control_supplementary_service_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_IS_FLAGS__
gchar *
qmi_voice_call_control_supplementary_service_type_build_string_from_mask (QmiVoiceCallControlSupplementaryServiceType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_call_control_supplementary_service_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_call_control_supplementary_service_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_call_control_supplementary_service_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_call_control_supplementary_service_type_values[i].value) {
            guint c;
            gulong number = qmi_voice_call_control_supplementary_service_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_call_control_supplementary_service_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_CALL_CONTROL_SUPPLEMENTARY_SERVICE_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_voice_supplementary_service_type_values[] = {
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_RELEASE_HELD_OR_WAITING, "QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_RELEASE_HELD_OR_WAITING", "release-held-or-waiting" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING, "QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING", "release-active-accept-held-or-waiting" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD, "QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD", "hold-active-accept-waiting-or-held" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_HOLD_ALL_EXCEPT_SPECIFIED_CALL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_HOLD_ALL_EXCEPT_SPECIFIED_CALL", "hold-all-except-specified-call" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_MAKE_CONFERENCE_CALL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_MAKE_CONFERENCE_CALL", "make-conference-call" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_EXPLICIT_CALL_TRANSFER, "QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_EXPLICIT_CALL_TRANSFER", "explicit-call-transfer" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_CCBS_ACTIVATION, "QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_CCBS_ACTIVATION", "ccbs-activation" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_END_ALL_CALLS, "QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_END_ALL_CALLS", "end-all-calls" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_RELEASE_SPECIFIED_CALL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_RELEASE_SPECIFIED_CALL", "release-specified-call" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_LOCAL_HOLD, "QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_LOCAL_HOLD", "local-hold" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_LOCAL_UNHOLD, "QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_LOCAL_UNHOLD", "local-unhold" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_supplementary_service_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceSupplementaryServiceType"),
                                      qmi_voice_supplementary_service_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_IS_ENUM__
const gchar *
qmi_voice_supplementary_service_type_get_string (QmiVoiceSupplementaryServiceType val)
{
    guint i;

    for (i = 0; qmi_voice_supplementary_service_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_supplementary_service_type_values[i].value)
            return qmi_voice_supplementary_service_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_IS_FLAGS__
gchar *
qmi_voice_supplementary_service_type_build_string_from_mask (QmiVoiceSupplementaryServiceType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_supplementary_service_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_supplementary_service_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_supplementary_service_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_supplementary_service_type_values[i].value) {
            guint c;
            gulong number = qmi_voice_supplementary_service_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_supplementary_service_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_SUPPLEMENTARY_SERVICE_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_voice_supplementary_service_notification_type_values[] = {
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_OUTGOING_CALL_IS_FORWARDED, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_OUTGOING_CALL_IS_FORWARDED", "outgoing-call-is-forwarded" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_OUTGOING_CALL_IS_WAITING, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_OUTGOING_CALL_IS_WAITING", "outgoing-call-is-waiting" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_OUTGOING_CUG_CALL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_OUTGOING_CUG_CALL", "outgoing-cug-call" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_OUTGOING_CALLS_BARRED, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_OUTGOING_CALLS_BARRED", "outgoing-calls-barred" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_OUTGOING_CALL_IS_DEFLECTED, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_OUTGOING_CALL_IS_DEFLECTED", "outgoing-call-is-deflected" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_CUG_CALL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_CUG_CALL", "incoming-cug-call" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_CALLS_BARRED, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_CALLS_BARRED", "incoming-calls-barred" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_FORWARDED_CALL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_FORWARDED_CALL", "incoming-forwarded-call" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_DEFLECTED_CALL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_DEFLECTED_CALL", "incoming-deflected-call" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_CALL_IS_FORWARDED, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_CALL_IS_FORWARDED", "incoming-call-is-forwarded" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_UNCONDITIONAL_CALL_FORWARD_ACTIVE, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_UNCONDITIONAL_CALL_FORWARD_ACTIVE", "unconditional-call-forward-active" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_CONDITIONAL_CALL_FORWARD_ACTIVE, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_CONDITIONAL_CALL_FORWARD_ACTIVE", "conditional-call-forward-active" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_CLIR_SUPPRESSION_REJECTED, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_CLIR_SUPPRESSION_REJECTED", "clir-suppression-rejected" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_CALL_IS_ON_HOLD, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_CALL_IS_ON_HOLD", "call-is-on-hold" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_CALL_IS_RETRIEVED, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_CALL_IS_RETRIEVED", "call-is-retrieved" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_CALL_IS_IN_MULTIPARTY, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_CALL_IS_IN_MULTIPARTY", "call-is-in-multiparty" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_CALL_IS_ECT, "QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_INCOMING_CALL_IS_ECT", "incoming-call-is-ect" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_supplementary_service_notification_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceSupplementaryServiceNotificationType"),
                                      qmi_voice_supplementary_service_notification_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_IS_ENUM__
const gchar *
qmi_voice_supplementary_service_notification_type_get_string (QmiVoiceSupplementaryServiceNotificationType val)
{
    guint i;

    for (i = 0; qmi_voice_supplementary_service_notification_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_supplementary_service_notification_type_values[i].value)
            return qmi_voice_supplementary_service_notification_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_IS_FLAGS__
gchar *
qmi_voice_supplementary_service_notification_type_build_string_from_mask (QmiVoiceSupplementaryServiceNotificationType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_supplementary_service_notification_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_supplementary_service_notification_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_supplementary_service_notification_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_supplementary_service_notification_type_values[i].value) {
            guint c;
            gulong number = qmi_voice_supplementary_service_notification_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_supplementary_service_notification_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_SUPPLEMENTARY_SERVICE_NOTIFICATION_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_voice_supplementary_service_action_values[] = {
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_ACTIVATE, "QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_ACTIVATE", "activate" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_DEACTIVATE, "QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_DEACTIVATE", "deactivate" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_REGISTER, "QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_REGISTER", "register" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_ERASE, "QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_ERASE", "erase" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_supplementary_service_action_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceSupplementaryServiceAction"),
                                      qmi_voice_supplementary_service_action_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_IS_ENUM__
const gchar *
qmi_voice_supplementary_service_action_get_string (QmiVoiceSupplementaryServiceAction val)
{
    guint i;

    for (i = 0; qmi_voice_supplementary_service_action_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_supplementary_service_action_values[i].value)
            return qmi_voice_supplementary_service_action_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_IS_FLAGS__
gchar *
qmi_voice_supplementary_service_action_build_string_from_mask (QmiVoiceSupplementaryServiceAction mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_supplementary_service_action_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_supplementary_service_action_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_supplementary_service_action_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_supplementary_service_action_values[i].value) {
            guint c;
            gulong number = qmi_voice_supplementary_service_action_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_supplementary_service_action_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_SUPPLEMENTARY_SERVICE_ACTION_IS_FLAGS__ */
static const GEnumValue qmi_voice_supplementary_service_reason_values[] = {
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_UNCONDITIONAL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_UNCONDITIONAL", "forward-unconditional" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_MOBILE_BUSY, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_MOBILE_BUSY", "forward-mobile-busy" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_NO_REPLY, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_NO_REPLY", "forward-no-reply" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_UNREACHABLE, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_UNREACHABLE", "forward-unreachable" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_ALL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_ALL", "forward-all" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_ALL_CONDITIONAL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_FORWARD_ALL_CONDITIONAL", "forward-all-conditional" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_ALL_OUTGOING, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_ALL_OUTGOING", "all-outgoing" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_OUTGOING_INTERNAL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_OUTGOING_INTERNAL", "outgoing-internal" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_OUTGOING_INTERNAL_EXTERNAL_TO_HOME, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_OUTGOING_INTERNAL_EXTERNAL_TO_HOME", "outgoing-internal-external-to-home" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_ALL_INCOMING, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_ALL_INCOMING", "all-incoming" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_INCOMING_ROAMING, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_INCOMING_ROAMING", "incoming-roaming" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_BAR_ALL, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_BAR_ALL", "bar-all" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_BAR_ALL_OUTGOING, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_BAR_ALL_OUTGOING", "bar-all-outgoing" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_BAR_ALL_INCOMING, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_BAR_ALL_INCOMING", "bar-all-incoming" },
    { QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_CALL_WAITING, "QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_CALL_WAITING", "call-waiting" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_voice_supplementary_service_reason_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiVoiceSupplementaryServiceReason"),
                                      qmi_voice_supplementary_service_reason_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_IS_ENUM__
const gchar *
qmi_voice_supplementary_service_reason_get_string (QmiVoiceSupplementaryServiceReason val)
{
    guint i;

    for (i = 0; qmi_voice_supplementary_service_reason_values[i].value_nick; i++) {
      if ((gint)val == qmi_voice_supplementary_service_reason_values[i].value)
            return qmi_voice_supplementary_service_reason_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_IS_FLAGS__
gchar *
qmi_voice_supplementary_service_reason_build_string_from_mask (QmiVoiceSupplementaryServiceReason mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_voice_supplementary_service_reason_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_voice_supplementary_service_reason_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_voice_supplementary_service_reason_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_voice_supplementary_service_reason_values[i].value) {
            guint c;
            gulong number = qmi_voice_supplementary_service_reason_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_voice_supplementary_service_reason_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_VOICE_SUPPLEMENTARY_SERVICE_REASON_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-wda.h" */
static const GEnumValue qmi_wda_link_layer_protocol_values[] = {
    { QMI_WDA_LINK_LAYER_PROTOCOL_UNKNOWN, "QMI_WDA_LINK_LAYER_PROTOCOL_UNKNOWN", "unknown" },
    { QMI_WDA_LINK_LAYER_PROTOCOL_802_3, "QMI_WDA_LINK_LAYER_PROTOCOL_802_3", "802-3" },
    { QMI_WDA_LINK_LAYER_PROTOCOL_RAW_IP, "QMI_WDA_LINK_LAYER_PROTOCOL_RAW_IP", "raw-ip" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wda_link_layer_protocol_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdaLinkLayerProtocol"),
                                      qmi_wda_link_layer_protocol_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDA_LINK_LAYER_PROTOCOL_IS_ENUM__
const gchar *
qmi_wda_link_layer_protocol_get_string (QmiWdaLinkLayerProtocol val)
{
    guint i;

    for (i = 0; qmi_wda_link_layer_protocol_values[i].value_nick; i++) {
      if ((gint)val == qmi_wda_link_layer_protocol_values[i].value)
            return qmi_wda_link_layer_protocol_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDA_LINK_LAYER_PROTOCOL_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDA_LINK_LAYER_PROTOCOL_IS_FLAGS__
gchar *
qmi_wda_link_layer_protocol_build_string_from_mask (QmiWdaLinkLayerProtocol mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wda_link_layer_protocol_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wda_link_layer_protocol_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wda_link_layer_protocol_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wda_link_layer_protocol_values[i].value) {
            guint c;
            gulong number = qmi_wda_link_layer_protocol_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wda_link_layer_protocol_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDA_LINK_LAYER_PROTOCOL_IS_FLAGS__ */
static const GEnumValue qmi_wda_data_aggregation_protocol_values[] = {
    { QMI_WDA_DATA_AGGREGATION_PROTOCOL_DISABLED, "QMI_WDA_DATA_AGGREGATION_PROTOCOL_DISABLED", "disabled" },
    { QMI_WDA_DATA_AGGREGATION_PROTOCOL_TLP, "QMI_WDA_DATA_AGGREGATION_PROTOCOL_TLP", "tlp" },
    { QMI_WDA_DATA_AGGREGATION_PROTOCOL_QC_NCM, "QMI_WDA_DATA_AGGREGATION_PROTOCOL_QC_NCM", "qc-ncm" },
    { QMI_WDA_DATA_AGGREGATION_PROTOCOL_MBIM, "QMI_WDA_DATA_AGGREGATION_PROTOCOL_MBIM", "mbim" },
    { QMI_WDA_DATA_AGGREGATION_PROTOCOL_RNDIS, "QMI_WDA_DATA_AGGREGATION_PROTOCOL_RNDIS", "rndis" },
    { QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAP, "QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAP", "qmap" },
    { QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAPV2, "QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAPV2", "qmapv2" },
    { QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAPV3, "QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAPV3", "qmapv3" },
    { QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAPV4, "QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAPV4", "qmapv4" },
    { QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAPV5, "QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAPV5", "qmapv5" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wda_data_aggregation_protocol_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdaDataAggregationProtocol"),
                                      qmi_wda_data_aggregation_protocol_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDA_DATA_AGGREGATION_PROTOCOL_IS_ENUM__
const gchar *
qmi_wda_data_aggregation_protocol_get_string (QmiWdaDataAggregationProtocol val)
{
    guint i;

    for (i = 0; qmi_wda_data_aggregation_protocol_values[i].value_nick; i++) {
      if ((gint)val == qmi_wda_data_aggregation_protocol_values[i].value)
            return qmi_wda_data_aggregation_protocol_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDA_DATA_AGGREGATION_PROTOCOL_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDA_DATA_AGGREGATION_PROTOCOL_IS_FLAGS__
gchar *
qmi_wda_data_aggregation_protocol_build_string_from_mask (QmiWdaDataAggregationProtocol mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wda_data_aggregation_protocol_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wda_data_aggregation_protocol_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wda_data_aggregation_protocol_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wda_data_aggregation_protocol_values[i].value) {
            guint c;
            gulong number = qmi_wda_data_aggregation_protocol_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wda_data_aggregation_protocol_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDA_DATA_AGGREGATION_PROTOCOL_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-wds.h" */
static const GEnumValue qmi_wds_ip_family_values[] = {
    { QMI_WDS_IP_FAMILY_UNKNOWN, "QMI_WDS_IP_FAMILY_UNKNOWN", "unknown" },
    { QMI_WDS_IP_FAMILY_IPV4, "QMI_WDS_IP_FAMILY_IPV4", "ipv4" },
    { QMI_WDS_IP_FAMILY_IPV6, "QMI_WDS_IP_FAMILY_IPV6", "ipv6" },
    { QMI_WDS_IP_FAMILY_UNSPECIFIED, "QMI_WDS_IP_FAMILY_UNSPECIFIED", "unspecified" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_ip_family_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsIpFamily"),
                                      qmi_wds_ip_family_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_IP_FAMILY_IS_ENUM__
const gchar *
qmi_wds_ip_family_get_string (QmiWdsIpFamily val)
{
    guint i;

    for (i = 0; qmi_wds_ip_family_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_ip_family_values[i].value)
            return qmi_wds_ip_family_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_IP_FAMILY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_IP_FAMILY_IS_FLAGS__
gchar *
qmi_wds_ip_family_build_string_from_mask (QmiWdsIpFamily mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_ip_family_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_ip_family_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_ip_family_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_ip_family_values[i].value) {
            guint c;
            gulong number = qmi_wds_ip_family_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_ip_family_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_IP_FAMILY_IS_FLAGS__ */
static const GFlagsValue qmi_wds_technology_preference_values[] = {
    { QMI_WDS_TECHNOLOGY_PREFERENCE_ALLOW_3GPP, "QMI_WDS_TECHNOLOGY_PREFERENCE_ALLOW_3GPP", "3gpp" },
    { QMI_WDS_TECHNOLOGY_PREFERENCE_ALLOW_3GPP2, "QMI_WDS_TECHNOLOGY_PREFERENCE_ALLOW_3GPP2", "3gpp2" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_technology_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsTechnologyPreference"),
                                      qmi_wds_technology_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_TECHNOLOGY_PREFERENCE_IS_ENUM__
const gchar *
qmi_wds_technology_preference_get_string (QmiWdsTechnologyPreference val)
{
    guint i;

    for (i = 0; qmi_wds_technology_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_technology_preference_values[i].value)
            return qmi_wds_technology_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_TECHNOLOGY_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_TECHNOLOGY_PREFERENCE_IS_FLAGS__
gchar *
qmi_wds_technology_preference_build_string_from_mask (QmiWdsTechnologyPreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_technology_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_technology_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_technology_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_technology_preference_values[i].value) {
            guint c;
            gulong number = qmi_wds_technology_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_technology_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_TECHNOLOGY_PREFERENCE_IS_FLAGS__ */
static const GEnumValue qmi_wds_extended_technology_preference_values[] = {
    { QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_CDMA, "QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_CDMA", "cdma" },
    { QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_UMTS, "QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_UMTS", "umts" },
    { QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_EPC, "QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_EPC", "epc" },
    { QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_EMBMS, "QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_EMBMS", "embms" },
    { QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_MODEM_LINK_LOCAL, "QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_MODEM_LINK_LOCAL", "modem-link-local" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_extended_technology_preference_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsExtendedTechnologyPreference"),
                                      qmi_wds_extended_technology_preference_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_IS_ENUM__
const gchar *
qmi_wds_extended_technology_preference_get_string (QmiWdsExtendedTechnologyPreference val)
{
    guint i;

    for (i = 0; qmi_wds_extended_technology_preference_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_extended_technology_preference_values[i].value)
            return qmi_wds_extended_technology_preference_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_IS_FLAGS__
gchar *
qmi_wds_extended_technology_preference_build_string_from_mask (QmiWdsExtendedTechnologyPreference mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_extended_technology_preference_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_extended_technology_preference_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_extended_technology_preference_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_extended_technology_preference_values[i].value) {
            guint c;
            gulong number = qmi_wds_extended_technology_preference_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_extended_technology_preference_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_IS_FLAGS__ */
static const GEnumValue qmi_wds_call_type_values[] = {
    { QMI_WDS_CALL_TYPE_LAPTOP, "QMI_WDS_CALL_TYPE_LAPTOP", "laptop" },
    { QMI_WDS_CALL_TYPE_EMBEDDED, "QMI_WDS_CALL_TYPE_EMBEDDED", "embedded" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_call_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsCallType"),
                                      qmi_wds_call_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_CALL_TYPE_IS_ENUM__
const gchar *
qmi_wds_call_type_get_string (QmiWdsCallType val)
{
    guint i;

    for (i = 0; qmi_wds_call_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_call_type_values[i].value)
            return qmi_wds_call_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_CALL_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_CALL_TYPE_IS_FLAGS__
gchar *
qmi_wds_call_type_build_string_from_mask (QmiWdsCallType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_call_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_call_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_call_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_call_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_call_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_call_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_CALL_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wds_call_end_reason_values[] = {
    { QMI_WDS_CALL_END_REASON_GENERIC_UNSPECIFIED, "QMI_WDS_CALL_END_REASON_GENERIC_UNSPECIFIED", "generic-unspecified" },
    { QMI_WDS_CALL_END_REASON_GENERIC_CLIENT_END, "QMI_WDS_CALL_END_REASON_GENERIC_CLIENT_END", "generic-client-end" },
    { QMI_WDS_CALL_END_REASON_GENERIC_NO_SERVICE, "QMI_WDS_CALL_END_REASON_GENERIC_NO_SERVICE", "generic-no-service" },
    { QMI_WDS_CALL_END_REASON_GENERIC_FADE, "QMI_WDS_CALL_END_REASON_GENERIC_FADE", "generic-fade" },
    { QMI_WDS_CALL_END_REASON_GENERIC_RELEASE_NORMAL, "QMI_WDS_CALL_END_REASON_GENERIC_RELEASE_NORMAL", "generic-release-normal" },
    { QMI_WDS_CALL_END_REASON_GENERIC_ACCESS_ATTEMPT_IN_PROGRESS, "QMI_WDS_CALL_END_REASON_GENERIC_ACCESS_ATTEMPT_IN_PROGRESS", "generic-access-attempt-in-progress" },
    { QMI_WDS_CALL_END_REASON_GENERIC_ACCESS_FAILURE, "QMI_WDS_CALL_END_REASON_GENERIC_ACCESS_FAILURE", "generic-access-failure" },
    { QMI_WDS_CALL_END_REASON_GENERIC_REDIRECTION_OR_HANDOFF, "QMI_WDS_CALL_END_REASON_GENERIC_REDIRECTION_OR_HANDOFF", "generic-redirection-or-handoff" },
    { QMI_WDS_CALL_END_REASON_GENERIC_CLOSE_IN_PROGRESS, "QMI_WDS_CALL_END_REASON_GENERIC_CLOSE_IN_PROGRESS", "generic-close-in-progress" },
    { QMI_WDS_CALL_END_REASON_GENERIC_AUTHENTICATION_FAILED, "QMI_WDS_CALL_END_REASON_GENERIC_AUTHENTICATION_FAILED", "generic-authentication-failed" },
    { QMI_WDS_CALL_END_REASON_GENERIC_INTERNAL_ERROR, "QMI_WDS_CALL_END_REASON_GENERIC_INTERNAL_ERROR", "generic-internal-error" },
    { QMI_WDS_CALL_END_REASON_CDMA_LOCK, "QMI_WDS_CALL_END_REASON_CDMA_LOCK", "cdma-lock" },
    { QMI_WDS_CALL_END_REASON_CDMA_INTERCEPT, "QMI_WDS_CALL_END_REASON_CDMA_INTERCEPT", "cdma-intercept" },
    { QMI_WDS_CALL_END_REASON_CDMA_REORDER, "QMI_WDS_CALL_END_REASON_CDMA_REORDER", "cdma-reorder" },
    { QMI_WDS_CALL_END_REASON_CDMA_RELEASE_SO_REJECT, "QMI_WDS_CALL_END_REASON_CDMA_RELEASE_SO_REJECT", "cdma-release-so-reject" },
    { QMI_WDS_CALL_END_REASON_CDMA_INCOMING_CALL, "QMI_WDS_CALL_END_REASON_CDMA_INCOMING_CALL", "cdma-incoming-call" },
    { QMI_WDS_CALL_END_REASON_CDMA_ALERT_STOP, "QMI_WDS_CALL_END_REASON_CDMA_ALERT_STOP", "cdma-alert-stop" },
    { QMI_WDS_CALL_END_REASON_CDMA_ACTIVATION, "QMI_WDS_CALL_END_REASON_CDMA_ACTIVATION", "cdma-activation" },
    { QMI_WDS_CALL_END_REASON_CDMA_MAX_ACCESS_PROBES, "QMI_WDS_CALL_END_REASON_CDMA_MAX_ACCESS_PROBES", "cdma-max-access-probes" },
    { QMI_WDS_CALL_END_REASON_CDMA_CCS_NOT_SUPPORTED_BY_BS, "QMI_WDS_CALL_END_REASON_CDMA_CCS_NOT_SUPPORTED_BY_BS", "cdma-ccs-not-supported-by-bs" },
    { QMI_WDS_CALL_END_REASON_CDMA_NO_RESPONSE_FROM_BS, "QMI_WDS_CALL_END_REASON_CDMA_NO_RESPONSE_FROM_BS", "cdma-no-response-from-bs" },
    { QMI_WDS_CALL_END_REASON_CDMA_REJECTED_BY_BS, "QMI_WDS_CALL_END_REASON_CDMA_REJECTED_BY_BS", "cdma-rejected-by-bs" },
    { QMI_WDS_CALL_END_REASON_CDMA_INCOMPATIBLE, "QMI_WDS_CALL_END_REASON_CDMA_INCOMPATIBLE", "cdma-incompatible" },
    { QMI_WDS_CALL_END_REASON_CDMA_ALREADY_IN_TC, "QMI_WDS_CALL_END_REASON_CDMA_ALREADY_IN_TC", "cdma-already-in-tc" },
    { QMI_WDS_CALL_END_REASON_CDMA_USER_CALL_ORIGINATED_DURING_GPS, "QMI_WDS_CALL_END_REASON_CDMA_USER_CALL_ORIGINATED_DURING_GPS", "cdma-user-call-originated-during-gps" },
    { QMI_WDS_CALL_END_REASON_CDMA_USER_CALL_ORIGINATED_DURING_SMS, "QMI_WDS_CALL_END_REASON_CDMA_USER_CALL_ORIGINATED_DURING_SMS", "cdma-user-call-originated-during-sms" },
    { QMI_WDS_CALL_END_REASON_CDMA_NO_SERVICE, "QMI_WDS_CALL_END_REASON_CDMA_NO_SERVICE", "cdma-no-service" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_CONFERENCE_FAILED, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_CONFERENCE_FAILED", "gsm-wcdma-conference-failed" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_INCOMING_REJECTED, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_INCOMING_REJECTED", "gsm-wcdma-incoming-rejected" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_NO_SERVICE, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_NO_SERVICE", "gsm-wcdma-no-service" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_NETWORK_END, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_NETWORK_END", "gsm-wcdma-network-end" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_LLC_SNDCP_FAILURE, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_LLC_SNDCP_FAILURE", "gsm-wcdma-llc-sndcp-failure" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_INSUFFICIENT_RESOURCES, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_INSUFFICIENT_RESOURCES", "gsm-wcdma-insufficient-resources" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_OPTION_TEMPORARILY_OUT_OF_ORDER, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_OPTION_TEMPORARILY_OUT_OF_ORDER", "gsm-wcdma-option-temporarily-out-of-order" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_NSAPI_ALREADY_USED, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_NSAPI_ALREADY_USED", "gsm-wcdma-nsapi-already-used" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_REGULAR_DEACTIVATION, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_REGULAR_DEACTIVATION", "gsm-wcdma-regular-deactivation" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_NETWORK_FAILURE, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_NETWORK_FAILURE", "gsm-wcdma-network-failure" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_REATTACH_REQUIRED, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_REATTACH_REQUIRED", "gsm-wcdma-reattach-required" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_PROTOCOL_ERROR, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_PROTOCOL_ERROR", "gsm-wcdma-protocol-error" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_OPERATOR_DETERMINED_BARRING, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_OPERATOR_DETERMINED_BARRING", "gsm-wcdma-operator-determined-barring" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_UNKNOWN_APN, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_UNKNOWN_APN", "gsm-wcdma-unknown-apn" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_UNKNOWN_PDP, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_UNKNOWN_PDP", "gsm-wcdma-unknown-pdp" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_GGSN_REJECT, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_GGSN_REJECT", "gsm-wcdma-ggsn-reject" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_ACTIVATION_REJECT, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_ACTIVATION_REJECT", "gsm-wcdma-activation-reject" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_OPTION_NOT_SUPPORTED, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_OPTION_NOT_SUPPORTED", "gsm-wcdma-option-not-supported" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_OPTION_UNSUBSCRIBED, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_OPTION_UNSUBSCRIBED", "gsm-wcdma-option-unsubscribed" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_QOS_NOT_ACCEPTED, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_QOS_NOT_ACCEPTED", "gsm-wcdma-qos-not-accepted" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_TFT_SEMANTIC_ERROR, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_TFT_SEMANTIC_ERROR", "gsm-wcdma-tft-semantic-error" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_TFT_SYNTAX_ERROR, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_TFT_SYNTAX_ERROR", "gsm-wcdma-tft-syntax-error" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_UNKNOWN_PDP_CONTEXT, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_UNKNOWN_PDP_CONTEXT", "gsm-wcdma-unknown-pdp-context" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_FILTER_SEMANTIC_ERROR, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_FILTER_SEMANTIC_ERROR", "gsm-wcdma-filter-semantic-error" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_FILTER_SYNTAX_ERROR, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_FILTER_SYNTAX_ERROR", "gsm-wcdma-filter-syntax-error" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_PDP_WITHOUT_ACTIVE_TFT, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_PDP_WITHOUT_ACTIVE_TFT", "gsm-wcdma-pdp-without-active-tft" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_INVALID_TRANSACTION_ID, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_INVALID_TRANSACTION_ID", "gsm-wcdma-invalid-transaction-id" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_MESSAGE_INCORRECT_SEMANTIC, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_MESSAGE_INCORRECT_SEMANTIC", "gsm-wcdma-message-incorrect-semantic" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_INVALID_MANDATORY_INFO, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_INVALID_MANDATORY_INFO", "gsm-wcdma-invalid-mandatory-info" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_MESSAGE_TYPE_UNSUPPORTED, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_MESSAGE_TYPE_UNSUPPORTED", "gsm-wcdma-message-type-unsupported" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_MESSAGE_TYPE_NONCOMPATIBLE_STATE, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_MESSAGE_TYPE_NONCOMPATIBLE_STATE", "gsm-wcdma-message-type-noncompatible-state" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_UNKNOWN_INFO_ELEMENT, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_UNKNOWN_INFO_ELEMENT", "gsm-wcdma-unknown-info-element" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_CONDITIONAL_IE_ERROR, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_CONDITIONAL_IE_ERROR", "gsm-wcdma-conditional-ie-error" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_MESSAGE_AND_PROTOCOL_STATE_UNCOMPATIBLE, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_MESSAGE_AND_PROTOCOL_STATE_UNCOMPATIBLE", "gsm-wcdma-message-and-protocol-state-uncompatible" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_APN_TYPE_CONFLICT, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_APN_TYPE_CONFLICT", "gsm-wcdma-apn-type-conflict" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_NO_GPRS_CONTEXT, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_NO_GPRS_CONTEXT", "gsm-wcdma-no-gprs-context" },
    { QMI_WDS_CALL_END_REASON_GSM_WCDMA_FEATURE_NOT_SUPPORTED, "QMI_WDS_CALL_END_REASON_GSM_WCDMA_FEATURE_NOT_SUPPORTED", "gsm-wcdma-feature-not-supported" },
    { QMI_WDS_CALL_END_REASON_EVDO_CONNECTION_DENY_GENERAL_OR_BUSY, "QMI_WDS_CALL_END_REASON_EVDO_CONNECTION_DENY_GENERAL_OR_BUSY", "evdo-connection-deny-general-or-busy" },
    { QMI_WDS_CALL_END_REASON_EVDO_CONNECTION_DENY_BILLING_OR_AUTHENTICATION_FAILURE, "QMI_WDS_CALL_END_REASON_EVDO_CONNECTION_DENY_BILLING_OR_AUTHENTICATION_FAILURE", "evdo-connection-deny-billing-or-authentication-failure" },
    { QMI_WDS_CALL_END_REASON_EVDO_HDR_CHANGE, "QMI_WDS_CALL_END_REASON_EVDO_HDR_CHANGE", "evdo-hdr-change" },
    { QMI_WDS_CALL_END_REASON_EVDO_HDR_EXIT, "QMI_WDS_CALL_END_REASON_EVDO_HDR_EXIT", "evdo-hdr-exit" },
    { QMI_WDS_CALL_END_REASON_EVDO_HDR_NO_SESSION, "QMI_WDS_CALL_END_REASON_EVDO_HDR_NO_SESSION", "evdo-hdr-no-session" },
    { QMI_WDS_CALL_END_REASON_EVDO_HDR_ORIGINATION_DURING_GPS_FIX, "QMI_WDS_CALL_END_REASON_EVDO_HDR_ORIGINATION_DURING_GPS_FIX", "evdo-hdr-origination-during-gps-fix" },
    { QMI_WDS_CALL_END_REASON_EVDO_HDR_CONNECTION_SETUP_TIMEOUT, "QMI_WDS_CALL_END_REASON_EVDO_HDR_CONNECTION_SETUP_TIMEOUT", "evdo-hdr-connection-setup-timeout" },
    { QMI_WDS_CALL_END_REASON_EVDO_HDR_RELEASED_BY_CM, "QMI_WDS_CALL_END_REASON_EVDO_HDR_RELEASED_BY_CM", "evdo-hdr-released-by-cm" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_call_end_reason_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsCallEndReason"),
                                      qmi_wds_call_end_reason_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_CALL_END_REASON_IS_ENUM__
const gchar *
qmi_wds_call_end_reason_get_string (QmiWdsCallEndReason val)
{
    guint i;

    for (i = 0; qmi_wds_call_end_reason_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_call_end_reason_values[i].value)
            return qmi_wds_call_end_reason_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_CALL_END_REASON_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_CALL_END_REASON_IS_FLAGS__
gchar *
qmi_wds_call_end_reason_build_string_from_mask (QmiWdsCallEndReason mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_call_end_reason_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_call_end_reason_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_call_end_reason_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_call_end_reason_values[i].value) {
            guint c;
            gulong number = qmi_wds_call_end_reason_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_call_end_reason_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_CALL_END_REASON_IS_FLAGS__ */
static const GEnumValue qmi_wds_verbose_call_end_reason_type_values[] = {
    { QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_MIP, "QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_MIP", "mip" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_INTERNAL, "QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_INTERNAL", "internal" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_CM, "QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_CM", "cm" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_3GPP, "QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_3GPP", "3gpp" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_PPP, "QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_PPP", "ppp" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_EHRPD, "QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_EHRPD", "ehrpd" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_IPV6, "QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_IPV6", "ipv6" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_verbose_call_end_reason_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsVerboseCallEndReasonType"),
                                      qmi_wds_verbose_call_end_reason_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_IS_ENUM__
const gchar *
qmi_wds_verbose_call_end_reason_type_get_string (QmiWdsVerboseCallEndReasonType val)
{
    guint i;

    for (i = 0; qmi_wds_verbose_call_end_reason_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_verbose_call_end_reason_type_values[i].value)
            return qmi_wds_verbose_call_end_reason_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_IS_FLAGS__
gchar *
qmi_wds_verbose_call_end_reason_type_build_string_from_mask (QmiWdsVerboseCallEndReasonType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_verbose_call_end_reason_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_verbose_call_end_reason_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_verbose_call_end_reason_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_verbose_call_end_reason_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_verbose_call_end_reason_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_verbose_call_end_reason_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wds_verbose_call_end_reason_mip_values[] = {
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_ERROR_REASON_UNKNOWN, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_ERROR_REASON_UNKNOWN", "error-reason-unknown" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_REASON_UNSPECIFIED, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_REASON_UNSPECIFIED", "fa-error-reason-unspecified" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_ADMINISTRATIVELY_PROHIBITED, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_ADMINISTRATIVELY_PROHIBITED", "fa-error-administratively-prohibited" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_INSUFFICIENT_RESOURCES, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_INSUFFICIENT_RESOURCES", "fa-error-insufficient-resources" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MOBILE_NODE_AUTHENTICATION_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MOBILE_NODE_AUTHENTICATION_FAILURE", "fa-error-mobile-node-authentication-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_HA_AUTHENTICATION_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_HA_AUTHENTICATION_FAILURE", "fa-error-ha-authentication-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_REQUESTED_LIFETIME_TOO_LONG, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_REQUESTED_LIFETIME_TOO_LONG", "fa-error-requested-lifetime-too-long" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MALFORMED_REQUEST, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MALFORMED_REQUEST", "fa-error-malformed-request" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MALFORMED_REPLY, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MALFORMED_REPLY", "fa-error-malformed-reply" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_ENCAPSULATION_UNAVAILABLE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_ENCAPSULATION_UNAVAILABLE", "fa-error-encapsulation-unavailable" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_VJHC_UNAVAILABLE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_VJHC_UNAVAILABLE", "fa-error-vjhc-unavailable" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_REVERSE_TUNNEL_UNAVAILABLE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_REVERSE_TUNNEL_UNAVAILABLE", "fa-error-reverse-tunnel-unavailable" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_REVERSE_TUNNEL_MANDATORY_AND_T_BIT_NOT_SET, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_REVERSE_TUNNEL_MANDATORY_AND_T_BIT_NOT_SET", "fa-error-reverse-tunnel-mandatory-and-t-bit-not-set" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_DELIVERY_STYLE_NOT_SUPPORTED, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_DELIVERY_STYLE_NOT_SUPPORTED", "fa-error-delivery-style-not-supported" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MISSING_NAI, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MISSING_NAI", "fa-error-missing-nai" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MISSING_HA, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MISSING_HA", "fa-error-missing-ha" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MISSING_HOME_ADDRESS, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MISSING_HOME_ADDRESS", "fa-error-missing-home-address" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_UNKNOWN_CHALLENGE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_UNKNOWN_CHALLENGE", "fa-error-unknown-challenge" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MISSING_CHALLENGE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_MISSING_CHALLENGE", "fa-error-missing-challenge" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_STALE_CHALLENGE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_FA_ERROR_STALE_CHALLENGE", "fa-error-stale-challenge" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_REASON_UNSPECIFIED, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_REASON_UNSPECIFIED", "ha-error-reason-unspecified" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_ADMINISTRATIVELY_PROHIBITED, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_ADMINISTRATIVELY_PROHIBITED", "ha-error-administratively-prohibited" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_INSUFFICIENT_RESOURCES, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_INSUFFICIENT_RESOURCES", "ha-error-insufficient-resources" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_MOBILE_NODE_AUTHENTICATION_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_MOBILE_NODE_AUTHENTICATION_FAILURE", "ha-error-mobile-node-authentication-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_FA_AUTHENTICATION_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_FA_AUTHENTICATION_FAILURE", "ha-error-fa-authentication-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_REGISTRATION_ID_MISMATCH, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_REGISTRATION_ID_MISMATCH", "ha-error-registration-id-mismatch" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_MALFORMED_REQUEST, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_MALFORMED_REQUEST", "ha-error-malformed-request" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_UNKNOWN_HA_ADDRESS, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_UNKNOWN_HA_ADDRESS", "ha-error-unknown-ha-address" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_REVERSE_TUNNEL_UNAVAILABLE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_REVERSE_TUNNEL_UNAVAILABLE", "ha-error-reverse-tunnel-unavailable" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_REVERSE_TUNNEL_MANDATORY_AND_T_BIT_NOT_SET, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_REVERSE_TUNNEL_MANDATORY_AND_T_BIT_NOT_SET", "ha-error-reverse-tunnel-mandatory-and-t-bit-not-set" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_ENCAPSULATION_UNAVAILABLE, "QMI_WDS_VERBOSE_CALL_END_REASON_MIP_HA_ERROR_ENCAPSULATION_UNAVAILABLE", "ha-error-encapsulation-unavailable" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_verbose_call_end_reason_mip_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsVerboseCallEndReasonMip"),
                                      qmi_wds_verbose_call_end_reason_mip_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_MIP_IS_ENUM__
const gchar *
qmi_wds_verbose_call_end_reason_mip_get_string (QmiWdsVerboseCallEndReasonMip val)
{
    guint i;

    for (i = 0; qmi_wds_verbose_call_end_reason_mip_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_verbose_call_end_reason_mip_values[i].value)
            return qmi_wds_verbose_call_end_reason_mip_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_MIP_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_MIP_IS_FLAGS__
gchar *
qmi_wds_verbose_call_end_reason_mip_build_string_from_mask (QmiWdsVerboseCallEndReasonMip mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_verbose_call_end_reason_mip_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_verbose_call_end_reason_mip_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_verbose_call_end_reason_mip_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_verbose_call_end_reason_mip_values[i].value) {
            guint c;
            gulong number = qmi_wds_verbose_call_end_reason_mip_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_verbose_call_end_reason_mip_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_MIP_IS_FLAGS__ */
static const GEnumValue qmi_wds_verbose_call_end_reason_internal_values[] = {
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_ERROR, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_ERROR", "error" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_CALL_ENDED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_CALL_ENDED", "call-ended" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_UNKNOWN_INTERNAL_CAUSE, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_UNKNOWN_INTERNAL_CAUSE", "unknown-internal-cause" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_UNKNOWN_CAUSE, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_UNKNOWN_CAUSE", "unknown-cause" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_CLOSE_IN_PROGRESS, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_CLOSE_IN_PROGRESS", "close-in-progress" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_NETWORK_INITIATED_TERMINATION, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_NETWORK_INITIATED_TERMINATION", "network-initiated-termination" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APP_PREEMPTED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APP_PREEMPTED", "app-preempted" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV4_CALL_DISALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV4_CALL_DISALLOWED", "pdn-ipv4-call-disallowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV4_CALL_THROTTLED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV4_CALL_THROTTLED", "pdn-ipv4-call-throttled" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV6_CALL_DISALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV6_CALL_DISALLOWED", "pdn-ipv6-call-disallowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV6_CALL_THROTTLED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV6_CALL_THROTTLED", "pdn-ipv6-call-throttled" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MODEM_RESTART, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MODEM_RESTART", "modem-restart" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDP_PPP_NOT_SUPPORTED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDP_PPP_NOT_SUPPORTED", "pdp-ppp-not-supported" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_UNPREFERRED_RAT, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_UNPREFERRED_RAT", "unpreferred-rat" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PHYSICAL_LINK_CLOSE_IN_PROGRESS, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PHYSICAL_LINK_CLOSE_IN_PROGRESS", "physical-link-close-in-progress" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_PENDING_HANDOVER, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_PENDING_HANDOVER", "apn-pending-handover" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PROFILE_BEARER_INCOMPATIBLE, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PROFILE_BEARER_INCOMPATIBLE", "profile-bearer-incompatible" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MMGDSI_CARD_EVENT, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MMGDSI_CARD_EVENT", "mmgdsi-card-event" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_LPM_OR_POWER_DOWN, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_LPM_OR_POWER_DOWN", "lpm-or-power-down" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_DISABLED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_DISABLED", "apn-disabled" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MPIT_EXPIRED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MPIT_EXPIRED", "mpit-expired" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IPV6_ADDRESS_TRANSFER_FAILED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IPV6_ADDRESS_TRANSFER_FAILED", "ipv6-address-transfer-failed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_TRAT_SWAP_FAILED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_TRAT_SWAP_FAILED", "trat-swap-failed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_EHRPD_TO_HRPD_FALLBACK, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_EHRPD_TO_HRPD_FALLBACK", "ehrpd-to-hrpd-fallback" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MANDATORY_APN_DISABLED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MANDATORY_APN_DISABLED", "mandatory-apn-disabled" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MIP_CONFIG_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MIP_CONFIG_FAILURE", "mip-config-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_INACTIVITY_TIMER_EXPIRED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_INACTIVITY_TIMER_EXPIRED", "pdn-inactivity-timer-expired" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MAX_V4_CONNECTIONS, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MAX_V4_CONNECTIONS", "max-v4-connections" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MAX_V6_CONNECTIONS, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MAX_V6_CONNECTIONS", "max-v6-connections" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_MISMATCH, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_MISMATCH", "apn-mismatch" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IP_VERSION_MISMATCH, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IP_VERSION_MISMATCH", "ip-version-mismatch" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DUN_CALL_DISALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DUN_CALL_DISALLOWED", "dun-call-disallowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INVALID_PROFILE, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INVALID_PROFILE", "invalid-profile" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_EPC_NONEPC_TRANSITION, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_EPC_NONEPC_TRANSITION", "epc-nonepc-transition" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INVALID_PROFILE_ID, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INVALID_PROFILE_ID", "invalid-profile-id" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_CALL_ALREADY_PRESENT, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_CALL_ALREADY_PRESENT", "call-already-present" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INTERFACE_IN_USE, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INTERFACE_IN_USE", "interface-in-use" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IP_PDP_MISMATCH, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IP_PDP_MISMATCH", "ip-pdp-mismatch" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_DISALLOWED_ON_ROAMING, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_DISALLOWED_ON_ROAMING", "apn-disallowed-on-roaming" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_PARAMETER_CHANGE, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_PARAMETER_CHANGE", "apn-parameter-change" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INTERFACE_IN_USE_CONFIG_MATCH, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INTERFACE_IN_USE_CONFIG_MATCH", "interface-in-use-config-match" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_NULL_APN_DISALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_NULL_APN_DISALLOWED", "null-apn-disallowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_THERMAL_MITIGATION, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_THERMAL_MITIGATION", "thermal-mitigation" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_SUBS_ID_MISMATCH, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_SUBS_ID_MISMATCH", "subs-id-mismatch" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DATA_SETTINGS_DISABLED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DATA_SETTINGS_DISABLED", "data-settings-disabled" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DATA_ROAMING_SETTINGS_DISABLED, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DATA_ROAMING_SETTINGS_DISABLED", "data-roaming-settings-disabled" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_FORMAT_INVALID, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_FORMAT_INVALID", "apn-format-invalid" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DDS_CALL_ABORT, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DDS_CALL_ABORT", "dds-call-abort" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_VALIDATION_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_VALIDATION_FAILURE", "validation-failure" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_verbose_call_end_reason_internal_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsVerboseCallEndReasonInternal"),
                                      qmi_wds_verbose_call_end_reason_internal_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IS_ENUM__
const gchar *
qmi_wds_verbose_call_end_reason_internal_get_string (QmiWdsVerboseCallEndReasonInternal val)
{
    guint i;

    for (i = 0; qmi_wds_verbose_call_end_reason_internal_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_verbose_call_end_reason_internal_values[i].value)
            return qmi_wds_verbose_call_end_reason_internal_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IS_FLAGS__
gchar *
qmi_wds_verbose_call_end_reason_internal_build_string_from_mask (QmiWdsVerboseCallEndReasonInternal mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_verbose_call_end_reason_internal_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_verbose_call_end_reason_internal_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_verbose_call_end_reason_internal_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_verbose_call_end_reason_internal_values[i].value) {
            guint c;
            gulong number = qmi_wds_verbose_call_end_reason_internal_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_verbose_call_end_reason_internal_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IS_FLAGS__ */
static const GEnumValue qmi_wds_verbose_call_end_reason_cm_values[] = {
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_CDMA_LOCK, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_CDMA_LOCK", "cdma-lock" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_INTERCEPT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_INTERCEPT", "intercept" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_REORDER, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_REORDER", "reorder" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_RELEASE_SO_REJECT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_RELEASE_SO_REJECT", "release-so-reject" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_INCOMING_CALL, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_INCOMING_CALL", "incoming-call" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ALERT_STOP, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ALERT_STOP", "alert-stop" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACTIVATION, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACTIVATION", "activation" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_MAX_ACCESS_PROBES, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_MAX_ACCESS_PROBES", "max-access-probes" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_CCS_NOT_SUPPORTED_BY_BS, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_CCS_NOT_SUPPORTED_BY_BS", "ccs-not-supported-by-bs" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_RESPONSE_FROM_BS, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_RESPONSE_FROM_BS", "no-response-from-bs" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_REJECTED_BY_BS, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_REJECTED_BY_BS", "rejected-by-bs" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_INCOMPATIBLE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_INCOMPATIBLE", "incompatible" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ALREADY_IN_TC, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ALREADY_IN_TC", "already-in-tc" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_USER_CALL_ORIGINATED_DURING_GPS, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_USER_CALL_ORIGINATED_DURING_GPS", "user-call-originated-during-gps" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_USER_CALL_ORIGINATED_DURING_SMS, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_USER_CALL_ORIGINATED_DURING_SMS", "user-call-originated-during-sms" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_CDMA_SERVICE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_CDMA_SERVICE", "no-cdma-service" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_MC_ABORT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_MC_ABORT", "mc-abort" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_PSIST_NG, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_PSIST_NG", "psist-ng" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_UIM_NOT_PRESENT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_UIM_NOT_PRESENT", "uim-not-present" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_RETRY_ORDER, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_RETRY_ORDER", "retry-order" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_BLOCK, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_BLOCK", "access-block" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_BLOCK_ALL, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_BLOCK_ALL", "access-block-all" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_IS707B_MAX_ACCESS_PROBES, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_IS707B_MAX_ACCESS_PROBES", "is707b-max-access-probes" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_THERMAL_EMERGENCY, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_THERMAL_EMERGENCY", "thermal-emergency" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_CALL_ORIGINATION_THROTTLED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_CALL_ORIGINATION_THROTTLED", "call-origination-throttled" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_USER_CALL_ORIGINATED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_USER_CALL_ORIGINATED", "user-call-originated" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONFERENCE_FAILED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONFERENCE_FAILED", "conference-failed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_INCOMING_REJECTED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_INCOMING_REJECTED", "incoming-rejected" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_GATEWAY_SERVICE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_GATEWAY_SERVICE", "no-gateway-service" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_GPRS_CONTEXT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_GPRS_CONTEXT", "no-gprs-context" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ILLEGAL_MS, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ILLEGAL_MS", "illegal-ms" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ILLEGAL_ME, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ILLEGAL_ME", "illegal-me" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_GPRS_AND_NON_GPRS_SERVICES_NOT_ALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_GPRS_AND_NON_GPRS_SERVICES_NOT_ALLOWED", "gprs-and-non-gprs-services-not-allowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_GPRS_SERVICES_NOT_ALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_GPRS_SERVICES_NOT_ALLOWED", "gprs-services-not-allowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_MS_IDENTITY_NOT_DERIVED_BY_THE_NETWORK, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_MS_IDENTITY_NOT_DERIVED_BY_THE_NETWORK", "ms-identity-not-derived-by-the-network" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_IMPLICITLY_DETACHED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_IMPLICITLY_DETACHED", "implicitly-detached" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_PLMN_NOT_ALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_PLMN_NOT_ALLOWED", "plmn-not-allowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LA_NOT_ALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LA_NOT_ALLOWED", "la-not-allowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_GPRS_SERVICES_NOT_ALLOWED_IN_PLMN, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_GPRS_SERVICES_NOT_ALLOWED_IN_PLMN", "gprs-services-not-allowed-in-plmn" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_PDP_DUPLICATE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_PDP_DUPLICATE", "pdp-duplicate" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_UE_RAT_CHANGE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_UE_RAT_CHANGE", "ue-rat-change" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONGESTION, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONGESTION", "congestion" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_PDP_CONTEXT_ACTIVATED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_PDP_CONTEXT_ACTIVATED", "no-pdp-context-activated" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_CLASS_DSAC_REJECTION, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_CLASS_DSAC_REJECTION", "access-class-dsac-rejection" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_PDP_ACTIVATE_MAX_RETRY_FAILED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_PDP_ACTIVATE_MAX_RETRY_FAILED", "pdp-activate-max-retry-failed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_RAB_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_RAB_FAILURE", "rab-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_EPS_SERVICE_NOT_ALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_EPS_SERVICE_NOT_ALLOWED", "eps-service-not-allowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_TRACKING_AREA_NOT_ALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_TRACKING_AREA_NOT_ALLOWED", "tracking-area-not-allowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ROAMING_NOT_ALLOWED_IN_TRACKING_AREA, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ROAMING_NOT_ALLOWED_IN_TRACKING_AREA", "roaming-not-allowed-in-tracking-area" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_SUITABLE_CELLS_IN_TRACKING_AREA, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_SUITABLE_CELLS_IN_TRACKING_AREA", "no-suitable-cells-in-tracking-area" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_NOT_AUTHORIZED_CLOSED_SUBSCRIBER_GROUP, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_NOT_AUTHORIZED_CLOSED_SUBSCRIBER_GROUP", "not-authorized-closed-subscriber-group" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_UNKNOWN_EPS_BEARER_CONTEXT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_UNKNOWN_EPS_BEARER_CONTEXT", "esm-unknown-eps-bearer-context" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_DRB_RELEASED_AT_RRC, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_DRB_RELEASED_AT_RRC", "drb-released-at-rrc" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_NAS_SIGNAL_CONNECTION_RELEASED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_NAS_SIGNAL_CONNECTION_RELEASED", "nas-signal-connection-released" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_DETACHED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_DETACHED", "emm-detached" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_ATTACH_FAILED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_ATTACH_FAILED", "emm-attach-failed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_ATTACH_STARTED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_ATTACH_STARTED", "emm-attach-started" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED", "lte-nas-service-request-failed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_ACTIVE_DEDICATED_BEARER_REACTIVATED_BY_NW, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_ACTIVE_DEDICATED_BEARER_REACTIVATED_BY_NW", "esm-active-dedicated-bearer-reactivated-by-nw" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_LOWER_LAYER_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_LOWER_LAYER_FAILURE", "esm-lower-layer-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_SYNC_UP_WITH_NW, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_SYNC_UP_WITH_NW", "esm-sync-up-with-nw" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_NW_ACTIVATED_DEDICATED_BEARER_WITH_ID_OF_DEFAULT_BEARER, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_NW_ACTIVATED_DEDICATED_BEARER_WITH_ID_OF_DEFAULT_BEARER", "esm-nw-activated-dedicated-bearer-with-id-of-default-bearer" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_BAD_OTA_MESSAGE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_BAD_OTA_MESSAGE", "esm-bad-ota-message" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_DS_REJECTED_CALL, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_DS_REJECTED_CALL", "esm-ds-rejected-call" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_CONTEXT_TRANSFERRED_DUE_TO_IRAT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_CONTEXT_TRANSFERRED_DUE_TO_IRAT", "esm-context-transferred-due-to-irat" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_DS_EXPLICIT_DEACT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_DS_EXPLICIT_DEACT", "ds-explicit-deact" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_LOCAL_CAUSE_NONE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_LOCAL_CAUSE_NONE", "esm-local-cause-none" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED_NO_THROTTLE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED_NO_THROTTLE", "lte-nas-service-request-failed-no-throttle" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACL_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACL_FAILURE", "acl-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED_DS_DISALLOW, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED_DS_DISALLOW", "lte-nas-service-request-failed-ds-disallow" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_T3417_EXPIRED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_T3417_EXPIRED", "emm-t3417-expired" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_T3417_EXT_EXPIRED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_T3417_EXT_EXPIRED", "emm-t3417-ext-expired" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_TXN, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_TXN", "lrrc-ul-data-confirmation-failure-txn" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_HANDOVER, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_HANDOVER", "lrrc-ul-data-confirmation-failure-handover" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_CONN_REL, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_CONN_REL", "lrrc-ul-data-confirmation-failure-conn-rel" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_RLF, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_RLF", "lrrc-ul-data-confirmation-failure-rlf" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_CTRL_NOT_CONN, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_CTRL_NOT_CONN", "lrrc-ul-data-confirmation-failure-ctrl-not-conn" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE", "lrrc-connection-establishment-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ABORTED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ABORTED", "lrrc-connection-establishment-failure-aborted" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ACCESS_BARRED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ACCESS_BARRED", "lrrc-connection-establishment-failure-access-barred" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CELL_RESELECTION, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CELL_RESELECTION", "lrrc-connection-establishment-failure-cell-reselection" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CONFIG_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CONFIG_FAILURE", "lrrc-connection-establishment-failure-config-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_TIMER_EXPIRED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_TIMER_EXPIRED", "lrrc-connection-establishment-failure-timer-expired" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_LINK_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_LINK_FAILURE", "lrrc-connection-establishment-failure-link-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_NOT_CAMPED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_NOT_CAMPED", "lrrc-connection-establishment-failure-not-camped" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_SI_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_SI_FAILURE", "lrrc-connection-establishment-failure-si-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_REJECTED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_REJECTED", "lrrc-connection-establishment-failure-rejected" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_NORMAL, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_NORMAL", "lrrc-connection-release-normal" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_RLF, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_RLF", "lrrc-connection-release-rlf" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_CRE_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_CRE_FAILURE", "lrrc-connection-release-cre-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_OOS_DURING_CRE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_OOS_DURING_CRE", "lrrc-connection-release-oos-during-cre" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_ABORTED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_ABORTED", "lrrc-connection-release-aborted" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_SIB_READ_ERROR, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_SIB_READ_ERROR", "lrrc-connection-release-sib-read-error" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_DETACH_WITH_REATTACH_LTE_NW_DETACH, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_DETACH_WITH_REATTACH_LTE_NW_DETACH", "detach-with-reattach-lte-nw-detach" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_DETACH_WITHOUT_REATTACH_LTE_NW_DETACH, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_DETACH_WITHOUT_REATTACH_LTE_NW_DETACH", "detach-without-reattach-lte-nw-detach" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_PROC_TIMEOUT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_PROC_TIMEOUT", "esm-proc-timeout" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_MESSAGE_EXCEED_MAX_L2_LIMIT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_MESSAGE_EXCEED_MAX_L2_LIMIT", "message-exceed-max-l2-limit" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONNECTION_DENY_GENERAL_OR_BUSY, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONNECTION_DENY_GENERAL_OR_BUSY", "connection-deny-general-or-busy" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONNECTION_DENY_BILLING_OR_AUTHENTICATION_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONNECTION_DENY_BILLING_OR_AUTHENTICATION_FAILURE", "connection-deny-billing-or-authentication-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_CHANGE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_CHANGE", "hdr-change" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_EXIT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_EXIT", "hdr-exit" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_NO_SESSION, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_NO_SESSION", "hdr-no-session" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_ORIGINATION_DURING_GPS_FIX, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_ORIGINATION_DURING_GPS_FIX", "hdr-origination-during-gps-fix" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_CONNECTION_SETUP_TIMEOUT, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_CONNECTION_SETUP_TIMEOUT", "hdr-connection-setup-timeout" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_RELEASED_BY_CM, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_RELEASED_BY_CM", "hdr-released-by-cm" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_COLLOCATED_ACQUISITION_FAILED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_COLLOCATED_ACQUISITION_FAILED", "hdr-collocated-acquisition-failed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_OTASP_COMMIT_IN_PROGRESS, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_OTASP_COMMIT_IN_PROGRESS", "otasp-commit-in-progress" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_NO_HYBRID_SERVICE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_NO_HYBRID_SERVICE", "hdr-no-hybrid-service" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_NO_LOCK_GRANTED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_NO_LOCK_GRANTED", "hdr-no-lock-granted" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HOLD_OTHER_IN_PROGRESS, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HOLD_OTHER_IN_PROGRESS", "hold-other-in-progress" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_FADE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_FADE", "hdr-fade" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_ACCESS_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_ACCESS_FAILURE", "hdr-access-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_CLIENT_END, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_CLIENT_END", "client-end" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_SERVICE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_SERVICE", "no-service" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_FADE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_FADE", "fade" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_RELEASE_NORMAL, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_RELEASE_NORMAL", "release-normal" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_ATTEMPT_IN_PROGRESS, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_ATTEMPT_IN_PROGRESS", "access-attempt-in-progress" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_FAILURE", "access-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_REDIRECTION_OR_HANDOFF, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_REDIRECTION_OR_HANDOFF", "redirection-or-handoff" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_OFFLINE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_OFFLINE", "offline" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMERGENCY_MODE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMERGENCY_MODE", "emergency-mode" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_PHONE_IN_USE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_PHONE_IN_USE", "phone-in-use" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_INVALID_MODE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_INVALID_MODE", "invalid-mode" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_INVALID_SIM_STATE, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_INVALID_SIM_STATE", "invalid-sim-state" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_COLLOCATED_HDR, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_COLLOCATED_HDR", "no-collocated-hdr" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_CM_CALL_CONTROL_REJECTED, "QMI_WDS_VERBOSE_CALL_END_REASON_CM_CALL_CONTROL_REJECTED", "call-control-rejected" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_verbose_call_end_reason_cm_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsVerboseCallEndReasonCm"),
                                      qmi_wds_verbose_call_end_reason_cm_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_CM_IS_ENUM__
const gchar *
qmi_wds_verbose_call_end_reason_cm_get_string (QmiWdsVerboseCallEndReasonCm val)
{
    guint i;

    for (i = 0; qmi_wds_verbose_call_end_reason_cm_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_verbose_call_end_reason_cm_values[i].value)
            return qmi_wds_verbose_call_end_reason_cm_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_CM_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_CM_IS_FLAGS__
gchar *
qmi_wds_verbose_call_end_reason_cm_build_string_from_mask (QmiWdsVerboseCallEndReasonCm mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_verbose_call_end_reason_cm_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_verbose_call_end_reason_cm_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_verbose_call_end_reason_cm_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_verbose_call_end_reason_cm_values[i].value) {
            guint c;
            gulong number = qmi_wds_verbose_call_end_reason_cm_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_verbose_call_end_reason_cm_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_CM_IS_FLAGS__ */
static const GEnumValue qmi_wds_verbose_call_end_reason_3gpp_values[] = {
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPERATOR_DETERMINED_BARRING, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPERATOR_DETERMINED_BARRING", "operator-determined-barring" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_LLC_SNDCP_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_LLC_SNDCP_FAILURE", "llc-sndcp-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INSUFFICIENT_RESOURCES, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INSUFFICIENT_RESOURCES", "insufficient-resources" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_UNKNOWN_APN, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_UNKNOWN_APN", "unknown-apn" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_UNKNOWN_PDP, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_UNKNOWN_PDP", "unknown-pdp" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_AUTHENTICATION_FAILED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_AUTHENTICATION_FAILED", "authentication-failed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_GGSN_REJECT, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_GGSN_REJECT", "ggsn-reject" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_ACTIVATION_REJECT, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_ACTIVATION_REJECT", "activation-reject" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPTION_NOT_SUPPORTED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPTION_NOT_SUPPORTED", "option-not-supported" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPTION_UNSUBSCRIBED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPTION_UNSUBSCRIBED", "option-unsubscribed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPTION_TEMPORARILY_OUT_OF_ORDER, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPTION_TEMPORARILY_OUT_OF_ORDER", "option-temporarily-out-of-order" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_NSAPI_ALREADY_USED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_NSAPI_ALREADY_USED", "nsapi-already-used" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_REGULAR_DEACTIVATION, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_REGULAR_DEACTIVATION", "regular-deactivation" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_QOS_NOT_ACCEPTED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_QOS_NOT_ACCEPTED", "qos-not-accepted" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_NETWORK_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_NETWORK_FAILURE", "network-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_REATTACH_REQUIRED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_REATTACH_REQUIRED", "reattach-required" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_FEATURE_NOT_SUPPORTED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_FEATURE_NOT_SUPPORTED", "feature-not-supported" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_TFT_SEMANTIC_ERROR, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_TFT_SEMANTIC_ERROR", "tft-semantic-error" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_TFT_SYNTAX_ERROR, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_TFT_SYNTAX_ERROR", "tft-syntax-error" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_UNKNOWN_PDP_CONTEXT, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_UNKNOWN_PDP_CONTEXT", "unknown-pdp-context" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_FILTER_SEMANTIC_ERROR, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_FILTER_SEMANTIC_ERROR", "filter-semantic-error" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_FILTER_SYNTAX_ERROR, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_FILTER_SYNTAX_ERROR", "filter-syntax-error" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_PDP_WITHOUT_ACTIVE_TFT, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_PDP_WITHOUT_ACTIVE_TFT", "pdp-without-active-tft" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_IPV4_ONLY_ALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_IPV4_ONLY_ALLOWED", "ipv4-only-allowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_IPV6_ONLY_ALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_IPV6_ONLY_ALLOWED", "ipv6-only-allowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_SINGLE_ADDRESS_BEARER_ONLY, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_SINGLE_ADDRESS_BEARER_ONLY", "single-address-bearer-only" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_ESM_INFO_NOT_RECEIVED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_ESM_INFO_NOT_RECEIVED", "esm-info-not-received" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_PDN_CONNECTION_DOES_NOT_EXIST, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_PDN_CONNECTION_DOES_NOT_EXIST", "pdn-connection-does-not-exist" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MULTIPLE_CONNECTION_TO_SAME_PDN_NOT_ALLOWED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MULTIPLE_CONNECTION_TO_SAME_PDN_NOT_ALLOWED", "multiple-connection-to-same-pdn-not-allowed" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INVALID_TRANSACTION_ID, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INVALID_TRANSACTION_ID", "invalid-transaction-id" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_INCORRECT_SEMANTIC, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_INCORRECT_SEMANTIC", "message-incorrect-semantic" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INVALID_MANDATORY_INFO, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INVALID_MANDATORY_INFO", "invalid-mandatory-info" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_TYPE_UNSUPPORTED, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_TYPE_UNSUPPORTED", "message-type-unsupported" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_TYPE_NONCOMPATIBLE_STATE, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_TYPE_NONCOMPATIBLE_STATE", "message-type-noncompatible-state" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_UNKNOWN_INFO_ELEMENT, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_UNKNOWN_INFO_ELEMENT", "unknown-info-element" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_CONDITIONAL_IE_ERROR, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_CONDITIONAL_IE_ERROR", "conditional-ie-error" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_AND_PROTOCOL_STATE_UNCOMPATIBLE, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_AND_PROTOCOL_STATE_UNCOMPATIBLE", "message-and-protocol-state-uncompatible" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_PROTOCOL_ERROR, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_PROTOCOL_ERROR", "protocol-error" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_APN_TYPE_CONFLICT, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_APN_TYPE_CONFLICT", "apn-type-conflict" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INVALID_PROXY_CALL_SESSION_CONTROL_FUNCTION_ADDRESS, "QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INVALID_PROXY_CALL_SESSION_CONTROL_FUNCTION_ADDRESS", "invalid-proxy-call-session-control-function-address" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_verbose_call_end_reason_3gpp_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsVerboseCallEndReason3gpp"),
                                      qmi_wds_verbose_call_end_reason_3gpp_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_IS_ENUM__
const gchar *
qmi_wds_verbose_call_end_reason_3gpp_get_string (QmiWdsVerboseCallEndReason3gpp val)
{
    guint i;

    for (i = 0; qmi_wds_verbose_call_end_reason_3gpp_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_verbose_call_end_reason_3gpp_values[i].value)
            return qmi_wds_verbose_call_end_reason_3gpp_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_IS_FLAGS__
gchar *
qmi_wds_verbose_call_end_reason_3gpp_build_string_from_mask (QmiWdsVerboseCallEndReason3gpp mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_verbose_call_end_reason_3gpp_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_verbose_call_end_reason_3gpp_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_verbose_call_end_reason_3gpp_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_verbose_call_end_reason_3gpp_values[i].value) {
            guint c;
            gulong number = qmi_wds_verbose_call_end_reason_3gpp_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_verbose_call_end_reason_3gpp_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_IS_FLAGS__ */
static const GEnumValue qmi_wds_verbose_call_end_reason_ppp_values[] = {
    { QMI_WDS_VERBOSE_CALL_END_REASON_PPP_UNKNOWN, "QMI_WDS_VERBOSE_CALL_END_REASON_PPP_UNKNOWN", "unknown" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_PPP_TIMEOUT, "QMI_WDS_VERBOSE_CALL_END_REASON_PPP_TIMEOUT", "timeout" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_PPP_AUTHENTICATION_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_PPP_AUTHENTICATION_FAILURE", "authentication-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_PPP_OPTION_MISMATCH, "QMI_WDS_VERBOSE_CALL_END_REASON_PPP_OPTION_MISMATCH", "option-mismatch" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_PPP_PAP_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_PPP_PAP_FAILURE", "pap-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_PPP_CHAP_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_PPP_CHAP_FAILURE", "chap-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_PPP_CLOSE_IN_PROGRESS, "QMI_WDS_VERBOSE_CALL_END_REASON_PPP_CLOSE_IN_PROGRESS", "close-in-progress" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_verbose_call_end_reason_ppp_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsVerboseCallEndReasonPpp"),
                                      qmi_wds_verbose_call_end_reason_ppp_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_PPP_IS_ENUM__
const gchar *
qmi_wds_verbose_call_end_reason_ppp_get_string (QmiWdsVerboseCallEndReasonPpp val)
{
    guint i;

    for (i = 0; qmi_wds_verbose_call_end_reason_ppp_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_verbose_call_end_reason_ppp_values[i].value)
            return qmi_wds_verbose_call_end_reason_ppp_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_PPP_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_PPP_IS_FLAGS__
gchar *
qmi_wds_verbose_call_end_reason_ppp_build_string_from_mask (QmiWdsVerboseCallEndReasonPpp mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_verbose_call_end_reason_ppp_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_verbose_call_end_reason_ppp_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_verbose_call_end_reason_ppp_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_verbose_call_end_reason_ppp_values[i].value) {
            guint c;
            gulong number = qmi_wds_verbose_call_end_reason_ppp_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_verbose_call_end_reason_ppp_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_PPP_IS_FLAGS__ */
static const GEnumValue qmi_wds_verbose_call_end_reason_ehrpd_values[] = {
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_SUBSCRIPTION_LIMITED_TO_IPV4, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_SUBSCRIPTION_LIMITED_TO_IPV4", "subscription-limited-to-ipv4" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_SUBSCRIPTION_LIMITED_TO_IPV6, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_SUBSCRIPTION_LIMITED_TO_IPV6", "subscription-limited-to-ipv6" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_TIMEOUT, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_TIMEOUT", "vsncp-timeout" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_FAILURE, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_FAILURE", "vsncp-failure" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_GENERAL_ERROR, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_GENERAL_ERROR", "vsncp-3gpp2-general-error" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_UNAUTHENTICATED_APN, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_UNAUTHENTICATED_APN", "vsncp-3gpp2-unauthenticated-apn" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_PDN_LIMIT_EXCEEDED, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_PDN_LIMIT_EXCEEDED", "vsncp-3gpp2-pdn-limit-exceeded" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_NO_PDN_GATEWAY, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_NO_PDN_GATEWAY", "vsncp-3gpp2-no-pdn-gateway" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_PDN_GATEWAY_UNREACHABLE, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_PDN_GATEWAY_UNREACHABLE", "vsncp-3gpp2-pdn-gateway-unreachable" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_PDN_GATEWAY_REJECTED, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_PDN_GATEWAY_REJECTED", "vsncp-3gpp2-pdn-gateway-rejected" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_INSUFFICIENT_PARAMETERS, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_INSUFFICIENT_PARAMETERS", "vsncp-3gpp2-insufficient-parameters" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_RESOURCE_UNAVAILABLE, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_RESOURCE_UNAVAILABLE", "vsncp-3gpp2-resource-unavailable" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_ADMINISTRATIVELY_PROHIBITED, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_ADMINISTRATIVELY_PROHIBITED", "vsncp-3gpp2-administratively-prohibited" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_PDN_ID_IN_USE, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_PDN_ID_IN_USE", "vsncp-3gpp2-pdn-id-in-use" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_SUBSCRIPTION_LIMITATION, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_SUBSCRIPTION_LIMITATION", "vsncp-3gpp2-subscription-limitation" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_PDN_EXISTS_FOR_THIS_APN, "QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_VSNCP_3GPP2_PDN_EXISTS_FOR_THIS_APN", "vsncp-3gpp2-pdn-exists-for-this-apn" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_verbose_call_end_reason_ehrpd_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsVerboseCallEndReasonEhrpd"),
                                      qmi_wds_verbose_call_end_reason_ehrpd_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_IS_ENUM__
const gchar *
qmi_wds_verbose_call_end_reason_ehrpd_get_string (QmiWdsVerboseCallEndReasonEhrpd val)
{
    guint i;

    for (i = 0; qmi_wds_verbose_call_end_reason_ehrpd_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_verbose_call_end_reason_ehrpd_values[i].value)
            return qmi_wds_verbose_call_end_reason_ehrpd_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_IS_FLAGS__
gchar *
qmi_wds_verbose_call_end_reason_ehrpd_build_string_from_mask (QmiWdsVerboseCallEndReasonEhrpd mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_verbose_call_end_reason_ehrpd_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_verbose_call_end_reason_ehrpd_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_verbose_call_end_reason_ehrpd_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_verbose_call_end_reason_ehrpd_values[i].value) {
            guint c;
            gulong number = qmi_wds_verbose_call_end_reason_ehrpd_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_verbose_call_end_reason_ehrpd_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_IS_FLAGS__ */
static const GEnumValue qmi_wds_verbose_call_end_reason_ipv6_values[] = {
    { QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_PREFIX_UNAVAILABLE, "QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_PREFIX_UNAVAILABLE", "prefix-unavailable" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_HRPD_IPV6_DISABLED, "QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_HRPD_IPV6_DISABLED", "hrpd-ipv6-disabled" },
    { QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_DISABLED, "QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_DISABLED", "disabled" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_verbose_call_end_reason_ipv6_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsVerboseCallEndReasonIpv6"),
                                      qmi_wds_verbose_call_end_reason_ipv6_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_IS_ENUM__
const gchar *
qmi_wds_verbose_call_end_reason_ipv6_get_string (QmiWdsVerboseCallEndReasonIpv6 val)
{
    guint i;

    for (i = 0; qmi_wds_verbose_call_end_reason_ipv6_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_verbose_call_end_reason_ipv6_values[i].value)
            return qmi_wds_verbose_call_end_reason_ipv6_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_IS_FLAGS__
gchar *
qmi_wds_verbose_call_end_reason_ipv6_build_string_from_mask (QmiWdsVerboseCallEndReasonIpv6 mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_verbose_call_end_reason_ipv6_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_verbose_call_end_reason_ipv6_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_verbose_call_end_reason_ipv6_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_verbose_call_end_reason_ipv6_values[i].value) {
            guint c;
            gulong number = qmi_wds_verbose_call_end_reason_ipv6_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_verbose_call_end_reason_ipv6_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_IS_FLAGS__ */
static const GEnumValue qmi_wds_connection_status_values[] = {
    { QMI_WDS_CONNECTION_STATUS_UNKNOWN, "QMI_WDS_CONNECTION_STATUS_UNKNOWN", "unknown" },
    { QMI_WDS_CONNECTION_STATUS_DISCONNECTED, "QMI_WDS_CONNECTION_STATUS_DISCONNECTED", "disconnected" },
    { QMI_WDS_CONNECTION_STATUS_CONNECTED, "QMI_WDS_CONNECTION_STATUS_CONNECTED", "connected" },
    { QMI_WDS_CONNECTION_STATUS_SUSPENDED, "QMI_WDS_CONNECTION_STATUS_SUSPENDED", "suspended" },
    { QMI_WDS_CONNECTION_STATUS_AUTHENTICATING, "QMI_WDS_CONNECTION_STATUS_AUTHENTICATING", "authenticating" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_connection_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsConnectionStatus"),
                                      qmi_wds_connection_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_CONNECTION_STATUS_IS_ENUM__
const gchar *
qmi_wds_connection_status_get_string (QmiWdsConnectionStatus val)
{
    guint i;

    for (i = 0; qmi_wds_connection_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_connection_status_values[i].value)
            return qmi_wds_connection_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_CONNECTION_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_CONNECTION_STATUS_IS_FLAGS__
gchar *
qmi_wds_connection_status_build_string_from_mask (QmiWdsConnectionStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_connection_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_connection_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_connection_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_connection_status_values[i].value) {
            guint c;
            gulong number = qmi_wds_connection_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_connection_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_CONNECTION_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_wds_data_bearer_technology_values[] = {
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_UNKNOWN, "QMI_WDS_DATA_BEARER_TECHNOLOGY_UNKNOWN", "unknown" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_CDMA20001X, "QMI_WDS_DATA_BEARER_TECHNOLOGY_CDMA20001X", "cdma20001x" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_1xEVDO, "QMI_WDS_DATA_BEARER_TECHNOLOGY_1xEVDO", "1xevdo" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_GSM, "QMI_WDS_DATA_BEARER_TECHNOLOGY_GSM", "gsm" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_UMTS, "QMI_WDS_DATA_BEARER_TECHNOLOGY_UMTS", "umts" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_1xEVDO_REVA, "QMI_WDS_DATA_BEARER_TECHNOLOGY_1xEVDO_REVA", "1xevdo-reva" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_EDGE, "QMI_WDS_DATA_BEARER_TECHNOLOGY_EDGE", "edge" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPA, "QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPA", "hsdpa" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_HSUPA, "QMI_WDS_DATA_BEARER_TECHNOLOGY_HSUPA", "hsupa" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPA_HSUPDA, "QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPA_HSUPDA", "hsdpa-hsupda" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_LTE, "QMI_WDS_DATA_BEARER_TECHNOLOGY_LTE", "lte" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_EHRPD, "QMI_WDS_DATA_BEARER_TECHNOLOGY_EHRPD", "ehrpd" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS, "QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS", "hsdpaplus" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS_HSUPA, "QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS_HSUPA", "hsdpaplus-hsupa" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_DCHSDPAPLUS, "QMI_WDS_DATA_BEARER_TECHNOLOGY_DCHSDPAPLUS", "dchsdpaplus" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_DCHSDPAPLUS_HSUPA, "QMI_WDS_DATA_BEARER_TECHNOLOGY_DCHSDPAPLUS_HSUPA", "dchsdpaplus-hsupa" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS_PLUS_64QAM, "QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS_PLUS_64QAM", "hsdpaplus-plus-64qam" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS_PLUS_64QAM_HSUPA, "QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS_PLUS_64QAM_HSUPA", "hsdpaplus-plus-64qam-hsupa" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA, "QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA", "tdscdma" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA_HSDPA, "QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA_HSDPA", "tdscdma-hsdpa" },
    { QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA_HSUPA, "QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA_HSUPA", "tdscdma-hsupa" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_data_bearer_technology_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsDataBearerTechnology"),
                                      qmi_wds_data_bearer_technology_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_DATA_BEARER_TECHNOLOGY_IS_ENUM__
const gchar *
qmi_wds_data_bearer_technology_get_string (QmiWdsDataBearerTechnology val)
{
    guint i;

    for (i = 0; qmi_wds_data_bearer_technology_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_data_bearer_technology_values[i].value)
            return qmi_wds_data_bearer_technology_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_DATA_BEARER_TECHNOLOGY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_DATA_BEARER_TECHNOLOGY_IS_FLAGS__
gchar *
qmi_wds_data_bearer_technology_build_string_from_mask (QmiWdsDataBearerTechnology mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_data_bearer_technology_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_data_bearer_technology_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_data_bearer_technology_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_data_bearer_technology_values[i].value) {
            guint c;
            gulong number = qmi_wds_data_bearer_technology_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_data_bearer_technology_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_DATA_BEARER_TECHNOLOGY_IS_FLAGS__ */
static const GEnumValue qmi_wds_network_type_values[] = {
    { QMI_WDS_NETWORK_TYPE_UNKNOWN, "QMI_WDS_NETWORK_TYPE_UNKNOWN", "unknown" },
    { QMI_WDS_NETWORK_TYPE_3GPP2, "QMI_WDS_NETWORK_TYPE_3GPP2", "3gpp2" },
    { QMI_WDS_NETWORK_TYPE_3GPP, "QMI_WDS_NETWORK_TYPE_3GPP", "3gpp" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_network_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsNetworkType"),
                                      qmi_wds_network_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_NETWORK_TYPE_IS_ENUM__
const gchar *
qmi_wds_network_type_get_string (QmiWdsNetworkType val)
{
    guint i;

    for (i = 0; qmi_wds_network_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_network_type_values[i].value)
            return qmi_wds_network_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_NETWORK_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_NETWORK_TYPE_IS_FLAGS__
gchar *
qmi_wds_network_type_build_string_from_mask (QmiWdsNetworkType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_network_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_network_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_network_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_network_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_network_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_network_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_NETWORK_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wds_data_system_network_type_values[] = {
    { QMI_WDS_DATA_SYSTEM_NETWORK_TYPE_3GPP, "QMI_WDS_DATA_SYSTEM_NETWORK_TYPE_3GPP", "3gpp" },
    { QMI_WDS_DATA_SYSTEM_NETWORK_TYPE_3GPP2, "QMI_WDS_DATA_SYSTEM_NETWORK_TYPE_3GPP2", "3gpp2" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_data_system_network_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsDataSystemNetworkType"),
                                      qmi_wds_data_system_network_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_DATA_SYSTEM_NETWORK_TYPE_IS_ENUM__
const gchar *
qmi_wds_data_system_network_type_get_string (QmiWdsDataSystemNetworkType val)
{
    guint i;

    for (i = 0; qmi_wds_data_system_network_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_data_system_network_type_values[i].value)
            return qmi_wds_data_system_network_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_DATA_SYSTEM_NETWORK_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_DATA_SYSTEM_NETWORK_TYPE_IS_FLAGS__
gchar *
qmi_wds_data_system_network_type_build_string_from_mask (QmiWdsDataSystemNetworkType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_data_system_network_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_data_system_network_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_data_system_network_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_data_system_network_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_data_system_network_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_data_system_network_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_DATA_SYSTEM_NETWORK_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wds_data_system_values[] = {
    { QMI_WDS_DATA_SYSTEM_UNKNOWN, "QMI_WDS_DATA_SYSTEM_UNKNOWN", "unknown" },
    { QMI_WDS_DATA_SYSTEM_CDMA1X, "QMI_WDS_DATA_SYSTEM_CDMA1X", "cdma1x" },
    { QMI_WDS_DATA_SYSTEM_CDMA1X_EVDO, "QMI_WDS_DATA_SYSTEM_CDMA1X_EVDO", "cdma1x-evdo" },
    { QMI_WDS_DATA_SYSTEM_GPRS, "QMI_WDS_DATA_SYSTEM_GPRS", "gprs" },
    { QMI_WDS_DATA_SYSTEM_WCDMA, "QMI_WDS_DATA_SYSTEM_WCDMA", "wcdma" },
    { QMI_WDS_DATA_SYSTEM_LTE, "QMI_WDS_DATA_SYSTEM_LTE", "lte" },
    { QMI_WDS_DATA_SYSTEM_TDSCDMA, "QMI_WDS_DATA_SYSTEM_TDSCDMA", "tdscdma" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_data_system_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsDataSystem"),
                                      qmi_wds_data_system_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_DATA_SYSTEM_IS_ENUM__
const gchar *
qmi_wds_data_system_get_string (QmiWdsDataSystem val)
{
    guint i;

    for (i = 0; qmi_wds_data_system_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_data_system_values[i].value)
            return qmi_wds_data_system_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_DATA_SYSTEM_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_DATA_SYSTEM_IS_FLAGS__
gchar *
qmi_wds_data_system_build_string_from_mask (QmiWdsDataSystem mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_data_system_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_data_system_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_data_system_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_data_system_values[i].value) {
            guint c;
            gulong number = qmi_wds_data_system_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_data_system_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_DATA_SYSTEM_IS_FLAGS__ */
static const GFlagsValue qmi_wds_rat_3gpp2_values[] = {
    { QMI_WDS_RAT_3GPP2_NONE, "QMI_WDS_RAT_3GPP2_NONE", "none" },
    { QMI_WDS_RAT_3GPP2_CDMA1X, "QMI_WDS_RAT_3GPP2_CDMA1X", "cdma1x" },
    { QMI_WDS_RAT_3GPP2_EVDO_REV0, "QMI_WDS_RAT_3GPP2_EVDO_REV0", "evdo-rev0" },
    { QMI_WDS_RAT_3GPP2_EVDO_REVA, "QMI_WDS_RAT_3GPP2_EVDO_REVA", "evdo-reva" },
    { QMI_WDS_RAT_3GPP2_EVDO_REVB, "QMI_WDS_RAT_3GPP2_EVDO_REVB", "evdo-revb" },
    { QMI_WDS_RAT_3GPP2_EHRPD, "QMI_WDS_RAT_3GPP2_EHRPD", "ehrpd" },
    { QMI_WDS_RAT_3GPP2_FMC, "QMI_WDS_RAT_3GPP2_FMC", "fmc" },
    { QMI_WDS_RAT_3GPP2_NULL_BEARER, "QMI_WDS_RAT_3GPP2_NULL_BEARER", "null-bearer" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_rat_3gpp2_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsRat3gpp2"),
                                      qmi_wds_rat_3gpp2_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_RAT_3GPP2_IS_ENUM__
const gchar *
qmi_wds_rat_3gpp2_get_string (QmiWdsRat3gpp2 val)
{
    guint i;

    for (i = 0; qmi_wds_rat_3gpp2_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_rat_3gpp2_values[i].value)
            return qmi_wds_rat_3gpp2_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_RAT_3GPP2_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_RAT_3GPP2_IS_FLAGS__
gchar *
qmi_wds_rat_3gpp2_build_string_from_mask (QmiWdsRat3gpp2 mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_rat_3gpp2_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_rat_3gpp2_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_rat_3gpp2_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_rat_3gpp2_values[i].value) {
            guint c;
            gulong number = qmi_wds_rat_3gpp2_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_rat_3gpp2_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_RAT_3GPP2_IS_FLAGS__ */
static const GFlagsValue qmi_wds_rat_3gpp_values[] = {
    { QMI_WDS_RAT_3GPP_NONE, "QMI_WDS_RAT_3GPP_NONE", "none" },
    { QMI_WDS_RAT_3GPP_WCDMA, "QMI_WDS_RAT_3GPP_WCDMA", "wcdma" },
    { QMI_WDS_RAT_3GPP_GPRS, "QMI_WDS_RAT_3GPP_GPRS", "gprs" },
    { QMI_WDS_RAT_3GPP_HSDPA, "QMI_WDS_RAT_3GPP_HSDPA", "hsdpa" },
    { QMI_WDS_RAT_3GPP_HSUPA, "QMI_WDS_RAT_3GPP_HSUPA", "hsupa" },
    { QMI_WDS_RAT_3GPP_EDGE, "QMI_WDS_RAT_3GPP_EDGE", "edge" },
    { QMI_WDS_RAT_3GPP_LTE, "QMI_WDS_RAT_3GPP_LTE", "lte" },
    { QMI_WDS_RAT_3GPP_HSDPAPLUS, "QMI_WDS_RAT_3GPP_HSDPAPLUS", "hsdpaplus" },
    { QMI_WDS_RAT_3GPP_DCHSDPAPLUS, "QMI_WDS_RAT_3GPP_DCHSDPAPLUS", "dchsdpaplus" },
    { QMI_WDS_RAT_3GPP_64QAM, "QMI_WDS_RAT_3GPP_64QAM", "64qam" },
    { QMI_WDS_RAT_3GPP_TDSCDMA, "QMI_WDS_RAT_3GPP_TDSCDMA", "tdscdma" },
    { QMI_WDS_RAT_3GPP_NULL_BEARER, "QMI_WDS_RAT_3GPP_NULL_BEARER", "null-bearer" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_rat_3gpp_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsRat3gpp"),
                                      qmi_wds_rat_3gpp_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_RAT_3GPP_IS_ENUM__
const gchar *
qmi_wds_rat_3gpp_get_string (QmiWdsRat3gpp val)
{
    guint i;

    for (i = 0; qmi_wds_rat_3gpp_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_rat_3gpp_values[i].value)
            return qmi_wds_rat_3gpp_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_RAT_3GPP_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_RAT_3GPP_IS_FLAGS__
gchar *
qmi_wds_rat_3gpp_build_string_from_mask (QmiWdsRat3gpp mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_rat_3gpp_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_rat_3gpp_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_rat_3gpp_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_rat_3gpp_values[i].value) {
            guint c;
            gulong number = qmi_wds_rat_3gpp_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_rat_3gpp_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_RAT_3GPP_IS_FLAGS__ */
static const GFlagsValue qmi_wds_so_cdma1x_values[] = {
    { QMI_WDS_SO_CDMA1X_NONE, "QMI_WDS_SO_CDMA1X_NONE", "none" },
    { QMI_WDS_SO_CDMA1X_IS95, "QMI_WDS_SO_CDMA1X_IS95", "is95" },
    { QMI_WDS_SO_CDMA1X_IS2000, "QMI_WDS_SO_CDMA1X_IS2000", "is2000" },
    { QMI_WDS_SO_CDMA1X_IS2000_REL_A, "QMI_WDS_SO_CDMA1X_IS2000_REL_A", "is2000-rel-a" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_so_cdma1x_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsSoCdma1x"),
                                      qmi_wds_so_cdma1x_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_SO_CDMA1X_IS_ENUM__
const gchar *
qmi_wds_so_cdma1x_get_string (QmiWdsSoCdma1x val)
{
    guint i;

    for (i = 0; qmi_wds_so_cdma1x_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_so_cdma1x_values[i].value)
            return qmi_wds_so_cdma1x_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_SO_CDMA1X_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_SO_CDMA1X_IS_FLAGS__
gchar *
qmi_wds_so_cdma1x_build_string_from_mask (QmiWdsSoCdma1x mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_so_cdma1x_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_so_cdma1x_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_so_cdma1x_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_so_cdma1x_values[i].value) {
            guint c;
            gulong number = qmi_wds_so_cdma1x_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_so_cdma1x_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_SO_CDMA1X_IS_FLAGS__ */
static const GFlagsValue qmi_wds_so_evdo_rev0_values[] = {
    { QMI_WDS_SO_EVDO_REV0_NONE, "QMI_WDS_SO_EVDO_REV0_NONE", "none" },
    { QMI_WDS_SO_EVDO_REV0_DPA, "QMI_WDS_SO_EVDO_REV0_DPA", "dpa" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_so_evdo_rev0_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsSoEvdoRev0"),
                                      qmi_wds_so_evdo_rev0_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_SO_EVDO_REV0_IS_ENUM__
const gchar *
qmi_wds_so_evdo_rev0_get_string (QmiWdsSoEvdoRev0 val)
{
    guint i;

    for (i = 0; qmi_wds_so_evdo_rev0_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_so_evdo_rev0_values[i].value)
            return qmi_wds_so_evdo_rev0_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_SO_EVDO_REV0_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_SO_EVDO_REV0_IS_FLAGS__
gchar *
qmi_wds_so_evdo_rev0_build_string_from_mask (QmiWdsSoEvdoRev0 mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_so_evdo_rev0_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_so_evdo_rev0_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_so_evdo_rev0_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_so_evdo_rev0_values[i].value) {
            guint c;
            gulong number = qmi_wds_so_evdo_rev0_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_so_evdo_rev0_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_SO_EVDO_REV0_IS_FLAGS__ */
static const GFlagsValue qmi_wds_so_evdo_reva_values[] = {
    { QMI_WDS_SO_EVDO_REVA_NONE, "QMI_WDS_SO_EVDO_REVA_NONE", "none" },
    { QMI_WDS_SO_EVDO_REVA_DPA, "QMI_WDS_SO_EVDO_REVA_DPA", "dpa" },
    { QMI_WDS_SO_EVDO_REVA_MFPA, "QMI_WDS_SO_EVDO_REVA_MFPA", "mfpa" },
    { QMI_WDS_SO_EVDO_REVA_EMPA, "QMI_WDS_SO_EVDO_REVA_EMPA", "empa" },
    { QMI_WDS_SO_EVDO_REVA_EMPA_EHRPD, "QMI_WDS_SO_EVDO_REVA_EMPA_EHRPD", "empa-ehrpd" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_so_evdo_reva_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsSoEvdoRevA"),
                                      qmi_wds_so_evdo_reva_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_SO_EVDO_REVA_IS_ENUM__
const gchar *
qmi_wds_so_evdo_reva_get_string (QmiWdsSoEvdoRevA val)
{
    guint i;

    for (i = 0; qmi_wds_so_evdo_reva_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_so_evdo_reva_values[i].value)
            return qmi_wds_so_evdo_reva_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_SO_EVDO_REVA_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_SO_EVDO_REVA_IS_FLAGS__
gchar *
qmi_wds_so_evdo_reva_build_string_from_mask (QmiWdsSoEvdoRevA mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_so_evdo_reva_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_so_evdo_reva_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_so_evdo_reva_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_so_evdo_reva_values[i].value) {
            guint c;
            gulong number = qmi_wds_so_evdo_reva_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_so_evdo_reva_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_SO_EVDO_REVA_IS_FLAGS__ */
static const GFlagsValue qmi_wds_so_evdo_revb_values[] = {
    { QMI_WDS_SO_EVDO_REVB_NONE, "QMI_WDS_SO_EVDO_REVB_NONE", "none" },
    { QMI_WDS_SO_EVDO_REVB_DPA, "QMI_WDS_SO_EVDO_REVB_DPA", "dpa" },
    { QMI_WDS_SO_EVDO_REVB_MFPA, "QMI_WDS_SO_EVDO_REVB_MFPA", "mfpa" },
    { QMI_WDS_SO_EVDO_REVB_EMPA, "QMI_WDS_SO_EVDO_REVB_EMPA", "empa" },
    { QMI_WDS_SO_EVDO_REVB_EMPA_EHRPD, "QMI_WDS_SO_EVDO_REVB_EMPA_EHRPD", "empa-ehrpd" },
    { QMI_WDS_SO_EVDO_REVB_MMPA, "QMI_WDS_SO_EVDO_REVB_MMPA", "mmpa" },
    { QMI_WDS_SO_EVDO_REVB_MMPA_EHRPD, "QMI_WDS_SO_EVDO_REVB_MMPA_EHRPD", "mmpa-ehrpd" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_so_evdo_revb_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsSoEvdoRevB"),
                                      qmi_wds_so_evdo_revb_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_SO_EVDO_REVB_IS_ENUM__
const gchar *
qmi_wds_so_evdo_revb_get_string (QmiWdsSoEvdoRevB val)
{
    guint i;

    for (i = 0; qmi_wds_so_evdo_revb_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_so_evdo_revb_values[i].value)
            return qmi_wds_so_evdo_revb_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_SO_EVDO_REVB_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_SO_EVDO_REVB_IS_FLAGS__
gchar *
qmi_wds_so_evdo_revb_build_string_from_mask (QmiWdsSoEvdoRevB mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_so_evdo_revb_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_so_evdo_revb_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_so_evdo_revb_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_so_evdo_revb_values[i].value) {
            guint c;
            gulong number = qmi_wds_so_evdo_revb_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_so_evdo_revb_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_SO_EVDO_REVB_IS_FLAGS__ */
static const GFlagsValue qmi_wds_get_current_settings_requested_settings_values[] = {
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_NONE, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_NONE", "none" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PROFILE_ID, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PROFILE_ID", "profile-id" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PROFILE_NAME, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PROFILE_NAME", "profile-name" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PDP_TYPE, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PDP_TYPE", "pdp-type" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_APN_NAME, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_APN_NAME", "apn-name" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_DNS_ADDRESS, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_DNS_ADDRESS", "dns-address" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_GRANTED_QOS, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_GRANTED_QOS", "granted-qos" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_USERNAME, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_USERNAME", "username" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_AUTH_PROTOCOL, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_AUTH_PROTOCOL", "auth-protocol" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IP_ADDRESS, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IP_ADDRESS", "ip-address" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_GATEWAY_INFO, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_GATEWAY_INFO", "gateway-info" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PCSCF_ADDRESS, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PCSCF_ADDRESS", "pcscf-address" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PCSCF_SERVER_ADDRESS_LIST, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PCSCF_SERVER_ADDRESS_LIST", "pcscf-server-address-list" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PCSCF_DOMAIN_NAME_LIST, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PCSCF_DOMAIN_NAME_LIST", "pcscf-domain-name-list" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_MTU, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_MTU", "mtu" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_DOMAIN_NAME_LIST, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_DOMAIN_NAME_LIST", "domain-name-list" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IP_FAMILY, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IP_FAMILY", "ip-family" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IMCN_FLAG, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IMCN_FLAG", "imcn-flag" },
    { QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_EXTENDED_TECHNOLOGY, "QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_EXTENDED_TECHNOLOGY", "extended-technology" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_get_current_settings_requested_settings_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsGetCurrentSettingsRequestedSettings"),
                                      qmi_wds_get_current_settings_requested_settings_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IS_ENUM__
const gchar *
qmi_wds_get_current_settings_requested_settings_get_string (QmiWdsGetCurrentSettingsRequestedSettings val)
{
    guint i;

    for (i = 0; qmi_wds_get_current_settings_requested_settings_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_get_current_settings_requested_settings_values[i].value)
            return qmi_wds_get_current_settings_requested_settings_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IS_FLAGS__
gchar *
qmi_wds_get_current_settings_requested_settings_build_string_from_mask (QmiWdsGetCurrentSettingsRequestedSettings mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_get_current_settings_requested_settings_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_get_current_settings_requested_settings_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_get_current_settings_requested_settings_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_get_current_settings_requested_settings_values[i].value) {
            guint c;
            gulong number = qmi_wds_get_current_settings_requested_settings_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_get_current_settings_requested_settings_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IS_FLAGS__ */
static const GEnumValue qmi_wds_pdp_type_values[] = {
    { QMI_WDS_PDP_TYPE_IPV4, "QMI_WDS_PDP_TYPE_IPV4", "ipv4" },
    { QMI_WDS_PDP_TYPE_PPP, "QMI_WDS_PDP_TYPE_PPP", "ppp" },
    { QMI_WDS_PDP_TYPE_IPV6, "QMI_WDS_PDP_TYPE_IPV6", "ipv6" },
    { QMI_WDS_PDP_TYPE_IPV4_OR_IPV6, "QMI_WDS_PDP_TYPE_IPV4_OR_IPV6", "ipv4-or-ipv6" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_pdp_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsPdpType"),
                                      qmi_wds_pdp_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_PDP_TYPE_IS_ENUM__
const gchar *
qmi_wds_pdp_type_get_string (QmiWdsPdpType val)
{
    guint i;

    for (i = 0; qmi_wds_pdp_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_pdp_type_values[i].value)
            return qmi_wds_pdp_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_PDP_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_PDP_TYPE_IS_FLAGS__
gchar *
qmi_wds_pdp_type_build_string_from_mask (QmiWdsPdpType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_pdp_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_pdp_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_pdp_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_pdp_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_pdp_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_pdp_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_PDP_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wds_traffic_class_values[] = {
    { QMI_WDS_TRAFFIC_CLASS_SUBSCRIBED, "QMI_WDS_TRAFFIC_CLASS_SUBSCRIBED", "subscribed" },
    { QMI_WDS_TRAFFIC_CLASS_CONVERSATIONAL, "QMI_WDS_TRAFFIC_CLASS_CONVERSATIONAL", "conversational" },
    { QMI_WDS_TRAFFIC_CLASS_STREAMING, "QMI_WDS_TRAFFIC_CLASS_STREAMING", "streaming" },
    { QMI_WDS_TRAFFIC_CLASS_INTERACTIVE, "QMI_WDS_TRAFFIC_CLASS_INTERACTIVE", "interactive" },
    { QMI_WDS_TRAFFIC_CLASS_BACKGROUND, "QMI_WDS_TRAFFIC_CLASS_BACKGROUND", "background" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_traffic_class_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsTrafficClass"),
                                      qmi_wds_traffic_class_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_TRAFFIC_CLASS_IS_ENUM__
const gchar *
qmi_wds_traffic_class_get_string (QmiWdsTrafficClass val)
{
    guint i;

    for (i = 0; qmi_wds_traffic_class_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_traffic_class_values[i].value)
            return qmi_wds_traffic_class_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_TRAFFIC_CLASS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_TRAFFIC_CLASS_IS_FLAGS__
gchar *
qmi_wds_traffic_class_build_string_from_mask (QmiWdsTrafficClass mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_traffic_class_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_traffic_class_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_traffic_class_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_traffic_class_values[i].value) {
            guint c;
            gulong number = qmi_wds_traffic_class_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_traffic_class_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_TRAFFIC_CLASS_IS_FLAGS__ */
static const GFlagsValue qmi_wds_authentication_values[] = {
    { QMI_WDS_AUTHENTICATION_NONE, "QMI_WDS_AUTHENTICATION_NONE", "none" },
    { QMI_WDS_AUTHENTICATION_PAP, "QMI_WDS_AUTHENTICATION_PAP", "pap" },
    { QMI_WDS_AUTHENTICATION_CHAP, "QMI_WDS_AUTHENTICATION_CHAP", "chap" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_authentication_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsAuthentication"),
                                      qmi_wds_authentication_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_AUTHENTICATION_IS_ENUM__
const gchar *
qmi_wds_authentication_get_string (QmiWdsAuthentication val)
{
    guint i;

    for (i = 0; qmi_wds_authentication_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_authentication_values[i].value)
            return qmi_wds_authentication_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_AUTHENTICATION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_AUTHENTICATION_IS_FLAGS__
gchar *
qmi_wds_authentication_build_string_from_mask (QmiWdsAuthentication mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_authentication_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_authentication_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_authentication_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_authentication_values[i].value) {
            guint c;
            gulong number = qmi_wds_authentication_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_authentication_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_AUTHENTICATION_IS_FLAGS__ */
static const GEnumValue qmi_wds_profile_type_values[] = {
    { QMI_WDS_PROFILE_TYPE_3GPP, "QMI_WDS_PROFILE_TYPE_3GPP", "3gpp" },
    { QMI_WDS_PROFILE_TYPE_3GPP2, "QMI_WDS_PROFILE_TYPE_3GPP2", "3gpp2" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_profile_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsProfileType"),
                                      qmi_wds_profile_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_PROFILE_TYPE_IS_ENUM__
const gchar *
qmi_wds_profile_type_get_string (QmiWdsProfileType val)
{
    guint i;

    for (i = 0; qmi_wds_profile_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_profile_type_values[i].value)
            return qmi_wds_profile_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_PROFILE_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_PROFILE_TYPE_IS_FLAGS__
gchar *
qmi_wds_profile_type_build_string_from_mask (QmiWdsProfileType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_profile_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_profile_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_profile_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_profile_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_profile_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_profile_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_PROFILE_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wds_profile_family_values[] = {
    { QMI_WDS_PROFILE_FAMILY_EMBEDDED, "QMI_WDS_PROFILE_FAMILY_EMBEDDED", "embedded" },
    { QMI_WDS_PROFILE_FAMILY_TETHERED, "QMI_WDS_PROFILE_FAMILY_TETHERED", "tethered" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_profile_family_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsProfileFamily"),
                                      qmi_wds_profile_family_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_PROFILE_FAMILY_IS_ENUM__
const gchar *
qmi_wds_profile_family_get_string (QmiWdsProfileFamily val)
{
    guint i;

    for (i = 0; qmi_wds_profile_family_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_profile_family_values[i].value)
            return qmi_wds_profile_family_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_PROFILE_FAMILY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_PROFILE_FAMILY_IS_FLAGS__
gchar *
qmi_wds_profile_family_build_string_from_mask (QmiWdsProfileFamily mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_profile_family_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_profile_family_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_profile_family_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_profile_family_values[i].value) {
            guint c;
            gulong number = qmi_wds_profile_family_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_profile_family_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_PROFILE_FAMILY_IS_FLAGS__ */
static const GEnumValue qmi_wds_delivery_order_values[] = {
    { QMI_WDS_QOS_DELIVERY_ORDER_SUBSCRIBE, "QMI_WDS_QOS_DELIVERY_ORDER_SUBSCRIBE", "subscribe" },
    { QMI_WDS_QOS_DELIVERY_ORDER_ON, "QMI_WDS_QOS_DELIVERY_ORDER_ON", "on" },
    { QMI_WDS_QOS_DELIVERY_ORDER_OFF, "QMI_WDS_QOS_DELIVERY_ORDER_OFF", "off" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_delivery_order_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsDeliveryOrder"),
                                      qmi_wds_delivery_order_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_DELIVERY_ORDER_IS_ENUM__
const gchar *
qmi_wds_delivery_order_get_string (QmiWdsDeliveryOrder val)
{
    guint i;

    for (i = 0; qmi_wds_delivery_order_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_delivery_order_values[i].value)
            return qmi_wds_delivery_order_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_DELIVERY_ORDER_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_DELIVERY_ORDER_IS_FLAGS__
gchar *
qmi_wds_delivery_order_build_string_from_mask (QmiWdsDeliveryOrder mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_delivery_order_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_delivery_order_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_delivery_order_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_delivery_order_values[i].value) {
            guint c;
            gulong number = qmi_wds_delivery_order_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_delivery_order_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_DELIVERY_ORDER_IS_FLAGS__ */
static const GEnumValue qmi_wds_sdu_error_ratio_values[] = {
    { QMI_WDS_SDU_ERROR_RATIO_SUBSCRIBE, "QMI_WDS_SDU_ERROR_RATIO_SUBSCRIBE", "subscribe" },
    { QMI_WDS_SDU_ERROR_RATIO_1E2, "QMI_WDS_SDU_ERROR_RATIO_1E2", "1e2" },
    { QMI_WDS_SDU_ERROR_RATIO_7E3, "QMI_WDS_SDU_ERROR_RATIO_7E3", "7e3" },
    { QMI_WDS_SDU_ERROR_RATIO_1E3, "QMI_WDS_SDU_ERROR_RATIO_1E3", "1e3" },
    { QMI_WDS_SDU_ERROR_RATIO_1E4, "QMI_WDS_SDU_ERROR_RATIO_1E4", "1e4" },
    { QMI_WDS_SDU_ERROR_RATIO_1E5, "QMI_WDS_SDU_ERROR_RATIO_1E5", "1e5" },
    { QMI_WDS_SDU_ERROR_RATIO_1E6, "QMI_WDS_SDU_ERROR_RATIO_1E6", "1e6" },
    { QMI_WDS_SDU_ERROR_RATIO_1E1, "QMI_WDS_SDU_ERROR_RATIO_1E1", "1e1" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_sdu_error_ratio_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsSduErrorRatio"),
                                      qmi_wds_sdu_error_ratio_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_SDU_ERROR_RATIO_IS_ENUM__
const gchar *
qmi_wds_sdu_error_ratio_get_string (QmiWdsSduErrorRatio val)
{
    guint i;

    for (i = 0; qmi_wds_sdu_error_ratio_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_sdu_error_ratio_values[i].value)
            return qmi_wds_sdu_error_ratio_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_SDU_ERROR_RATIO_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_SDU_ERROR_RATIO_IS_FLAGS__
gchar *
qmi_wds_sdu_error_ratio_build_string_from_mask (QmiWdsSduErrorRatio mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_sdu_error_ratio_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_sdu_error_ratio_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_sdu_error_ratio_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_sdu_error_ratio_values[i].value) {
            guint c;
            gulong number = qmi_wds_sdu_error_ratio_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_sdu_error_ratio_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_SDU_ERROR_RATIO_IS_FLAGS__ */
static const GEnumValue qmi_wds_sdu_residual_bit_error_ratio_values[] = {
    { QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_SUBSCRIBE, "QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_SUBSCRIBE", "subscribe" },
    { QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_5E2, "QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_5E2", "5e2" },
    { QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_1E2, "QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_1E2", "1e2" },
    { QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_5E3, "QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_5E3", "5e3" },
    { QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_4E3, "QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_4E3", "4e3" },
    { QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_1E3, "QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_1E3", "1e3" },
    { QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_1E4, "QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_1E4", "1e4" },
    { QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_1E5, "QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_1E5", "1e5" },
    { QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_1E6, "QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_1E6", "1e6" },
    { QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_6E8, "QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_6E8", "6e8" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_sdu_residual_bit_error_ratio_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsSduResidualBitErrorRatio"),
                                      qmi_wds_sdu_residual_bit_error_ratio_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_IS_ENUM__
const gchar *
qmi_wds_sdu_residual_bit_error_ratio_get_string (QmiWdsSduResidualBitErrorRatio val)
{
    guint i;

    for (i = 0; qmi_wds_sdu_residual_bit_error_ratio_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_sdu_residual_bit_error_ratio_values[i].value)
            return qmi_wds_sdu_residual_bit_error_ratio_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_IS_FLAGS__
gchar *
qmi_wds_sdu_residual_bit_error_ratio_build_string_from_mask (QmiWdsSduResidualBitErrorRatio mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_sdu_residual_bit_error_ratio_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_sdu_residual_bit_error_ratio_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_sdu_residual_bit_error_ratio_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_sdu_residual_bit_error_ratio_values[i].value) {
            guint c;
            gulong number = qmi_wds_sdu_residual_bit_error_ratio_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_sdu_residual_bit_error_ratio_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_IS_FLAGS__ */
static const GEnumValue qmi_wds_sdu_erroneous_delivery_values[] = {
    { QMI_WDS_SDU_ERRONEOUS_DELIVERY_SUBSCRIBE, "QMI_WDS_SDU_ERRONEOUS_DELIVERY_SUBSCRIBE", "subscribe" },
    { QMI_WDS_SDU_ERRONEOUS_DELIVERY_NO_DETECTION, "QMI_WDS_SDU_ERRONEOUS_DELIVERY_NO_DETECTION", "no-detection" },
    { QMI_WDS_SDU_ERRONEOUS_DELIVERY_ENABLED, "QMI_WDS_SDU_ERRONEOUS_DELIVERY_ENABLED", "enabled" },
    { QMI_WDS_SDU_ERRONEOUS_DELIVERY_DISABLED, "QMI_WDS_SDU_ERRONEOUS_DELIVERY_DISABLED", "disabled" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_sdu_erroneous_delivery_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsSduErroneousDelivery"),
                                      qmi_wds_sdu_erroneous_delivery_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_SDU_ERRONEOUS_DELIVERY_IS_ENUM__
const gchar *
qmi_wds_sdu_erroneous_delivery_get_string (QmiWdsSduErroneousDelivery val)
{
    guint i;

    for (i = 0; qmi_wds_sdu_erroneous_delivery_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_sdu_erroneous_delivery_values[i].value)
            return qmi_wds_sdu_erroneous_delivery_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_SDU_ERRONEOUS_DELIVERY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_SDU_ERRONEOUS_DELIVERY_IS_FLAGS__
gchar *
qmi_wds_sdu_erroneous_delivery_build_string_from_mask (QmiWdsSduErroneousDelivery mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_sdu_erroneous_delivery_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_sdu_erroneous_delivery_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_sdu_erroneous_delivery_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_sdu_erroneous_delivery_values[i].value) {
            guint c;
            gulong number = qmi_wds_sdu_erroneous_delivery_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_sdu_erroneous_delivery_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_SDU_ERRONEOUS_DELIVERY_IS_FLAGS__ */
static const GFlagsValue qmi_wds_packet_statistics_mask_flag_values[] = {
    { QMI_WDS_PACKET_STATISTICS_MASK_FLAG_TX_PACKETS_OK, "QMI_WDS_PACKET_STATISTICS_MASK_FLAG_TX_PACKETS_OK", "tx-packets-ok" },
    { QMI_WDS_PACKET_STATISTICS_MASK_FLAG_RX_PACKETS_OK, "QMI_WDS_PACKET_STATISTICS_MASK_FLAG_RX_PACKETS_OK", "rx-packets-ok" },
    { QMI_WDS_PACKET_STATISTICS_MASK_FLAG_TX_PACKETS_ERROR, "QMI_WDS_PACKET_STATISTICS_MASK_FLAG_TX_PACKETS_ERROR", "tx-packets-error" },
    { QMI_WDS_PACKET_STATISTICS_MASK_FLAG_RX_PACKETS_ERROR, "QMI_WDS_PACKET_STATISTICS_MASK_FLAG_RX_PACKETS_ERROR", "rx-packets-error" },
    { QMI_WDS_PACKET_STATISTICS_MASK_FLAG_TX_OVERFLOWS, "QMI_WDS_PACKET_STATISTICS_MASK_FLAG_TX_OVERFLOWS", "tx-overflows" },
    { QMI_WDS_PACKET_STATISTICS_MASK_FLAG_RX_OVERFLOWS, "QMI_WDS_PACKET_STATISTICS_MASK_FLAG_RX_OVERFLOWS", "rx-overflows" },
    { QMI_WDS_PACKET_STATISTICS_MASK_FLAG_TX_BYTES_OK, "QMI_WDS_PACKET_STATISTICS_MASK_FLAG_TX_BYTES_OK", "tx-bytes-ok" },
    { QMI_WDS_PACKET_STATISTICS_MASK_FLAG_RX_BYTES_OK, "QMI_WDS_PACKET_STATISTICS_MASK_FLAG_RX_BYTES_OK", "rx-bytes-ok" },
    { QMI_WDS_PACKET_STATISTICS_MASK_FLAG_TX_PACKETS_DROPPED, "QMI_WDS_PACKET_STATISTICS_MASK_FLAG_TX_PACKETS_DROPPED", "tx-packets-dropped" },
    { QMI_WDS_PACKET_STATISTICS_MASK_FLAG_RX_PACKETS_DROPPED, "QMI_WDS_PACKET_STATISTICS_MASK_FLAG_RX_PACKETS_DROPPED", "rx-packets-dropped" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_packet_statistics_mask_flag_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsPacketStatisticsMaskFlag"),
                                      qmi_wds_packet_statistics_mask_flag_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_PACKET_STATISTICS_MASK_FLAG_IS_ENUM__
const gchar *
qmi_wds_packet_statistics_mask_flag_get_string (QmiWdsPacketStatisticsMaskFlag val)
{
    guint i;

    for (i = 0; qmi_wds_packet_statistics_mask_flag_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_packet_statistics_mask_flag_values[i].value)
            return qmi_wds_packet_statistics_mask_flag_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_PACKET_STATISTICS_MASK_FLAG_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_PACKET_STATISTICS_MASK_FLAG_IS_FLAGS__
gchar *
qmi_wds_packet_statistics_mask_flag_build_string_from_mask (QmiWdsPacketStatisticsMaskFlag mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_packet_statistics_mask_flag_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_packet_statistics_mask_flag_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_packet_statistics_mask_flag_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_packet_statistics_mask_flag_values[i].value) {
            guint c;
            gulong number = qmi_wds_packet_statistics_mask_flag_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_packet_statistics_mask_flag_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_PACKET_STATISTICS_MASK_FLAG_IS_FLAGS__ */
static const GEnumValue qmi_wds_ds_profile_error_values[] = {
    { QMI_WDS_DS_PROFILE_ERROR_UNKNOWN, "QMI_WDS_DS_PROFILE_ERROR_UNKNOWN", "unknown" },
    { QMI_WDS_DS_PROFILE_ERROR_FAIL, "QMI_WDS_DS_PROFILE_ERROR_FAIL", "fail" },
    { QMI_WDS_DS_PROFILE_ERROR_INVALID_HANDLE, "QMI_WDS_DS_PROFILE_ERROR_INVALID_HANDLE", "invalid-handle" },
    { QMI_WDS_DS_PROFILE_ERROR_INVALID_OPERATION, "QMI_WDS_DS_PROFILE_ERROR_INVALID_OPERATION", "invalid-operation" },
    { QMI_WDS_DS_PROFILE_ERROR_INVALID_PROFILE_TYPE, "QMI_WDS_DS_PROFILE_ERROR_INVALID_PROFILE_TYPE", "invalid-profile-type" },
    { QMI_WDS_DS_PROFILE_ERROR_INVALID_PROFILE_NUMBER, "QMI_WDS_DS_PROFILE_ERROR_INVALID_PROFILE_NUMBER", "invalid-profile-number" },
    { QMI_WDS_DS_PROFILE_ERROR_INVALID_PROFILE_ID, "QMI_WDS_DS_PROFILE_ERROR_INVALID_PROFILE_ID", "invalid-profile-id" },
    { QMI_WDS_DS_PROFILE_ERROR_INVALID_ARGUMENT, "QMI_WDS_DS_PROFILE_ERROR_INVALID_ARGUMENT", "invalid-argument" },
    { QMI_WDS_DS_PROFILE_ERROR_REGISTRY_NOT_INITIALIZED, "QMI_WDS_DS_PROFILE_ERROR_REGISTRY_NOT_INITIALIZED", "registry-not-initialized" },
    { QMI_WDS_DS_PROFILE_ERROR_INVALID_PARAMETER_LENGTH, "QMI_WDS_DS_PROFILE_ERROR_INVALID_PARAMETER_LENGTH", "invalid-parameter-length" },
    { QMI_WDS_DS_PROFILE_ERROR_LIST_END, "QMI_WDS_DS_PROFILE_ERROR_LIST_END", "list-end" },
    { QMI_WDS_DS_PROFILE_ERROR_INVALID_SUBSCRIPTION_ID, "QMI_WDS_DS_PROFILE_ERROR_INVALID_SUBSCRIPTION_ID", "invalid-subscription-id" },
    { QMI_WDS_DS_PROFILE_ERROR_INVALID_PROFILE_FAMILY, "QMI_WDS_DS_PROFILE_ERROR_INVALID_PROFILE_FAMILY", "invalid-profile-family" },
    { QMI_WDS_DS_PROFILE_ERROR_3GPP_INVALID_PROFILE_FAMILY, "QMI_WDS_DS_PROFILE_ERROR_3GPP_INVALID_PROFILE_FAMILY", "3gpp-invalid-profile-family" },
    { QMI_WDS_DS_PROFILE_ERROR_3GPP_ACCESS_ERROR, "QMI_WDS_DS_PROFILE_ERROR_3GPP_ACCESS_ERROR", "3gpp-access-error" },
    { QMI_WDS_DS_PROFILE_ERROR_3GPP_CONTEXT_NOT_DEFINED, "QMI_WDS_DS_PROFILE_ERROR_3GPP_CONTEXT_NOT_DEFINED", "3gpp-context-not-defined" },
    { QMI_WDS_DS_PROFILE_ERROR_3GPP_VALID_FLAG_NOT_SET, "QMI_WDS_DS_PROFILE_ERROR_3GPP_VALID_FLAG_NOT_SET", "3gpp-valid-flag-not-set" },
    { QMI_WDS_DS_PROFILE_ERROR_3GPP_READ_ONLY_FLAG_SET, "QMI_WDS_DS_PROFILE_ERROR_3GPP_READ_ONLY_FLAG_SET", "3gpp-read-only-flag-set" },
    { QMI_WDS_DS_PROFILE_ERROR_3GPP_OUT_OF_PROFILES, "QMI_WDS_DS_PROFILE_ERROR_3GPP_OUT_OF_PROFILES", "3gpp-out-of-profiles" },
    { QMI_WDS_DS_PROFILE_ERROR_3GPP2_INVALID_PROFILE_ID, "QMI_WDS_DS_PROFILE_ERROR_3GPP2_INVALID_PROFILE_ID", "3gpp2-invalid-profile-id" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_ds_profile_error_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsDsProfileError"),
                                      qmi_wds_ds_profile_error_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_DS_PROFILE_ERROR_IS_ENUM__
const gchar *
qmi_wds_ds_profile_error_get_string (QmiWdsDsProfileError val)
{
    guint i;

    for (i = 0; qmi_wds_ds_profile_error_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_ds_profile_error_values[i].value)
            return qmi_wds_ds_profile_error_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_DS_PROFILE_ERROR_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_DS_PROFILE_ERROR_IS_FLAGS__
gchar *
qmi_wds_ds_profile_error_build_string_from_mask (QmiWdsDsProfileError mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_ds_profile_error_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_ds_profile_error_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_ds_profile_error_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_ds_profile_error_values[i].value) {
            guint c;
            gulong number = qmi_wds_ds_profile_error_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_ds_profile_error_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_DS_PROFILE_ERROR_IS_FLAGS__ */
static const GEnumValue qmi_wds_autoconnect_setting_values[] = {
    { QMI_WDS_AUTOCONNECT_SETTING_DISABLED, "QMI_WDS_AUTOCONNECT_SETTING_DISABLED", "disabled" },
    { QMI_WDS_AUTOCONNECT_SETTING_ENABLED, "QMI_WDS_AUTOCONNECT_SETTING_ENABLED", "enabled" },
    { QMI_WDS_AUTOCONNECT_SETTING_PAUSED, "QMI_WDS_AUTOCONNECT_SETTING_PAUSED", "paused" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_autoconnect_setting_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsAutoconnectSetting"),
                                      qmi_wds_autoconnect_setting_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_AUTOCONNECT_SETTING_IS_ENUM__
const gchar *
qmi_wds_autoconnect_setting_get_string (QmiWdsAutoconnectSetting val)
{
    guint i;

    for (i = 0; qmi_wds_autoconnect_setting_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_autoconnect_setting_values[i].value)
            return qmi_wds_autoconnect_setting_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_AUTOCONNECT_SETTING_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_AUTOCONNECT_SETTING_IS_FLAGS__
gchar *
qmi_wds_autoconnect_setting_build_string_from_mask (QmiWdsAutoconnectSetting mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_autoconnect_setting_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_autoconnect_setting_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_autoconnect_setting_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_autoconnect_setting_values[i].value) {
            guint c;
            gulong number = qmi_wds_autoconnect_setting_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_autoconnect_setting_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_AUTOCONNECT_SETTING_IS_FLAGS__ */
static const GEnumValue qmi_wds_autoconnect_setting_roaming_values[] = {
    { QMI_WDS_AUTOCONNECT_SETTING_ROAMING_ALLOWED, "QMI_WDS_AUTOCONNECT_SETTING_ROAMING_ALLOWED", "allowed" },
    { QMI_WDS_AUTOCONNECT_SETTING_ROAMING_HOME_ONLY, "QMI_WDS_AUTOCONNECT_SETTING_ROAMING_HOME_ONLY", "home-only" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_autoconnect_setting_roaming_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsAutoconnectSettingRoaming"),
                                      qmi_wds_autoconnect_setting_roaming_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_AUTOCONNECT_SETTING_ROAMING_IS_ENUM__
const gchar *
qmi_wds_autoconnect_setting_roaming_get_string (QmiWdsAutoconnectSettingRoaming val)
{
    guint i;

    for (i = 0; qmi_wds_autoconnect_setting_roaming_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_autoconnect_setting_roaming_values[i].value)
            return qmi_wds_autoconnect_setting_roaming_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_AUTOCONNECT_SETTING_ROAMING_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_AUTOCONNECT_SETTING_ROAMING_IS_FLAGS__
gchar *
qmi_wds_autoconnect_setting_roaming_build_string_from_mask (QmiWdsAutoconnectSettingRoaming mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_autoconnect_setting_roaming_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_autoconnect_setting_roaming_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_autoconnect_setting_roaming_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_autoconnect_setting_roaming_values[i].value) {
            guint c;
            gulong number = qmi_wds_autoconnect_setting_roaming_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_autoconnect_setting_roaming_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_AUTOCONNECT_SETTING_ROAMING_IS_FLAGS__ */
static const GFlagsValue qmi_wds_set_event_report_transfer_statistics_values[] = {
    { QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_TX_PACKETS_OK, "QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_TX_PACKETS_OK", "tx-packets-ok" },
    { QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_RX_PACKETS_OK, "QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_RX_PACKETS_OK", "rx-packets-ok" },
    { QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_TX_PACKETS_ERROR, "QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_TX_PACKETS_ERROR", "tx-packets-error" },
    { QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_RX_PACKETS_ERROR, "QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_RX_PACKETS_ERROR", "rx-packets-error" },
    { QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_TX_OVERFLOWS, "QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_TX_OVERFLOWS", "tx-overflows" },
    { QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_RX_OVERFLOWS, "QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_RX_OVERFLOWS", "rx-overflows" },
    { QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_TX_BYTES_OK, "QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_TX_BYTES_OK", "tx-bytes-ok" },
    { QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_RX_BYTES_OK, "QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_RX_BYTES_OK", "rx-bytes-ok" },
    { QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_TX_PACKETS_DROPPED, "QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_TX_PACKETS_DROPPED", "tx-packets-dropped" },
    { QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_RX_PACKETS_DROPPED, "QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_RX_PACKETS_DROPPED", "rx-packets-dropped" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_set_event_report_transfer_statistics_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsSetEventReportTransferStatistics"),
                                      qmi_wds_set_event_report_transfer_statistics_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_IS_ENUM__
const gchar *
qmi_wds_set_event_report_transfer_statistics_get_string (QmiWdsSetEventReportTransferStatistics val)
{
    guint i;

    for (i = 0; qmi_wds_set_event_report_transfer_statistics_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_set_event_report_transfer_statistics_values[i].value)
            return qmi_wds_set_event_report_transfer_statistics_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_IS_FLAGS__
gchar *
qmi_wds_set_event_report_transfer_statistics_build_string_from_mask (QmiWdsSetEventReportTransferStatistics mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_set_event_report_transfer_statistics_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_set_event_report_transfer_statistics_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_set_event_report_transfer_statistics_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_set_event_report_transfer_statistics_values[i].value) {
            guint c;
            gulong number = qmi_wds_set_event_report_transfer_statistics_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_set_event_report_transfer_statistics_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_IS_FLAGS__ */
static const GEnumValue qmi_wds_dormancy_status_values[] = {
    { QMI_WDS_DORMANCY_STATUS_UNKNOWN, "QMI_WDS_DORMANCY_STATUS_UNKNOWN", "unknown" },
    { QMI_WDS_DORMANCY_STATUS_TRAFFIC_CHANNEL_DORMANT, "QMI_WDS_DORMANCY_STATUS_TRAFFIC_CHANNEL_DORMANT", "traffic-channel-dormant" },
    { QMI_WDS_DORMANCY_STATUS_TRAFFIC_CHANNEL_ACTIVE, "QMI_WDS_DORMANCY_STATUS_TRAFFIC_CHANNEL_ACTIVE", "traffic-channel-active" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_dormancy_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsDormancyStatus"),
                                      qmi_wds_dormancy_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_DORMANCY_STATUS_IS_ENUM__
const gchar *
qmi_wds_dormancy_status_get_string (QmiWdsDormancyStatus val)
{
    guint i;

    for (i = 0; qmi_wds_dormancy_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_dormancy_status_values[i].value)
            return qmi_wds_dormancy_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_DORMANCY_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_DORMANCY_STATUS_IS_FLAGS__
gchar *
qmi_wds_dormancy_status_build_string_from_mask (QmiWdsDormancyStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_dormancy_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_dormancy_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_dormancy_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_dormancy_status_values[i].value) {
            guint c;
            gulong number = qmi_wds_dormancy_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_dormancy_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_DORMANCY_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_wds_data_call_status_values[] = {
    { QMI_WDS_DATA_CALL_STATUS_UNKNOWN, "QMI_WDS_DATA_CALL_STATUS_UNKNOWN", "unknown" },
    { QMI_WDS_DATA_CALL_STATUS_ACTIVATED, "QMI_WDS_DATA_CALL_STATUS_ACTIVATED", "activated" },
    { QMI_WDS_DATA_CALL_STATUS_TERMINATED, "QMI_WDS_DATA_CALL_STATUS_TERMINATED", "terminated" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_data_call_status_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsDataCallStatus"),
                                      qmi_wds_data_call_status_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_DATA_CALL_STATUS_IS_ENUM__
const gchar *
qmi_wds_data_call_status_get_string (QmiWdsDataCallStatus val)
{
    guint i;

    for (i = 0; qmi_wds_data_call_status_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_data_call_status_values[i].value)
            return qmi_wds_data_call_status_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_DATA_CALL_STATUS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_DATA_CALL_STATUS_IS_FLAGS__
gchar *
qmi_wds_data_call_status_build_string_from_mask (QmiWdsDataCallStatus mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_data_call_status_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_data_call_status_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_data_call_status_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_data_call_status_values[i].value) {
            guint c;
            gulong number = qmi_wds_data_call_status_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_data_call_status_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_DATA_CALL_STATUS_IS_FLAGS__ */
static const GEnumValue qmi_wds_data_call_type_values[] = {
    { QMI_WDS_DATA_CALL_TYPE_UNKNOWN, "QMI_WDS_DATA_CALL_TYPE_UNKNOWN", "unknown" },
    { QMI_WDS_DATA_CALL_TYPE_EMBEDDED, "QMI_WDS_DATA_CALL_TYPE_EMBEDDED", "embedded" },
    { QMI_WDS_DATA_CALL_TYPE_TETHERED, "QMI_WDS_DATA_CALL_TYPE_TETHERED", "tethered" },
    { QMI_WDS_DATA_CALL_TYPE_MODEM_EMBEDDED, "QMI_WDS_DATA_CALL_TYPE_MODEM_EMBEDDED", "modem-embedded" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_data_call_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsDataCallType"),
                                      qmi_wds_data_call_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_DATA_CALL_TYPE_IS_ENUM__
const gchar *
qmi_wds_data_call_type_get_string (QmiWdsDataCallType val)
{
    guint i;

    for (i = 0; qmi_wds_data_call_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_data_call_type_values[i].value)
            return qmi_wds_data_call_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_DATA_CALL_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_DATA_CALL_TYPE_IS_FLAGS__
gchar *
qmi_wds_data_call_type_build_string_from_mask (QmiWdsDataCallType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_data_call_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_data_call_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_data_call_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_data_call_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_data_call_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_data_call_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_DATA_CALL_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wds_tethered_call_type_values[] = {
    { QMI_WDS_TETHERED_CALL_TYPE_NON_TETHERED, "QMI_WDS_TETHERED_CALL_TYPE_NON_TETHERED", "non-tethered" },
    { QMI_WDS_TETHERED_CALL_TYPE_RMNET, "QMI_WDS_TETHERED_CALL_TYPE_RMNET", "rmnet" },
    { QMI_WDS_TETHERED_CALL_TYPE_DUN, "QMI_WDS_TETHERED_CALL_TYPE_DUN", "dun" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_tethered_call_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsTetheredCallType"),
                                      qmi_wds_tethered_call_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_TETHERED_CALL_TYPE_IS_ENUM__
const gchar *
qmi_wds_tethered_call_type_get_string (QmiWdsTetheredCallType val)
{
    guint i;

    for (i = 0; qmi_wds_tethered_call_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_tethered_call_type_values[i].value)
            return qmi_wds_tethered_call_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_TETHERED_CALL_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_TETHERED_CALL_TYPE_IS_FLAGS__
gchar *
qmi_wds_tethered_call_type_build_string_from_mask (QmiWdsTetheredCallType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_tethered_call_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_tethered_call_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_tethered_call_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_tethered_call_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_tethered_call_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_tethered_call_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_TETHERED_CALL_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wds_radio_access_technology_values[] = {
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_NULL_BEARER, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_NULL_BEARER", "null-bearer" },
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_WCDMA, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_WCDMA", "3gpp-wcdma" },
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_GERAN, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_GERAN", "3gpp-geran" },
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_LTE, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_LTE", "3gpp-lte" },
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_TDSCDMA, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_TDSCDMA", "3gpp-tdscdma" },
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_WLAN, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_WLAN", "3gpp-wlan" },
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_MAXIMUM, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP_MAXIMUM", "3gpp-maximum" },
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP2_1X, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP2_1X", "3gpp2-1x" },
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP2_HRPD, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP2_HRPD", "3gpp2-hrpd" },
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP2_EHRPD, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP2_EHRPD", "3gpp2-ehrpd" },
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP2_WLAN, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP2_WLAN", "3gpp2-wlan" },
    { QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP2_MAXIMUM, "QMI_WDS_RADIO_ACCESS_TECHNOLOGY_3GPP2_MAXIMUM", "3gpp2-maximum" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_radio_access_technology_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsRadioAccessTechnology"),
                                      qmi_wds_radio_access_technology_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_RADIO_ACCESS_TECHNOLOGY_IS_ENUM__
const gchar *
qmi_wds_radio_access_technology_get_string (QmiWdsRadioAccessTechnology val)
{
    guint i;

    for (i = 0; qmi_wds_radio_access_technology_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_radio_access_technology_values[i].value)
            return qmi_wds_radio_access_technology_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_RADIO_ACCESS_TECHNOLOGY_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_RADIO_ACCESS_TECHNOLOGY_IS_FLAGS__
gchar *
qmi_wds_radio_access_technology_build_string_from_mask (QmiWdsRadioAccessTechnology mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_radio_access_technology_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_radio_access_technology_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_radio_access_technology_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_radio_access_technology_values[i].value) {
            guint c;
            gulong number = qmi_wds_radio_access_technology_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_radio_access_technology_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_RADIO_ACCESS_TECHNOLOGY_IS_FLAGS__ */
static const GFlagsValue qmi_wds_extended_data_bearer_technology_3gpp_values[] = {
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_UNKNOWN, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_UNKNOWN", "unknown" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_WCDMA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_WCDMA", "wcdma" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_HSDPA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_HSDPA", "hsdpa" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_HSUPA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_HSUPA", "hsupa" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_HSDPA_PLUS, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_HSDPA_PLUS", "hsdpa-plus" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_DC_HSDPA_PLUS, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_DC_HSDPA_PLUS", "dc-hsdpa-plus" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_64QAM, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_64QAM", "64qam" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_HSPA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_HSPA", "hspa" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_GPRS, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_GPRS", "gprs" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_EDGE, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_EDGE", "edge" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_GSM, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_GSM", "gsm" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_S2B, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_S2B", "s2b" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_LTE_LIMITED_SERVICE, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_LTE_LIMITED_SERVICE", "lte-limited-service" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_LTE_FDD, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_LTE_FDD", "lte-fdd" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_LTE_TDD, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_LTE_TDD", "lte-tdd" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_extended_data_bearer_technology_3gpp_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsExtendedDataBearerTechnology3gpp"),
                                      qmi_wds_extended_data_bearer_technology_3gpp_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_IS_ENUM__
const gchar *
qmi_wds_extended_data_bearer_technology_3gpp_get_string (QmiWdsExtendedDataBearerTechnology3gpp val)
{
    guint i;

    for (i = 0; qmi_wds_extended_data_bearer_technology_3gpp_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_extended_data_bearer_technology_3gpp_values[i].value)
            return qmi_wds_extended_data_bearer_technology_3gpp_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_IS_FLAGS__
gchar *
qmi_wds_extended_data_bearer_technology_3gpp_build_string_from_mask (QmiWdsExtendedDataBearerTechnology3gpp mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_extended_data_bearer_technology_3gpp_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_extended_data_bearer_technology_3gpp_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_extended_data_bearer_technology_3gpp_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_extended_data_bearer_technology_3gpp_values[i].value) {
            guint c;
            gulong number = qmi_wds_extended_data_bearer_technology_3gpp_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_extended_data_bearer_technology_3gpp_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_IS_FLAGS__ */
static const GFlagsValue qmi_wds_extended_data_bearer_technology_3gpp2_values[] = {
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_UNKNOWN, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_UNKNOWN", "unknown" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_RESERVED, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_RESERVED", "reserved" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_CDMA1X_IS95, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_CDMA1X_IS95", "cdma1x-is95" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_CDMA1X_IS2000, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_CDMA1X_IS2000", "cdma1x-is2000" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_CDMA1X_IS2000_REL_A, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_CDMA1X_IS2000_REL_A", "cdma1x-is2000-rel-a" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_0_DPA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_0_DPA", "hdr-rev-0-dpa" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_A_DPA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_A_DPA", "hdr-rev-a-dpa" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_B_DPA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_B_DPA", "hdr-rev-b-dpa" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_A_MPA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_A_MPA", "hdr-rev-a-mpa" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_B_MPA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_B_MPA", "hdr-rev-b-mpa" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_A_EMPA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_A_EMPA", "hdr-rev-a-empa" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_B_EMPA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_B_EMPA", "hdr-rev-b-empa" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_B_MMPA, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_REV_B_MMPA", "hdr-rev-b-mmpa" },
    { QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_EVDO_FMC, "QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_HDR_EVDO_FMC", "hdr-evdo-fmc" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_extended_data_bearer_technology_3gpp2_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_flags_register_static (g_intern_static_string ("QmiWdsExtendedDataBearerTechnology3gpp2"),
                                      qmi_wds_extended_data_bearer_technology_3gpp2_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_IS_ENUM__
const gchar *
qmi_wds_extended_data_bearer_technology_3gpp2_get_string (QmiWdsExtendedDataBearerTechnology3gpp2 val)
{
    guint i;

    for (i = 0; qmi_wds_extended_data_bearer_technology_3gpp2_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_extended_data_bearer_technology_3gpp2_values[i].value)
            return qmi_wds_extended_data_bearer_technology_3gpp2_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_IS_FLAGS__
gchar *
qmi_wds_extended_data_bearer_technology_3gpp2_build_string_from_mask (QmiWdsExtendedDataBearerTechnology3gpp2 mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_extended_data_bearer_technology_3gpp2_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_extended_data_bearer_technology_3gpp2_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_extended_data_bearer_technology_3gpp2_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_extended_data_bearer_technology_3gpp2_values[i].value) {
            guint c;
            gulong number = qmi_wds_extended_data_bearer_technology_3gpp2_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_extended_data_bearer_technology_3gpp2_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_IS_FLAGS__ */
static const GEnumValue qmi_wds_pdp_header_compression_type_values[] = {
    { QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_OFF, "QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_OFF", "off" },
    { QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_MANUFACTURER_PREFERRED, "QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_MANUFACTURER_PREFERRED", "manufacturer-preferred" },
    { QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_RFC1144, "QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_RFC1144", "rfc1144" },
    { QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_RFC2507, "QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_RFC2507", "rfc2507" },
    { QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_RFC3095, "QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_RFC3095", "rfc3095" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_pdp_header_compression_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsPdpHeaderCompressionType"),
                                      qmi_wds_pdp_header_compression_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_IS_ENUM__
const gchar *
qmi_wds_pdp_header_compression_type_get_string (QmiWdsPdpHeaderCompressionType val)
{
    guint i;

    for (i = 0; qmi_wds_pdp_header_compression_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_pdp_header_compression_type_values[i].value)
            return qmi_wds_pdp_header_compression_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_IS_FLAGS__
gchar *
qmi_wds_pdp_header_compression_type_build_string_from_mask (QmiWdsPdpHeaderCompressionType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_pdp_header_compression_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_pdp_header_compression_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_pdp_header_compression_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_pdp_header_compression_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_pdp_header_compression_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_pdp_header_compression_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wds_pdp_data_compression_type_values[] = {
    { QMI_WDS_PDP_DATA_COMPRESSION_TYPE_OFF, "QMI_WDS_PDP_DATA_COMPRESSION_TYPE_OFF", "off" },
    { QMI_WDS_PDP_DATA_COMPRESSION_TYPE_MANUFACTURER_PREFERRED, "QMI_WDS_PDP_DATA_COMPRESSION_TYPE_MANUFACTURER_PREFERRED", "manufacturer-preferred" },
    { QMI_WDS_PDP_DATA_COMPRESSION_TYPE_V42BIS, "QMI_WDS_PDP_DATA_COMPRESSION_TYPE_V42BIS", "v42bis" },
    { QMI_WDS_PDP_DATA_COMPRESSION_TYPE_V44, "QMI_WDS_PDP_DATA_COMPRESSION_TYPE_V44", "v44" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_pdp_data_compression_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsPdpDataCompressionType"),
                                      qmi_wds_pdp_data_compression_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_PDP_DATA_COMPRESSION_TYPE_IS_ENUM__
const gchar *
qmi_wds_pdp_data_compression_type_get_string (QmiWdsPdpDataCompressionType val)
{
    guint i;

    for (i = 0; qmi_wds_pdp_data_compression_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_pdp_data_compression_type_values[i].value)
            return qmi_wds_pdp_data_compression_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_PDP_DATA_COMPRESSION_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_PDP_DATA_COMPRESSION_TYPE_IS_FLAGS__
gchar *
qmi_wds_pdp_data_compression_type_build_string_from_mask (QmiWdsPdpDataCompressionType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_pdp_data_compression_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_pdp_data_compression_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_pdp_data_compression_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_pdp_data_compression_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_pdp_data_compression_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_pdp_data_compression_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_PDP_DATA_COMPRESSION_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wds_qos_class_identifier_values[] = {
    { QMI_WDS_QOS_CLASS_IDENTIFIER_NETWORK_ASSIGN, "QMI_WDS_QOS_CLASS_IDENTIFIER_NETWORK_ASSIGN", "network-assign" },
    { QMI_WDS_QOS_CLASS_IDENTIFIER_GUARANTEED_BITRATE1, "QMI_WDS_QOS_CLASS_IDENTIFIER_GUARANTEED_BITRATE1", "guaranteed-bitrate1" },
    { QMI_WDS_QOS_CLASS_IDENTIFIER_GUARANTEED_BITRATE2, "QMI_WDS_QOS_CLASS_IDENTIFIER_GUARANTEED_BITRATE2", "guaranteed-bitrate2" },
    { QMI_WDS_QOS_CLASS_IDENTIFIER_GUARANTEED_BITRATE3, "QMI_WDS_QOS_CLASS_IDENTIFIER_GUARANTEED_BITRATE3", "guaranteed-bitrate3" },
    { QMI_WDS_QOS_CLASS_IDENTIFIER_GUARANTEED_BITRATE4, "QMI_WDS_QOS_CLASS_IDENTIFIER_GUARANTEED_BITRATE4", "guaranteed-bitrate4" },
    { QMI_WDS_QOS_CLASS_IDENTIFIER_NON_GUARANTEED_BITRATE5, "QMI_WDS_QOS_CLASS_IDENTIFIER_NON_GUARANTEED_BITRATE5", "non-guaranteed-bitrate5" },
    { QMI_WDS_QOS_CLASS_IDENTIFIER_NON_GUARANTEED_BITRATE6, "QMI_WDS_QOS_CLASS_IDENTIFIER_NON_GUARANTEED_BITRATE6", "non-guaranteed-bitrate6" },
    { QMI_WDS_QOS_CLASS_IDENTIFIER_NON_GUARANTEED_BITRATE7, "QMI_WDS_QOS_CLASS_IDENTIFIER_NON_GUARANTEED_BITRATE7", "non-guaranteed-bitrate7" },
    { QMI_WDS_QOS_CLASS_IDENTIFIER_NON_GUARANTEED_BITRATE8, "QMI_WDS_QOS_CLASS_IDENTIFIER_NON_GUARANTEED_BITRATE8", "non-guaranteed-bitrate8" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_qos_class_identifier_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsQosClassIdentifier"),
                                      qmi_wds_qos_class_identifier_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_QOS_CLASS_IDENTIFIER_IS_ENUM__
const gchar *
qmi_wds_qos_class_identifier_get_string (QmiWdsQosClassIdentifier val)
{
    guint i;

    for (i = 0; qmi_wds_qos_class_identifier_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_qos_class_identifier_values[i].value)
            return qmi_wds_qos_class_identifier_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_QOS_CLASS_IDENTIFIER_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_QOS_CLASS_IDENTIFIER_IS_FLAGS__
gchar *
qmi_wds_qos_class_identifier_build_string_from_mask (QmiWdsQosClassIdentifier mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_qos_class_identifier_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_qos_class_identifier_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_qos_class_identifier_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_qos_class_identifier_values[i].value) {
            guint c;
            gulong number = qmi_wds_qos_class_identifier_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_qos_class_identifier_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_QOS_CLASS_IDENTIFIER_IS_FLAGS__ */
static const GEnumValue qmi_wds_attach_pdn_list_action_values[] = {
    { QMI_WDS_ATTACH_PDN_LIST_ACTION_NONE, "QMI_WDS_ATTACH_PDN_LIST_ACTION_NONE", "none" },
    { QMI_WDS_ATTACH_PDN_LIST_ACTION_DETACH_OR_PDN_DISCONNECT, "QMI_WDS_ATTACH_PDN_LIST_ACTION_DETACH_OR_PDN_DISCONNECT", "detach-or-pdn-disconnect" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_attach_pdn_list_action_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsAttachPdnListAction"),
                                      qmi_wds_attach_pdn_list_action_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_ATTACH_PDN_LIST_ACTION_IS_ENUM__
const gchar *
qmi_wds_attach_pdn_list_action_get_string (QmiWdsAttachPdnListAction val)
{
    guint i;

    for (i = 0; qmi_wds_attach_pdn_list_action_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_attach_pdn_list_action_values[i].value)
            return qmi_wds_attach_pdn_list_action_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_ATTACH_PDN_LIST_ACTION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_ATTACH_PDN_LIST_ACTION_IS_FLAGS__
gchar *
qmi_wds_attach_pdn_list_action_build_string_from_mask (QmiWdsAttachPdnListAction mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_attach_pdn_list_action_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_attach_pdn_list_action_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_attach_pdn_list_action_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_attach_pdn_list_action_values[i].value) {
            guint c;
            gulong number = qmi_wds_attach_pdn_list_action_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_attach_pdn_list_action_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_ATTACH_PDN_LIST_ACTION_IS_FLAGS__ */
static const GEnumValue qmi_wds_client_type_values[] = {
    { QMI_WDS_CLIENT_TYPE_TETHERED, "QMI_WDS_CLIENT_TYPE_TETHERED", "tethered" },
    { QMI_WDS_CLIENT_TYPE_UNDEFINED, "QMI_WDS_CLIENT_TYPE_UNDEFINED", "undefined" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_client_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsClientType"),
                                      qmi_wds_client_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_CLIENT_TYPE_IS_ENUM__
const gchar *
qmi_wds_client_type_get_string (QmiWdsClientType val)
{
    guint i;

    for (i = 0; qmi_wds_client_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_client_type_values[i].value)
            return qmi_wds_client_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_CLIENT_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_CLIENT_TYPE_IS_FLAGS__
gchar *
qmi_wds_client_type_build_string_from_mask (QmiWdsClientType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_client_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_client_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_client_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_client_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_client_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_client_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_CLIENT_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wds_ip_support_type_values[] = {
    { QMI_WDS_IP_SUPPORT_TYPE_IPV4, "QMI_WDS_IP_SUPPORT_TYPE_IPV4", "ipv4" },
    { QMI_WDS_IP_SUPPORT_TYPE_IPV6, "QMI_WDS_IP_SUPPORT_TYPE_IPV6", "ipv6" },
    { QMI_WDS_IP_SUPPORT_TYPE_IPV4V6, "QMI_WDS_IP_SUPPORT_TYPE_IPV4V6", "ipv4v6" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wds_ip_support_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWdsIpSupportType"),
                                      qmi_wds_ip_support_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WDS_IP_SUPPORT_TYPE_IS_ENUM__
const gchar *
qmi_wds_ip_support_type_get_string (QmiWdsIpSupportType val)
{
    guint i;

    for (i = 0; qmi_wds_ip_support_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wds_ip_support_type_values[i].value)
            return qmi_wds_ip_support_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WDS_IP_SUPPORT_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WDS_IP_SUPPORT_TYPE_IS_FLAGS__
gchar *
qmi_wds_ip_support_type_build_string_from_mask (QmiWdsIpSupportType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wds_ip_support_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wds_ip_support_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wds_ip_support_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wds_ip_support_type_values[i].value) {
            guint c;
            gulong number = qmi_wds_ip_support_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wds_ip_support_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WDS_IP_SUPPORT_TYPE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums-wms.h" */
static const GEnumValue qmi_wms_storage_type_values[] = {
    { QMI_WMS_STORAGE_TYPE_UIM, "QMI_WMS_STORAGE_TYPE_UIM", "uim" },
    { QMI_WMS_STORAGE_TYPE_NV, "QMI_WMS_STORAGE_TYPE_NV", "nv" },
    { QMI_WMS_STORAGE_TYPE_NONE, "QMI_WMS_STORAGE_TYPE_NONE", "none" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_storage_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsStorageType"),
                                      qmi_wms_storage_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_STORAGE_TYPE_IS_ENUM__
const gchar *
qmi_wms_storage_type_get_string (QmiWmsStorageType val)
{
    guint i;

    for (i = 0; qmi_wms_storage_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_storage_type_values[i].value)
            return qmi_wms_storage_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_STORAGE_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_STORAGE_TYPE_IS_FLAGS__
gchar *
qmi_wms_storage_type_build_string_from_mask (QmiWmsStorageType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_storage_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_storage_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_storage_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_storage_type_values[i].value) {
            guint c;
            gulong number = qmi_wms_storage_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_storage_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_STORAGE_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wms_ack_indicator_values[] = {
    { QMI_WMS_ACK_INDICATOR_SEND, "QMI_WMS_ACK_INDICATOR_SEND", "send" },
    { QMI_WMS_ACK_INDICATOR_DO_NOT_SEND, "QMI_WMS_ACK_INDICATOR_DO_NOT_SEND", "do-not-send" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_ack_indicator_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsAckIndicator"),
                                      qmi_wms_ack_indicator_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_ACK_INDICATOR_IS_ENUM__
const gchar *
qmi_wms_ack_indicator_get_string (QmiWmsAckIndicator val)
{
    guint i;

    for (i = 0; qmi_wms_ack_indicator_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_ack_indicator_values[i].value)
            return qmi_wms_ack_indicator_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_ACK_INDICATOR_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_ACK_INDICATOR_IS_FLAGS__
gchar *
qmi_wms_ack_indicator_build_string_from_mask (QmiWmsAckIndicator mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_ack_indicator_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_ack_indicator_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_ack_indicator_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_ack_indicator_values[i].value) {
            guint c;
            gulong number = qmi_wms_ack_indicator_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_ack_indicator_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_ACK_INDICATOR_IS_FLAGS__ */
static const GEnumValue qmi_wms_message_format_values[] = {
    { QMI_WMS_MESSAGE_FORMAT_CDMA, "QMI_WMS_MESSAGE_FORMAT_CDMA", "cdma" },
    { QMI_WMS_MESSAGE_FORMAT_GSM_WCDMA_POINT_TO_POINT, "QMI_WMS_MESSAGE_FORMAT_GSM_WCDMA_POINT_TO_POINT", "gsm-wcdma-point-to-point" },
    { QMI_WMS_MESSAGE_FORMAT_GSM_WCDMA_BROADCAST, "QMI_WMS_MESSAGE_FORMAT_GSM_WCDMA_BROADCAST", "gsm-wcdma-broadcast" },
    { QMI_WMS_MESSAGE_FORMAT_MWI, "QMI_WMS_MESSAGE_FORMAT_MWI", "mwi" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_message_format_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsMessageFormat"),
                                      qmi_wms_message_format_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_MESSAGE_FORMAT_IS_ENUM__
const gchar *
qmi_wms_message_format_get_string (QmiWmsMessageFormat val)
{
    guint i;

    for (i = 0; qmi_wms_message_format_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_message_format_values[i].value)
            return qmi_wms_message_format_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_MESSAGE_FORMAT_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_MESSAGE_FORMAT_IS_FLAGS__
gchar *
qmi_wms_message_format_build_string_from_mask (QmiWmsMessageFormat mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_message_format_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_message_format_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_message_format_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_message_format_values[i].value) {
            guint c;
            gulong number = qmi_wms_message_format_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_message_format_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_MESSAGE_FORMAT_IS_FLAGS__ */
static const GEnumValue qmi_wms_message_mode_values[] = {
    { QMI_WMS_MESSAGE_MODE_CDMA, "QMI_WMS_MESSAGE_MODE_CDMA", "cdma" },
    { QMI_WMS_MESSAGE_MODE_GSM_WCDMA, "QMI_WMS_MESSAGE_MODE_GSM_WCDMA", "gsm-wcdma" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_message_mode_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsMessageMode"),
                                      qmi_wms_message_mode_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_MESSAGE_MODE_IS_ENUM__
const gchar *
qmi_wms_message_mode_get_string (QmiWmsMessageMode val)
{
    guint i;

    for (i = 0; qmi_wms_message_mode_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_message_mode_values[i].value)
            return qmi_wms_message_mode_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_MESSAGE_MODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_MESSAGE_MODE_IS_FLAGS__
gchar *
qmi_wms_message_mode_build_string_from_mask (QmiWmsMessageMode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_message_mode_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_message_mode_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_message_mode_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_message_mode_values[i].value) {
            guint c;
            gulong number = qmi_wms_message_mode_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_message_mode_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_MESSAGE_MODE_IS_FLAGS__ */
static const GEnumValue qmi_wms_notification_type_values[] = {
    { QMI_WMS_NOTIFICATION_TYPE_PRIMARY, "QMI_WMS_NOTIFICATION_TYPE_PRIMARY", "primary" },
    { QMI_WMS_NOTIFICATION_TYPE_SECONDARY_GSM, "QMI_WMS_NOTIFICATION_TYPE_SECONDARY_GSM", "secondary-gsm" },
    { QMI_WMS_NOTIFICATION_TYPE_SECONDARY_UMTS, "QMI_WMS_NOTIFICATION_TYPE_SECONDARY_UMTS", "secondary-umts" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_notification_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsNotificationType"),
                                      qmi_wms_notification_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_NOTIFICATION_TYPE_IS_ENUM__
const gchar *
qmi_wms_notification_type_get_string (QmiWmsNotificationType val)
{
    guint i;

    for (i = 0; qmi_wms_notification_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_notification_type_values[i].value)
            return qmi_wms_notification_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_NOTIFICATION_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_NOTIFICATION_TYPE_IS_FLAGS__
gchar *
qmi_wms_notification_type_build_string_from_mask (QmiWmsNotificationType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_notification_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_notification_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_notification_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_notification_type_values[i].value) {
            guint c;
            gulong number = qmi_wms_notification_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_notification_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_NOTIFICATION_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wms_cdma_service_option_values[] = {
    { QMI_WMS_CDMA_SERVICE_OPTION_AUTO, "QMI_WMS_CDMA_SERVICE_OPTION_AUTO", "auto" },
    { QMI_WMS_CDMA_SERVICE_OPTION_6, "QMI_WMS_CDMA_SERVICE_OPTION_6", "6" },
    { QMI_WMS_CDMA_SERVICE_OPTION_14, "QMI_WMS_CDMA_SERVICE_OPTION_14", "14" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_cdma_service_option_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsCdmaServiceOption"),
                                      qmi_wms_cdma_service_option_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_CDMA_SERVICE_OPTION_IS_ENUM__
const gchar *
qmi_wms_cdma_service_option_get_string (QmiWmsCdmaServiceOption val)
{
    guint i;

    for (i = 0; qmi_wms_cdma_service_option_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_cdma_service_option_values[i].value)
            return qmi_wms_cdma_service_option_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_CDMA_SERVICE_OPTION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_CDMA_SERVICE_OPTION_IS_FLAGS__
gchar *
qmi_wms_cdma_service_option_build_string_from_mask (QmiWmsCdmaServiceOption mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_cdma_service_option_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_cdma_service_option_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_cdma_service_option_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_cdma_service_option_values[i].value) {
            guint c;
            gulong number = qmi_wms_cdma_service_option_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_cdma_service_option_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_CDMA_SERVICE_OPTION_IS_FLAGS__ */
static const GEnumValue qmi_wms_cdma_cause_code_values[] = {
    { QMI_WMS_CDMA_CAUSE_CODE_NETWORK_ADDRESS_VACANT, "QMI_WMS_CDMA_CAUSE_CODE_NETWORK_ADDRESS_VACANT", "network-address-vacant" },
    { QMI_WMS_CDMA_CAUSE_CODE_NETWORK_ADDRESS_TRANSLATION_FAILURE, "QMI_WMS_CDMA_CAUSE_CODE_NETWORK_ADDRESS_TRANSLATION_FAILURE", "network-address-translation-failure" },
    { QMI_WMS_CDMA_CAUSE_CODE_NETWORK_RESOURCE_SHORTAGE, "QMI_WMS_CDMA_CAUSE_CODE_NETWORK_RESOURCE_SHORTAGE", "network-resource-shortage" },
    { QMI_WMS_CDMA_CAUSE_CODE_NETWORK_FAILURE, "QMI_WMS_CDMA_CAUSE_CODE_NETWORK_FAILURE", "network-failure" },
    { QMI_WMS_CDMA_CAUSE_CODE_NETWORK_INVALID_TELESERVICE_ID, "QMI_WMS_CDMA_CAUSE_CODE_NETWORK_INVALID_TELESERVICE_ID", "network-invalid-teleservice-id" },
    { QMI_WMS_CDMA_CAUSE_CODE_NETWORK_OTHER, "QMI_WMS_CDMA_CAUSE_CODE_NETWORK_OTHER", "network-other" },
    { QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_NO_PAGE_RESPONSE, "QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_NO_PAGE_RESPONSE", "destination-no-page-response" },
    { QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_BUSY, "QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_BUSY", "destination-busy" },
    { QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_NO_ACK, "QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_NO_ACK", "destination-no-ack" },
    { QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_RESOURCE_SHORTAGE, "QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_RESOURCE_SHORTAGE", "destination-resource-shortage" },
    { QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_SMS_DELIVERY_POSTPONED, "QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_SMS_DELIVERY_POSTPONED", "destination-sms-delivery-postponed" },
    { QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_OUT_OF_SERVICE, "QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_OUT_OF_SERVICE", "destination-out-of-service" },
    { QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_NOT_AT_ADDRESS, "QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_NOT_AT_ADDRESS", "destination-not-at-address" },
    { QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_OTHER, "QMI_WMS_CDMA_CAUSE_CODE_DESTINATION_OTHER", "destination-other" },
    { QMI_WMS_CDMA_CAUSE_CODE_RADIO_INTERFACE_RESOURCE_SHORTAGE, "QMI_WMS_CDMA_CAUSE_CODE_RADIO_INTERFACE_RESOURCE_SHORTAGE", "radio-interface-resource-shortage" },
    { QMI_WMS_CDMA_CAUSE_CODE_RADIO_INTERFACE_INCOMPATIBILITY, "QMI_WMS_CDMA_CAUSE_CODE_RADIO_INTERFACE_INCOMPATIBILITY", "radio-interface-incompatibility" },
    { QMI_WMS_CDMA_CAUSE_CODE_RADIO_INTERFACE_OTHER, "QMI_WMS_CDMA_CAUSE_CODE_RADIO_INTERFACE_OTHER", "radio-interface-other" },
    { QMI_WMS_CDMA_CAUSE_CODE_GENERAL_ENCODING, "QMI_WMS_CDMA_CAUSE_CODE_GENERAL_ENCODING", "general-encoding" },
    { QMI_WMS_CDMA_CAUSE_CODE_GENERAL_SMS_ORIGIN_DENIED, "QMI_WMS_CDMA_CAUSE_CODE_GENERAL_SMS_ORIGIN_DENIED", "general-sms-origin-denied" },
    { QMI_WMS_CDMA_CAUSE_CODE_GENERAL_SMS_DESTINATION_DENIED, "QMI_WMS_CDMA_CAUSE_CODE_GENERAL_SMS_DESTINATION_DENIED", "general-sms-destination-denied" },
    { QMI_WMS_CDMA_CAUSE_CODE_GENERAL_SUPPLEMENTARY_SERVICE_NOT_SUPPORTED, "QMI_WMS_CDMA_CAUSE_CODE_GENERAL_SUPPLEMENTARY_SERVICE_NOT_SUPPORTED", "general-supplementary-service-not-supported" },
    { QMI_WMS_CDMA_CAUSE_CODE_GENERAL_SMS_NOT_SUPPORTED, "QMI_WMS_CDMA_CAUSE_CODE_GENERAL_SMS_NOT_SUPPORTED", "general-sms-not-supported" },
    { QMI_WMS_CDMA_CAUSE_CODE_GENERAL_MISSING_EXPECTED_PARAMETER, "QMI_WMS_CDMA_CAUSE_CODE_GENERAL_MISSING_EXPECTED_PARAMETER", "general-missing-expected-parameter" },
    { QMI_WMS_CDMA_CAUSE_CODE_GENERAL_MISSING_MANDATORY_PARAMETER, "QMI_WMS_CDMA_CAUSE_CODE_GENERAL_MISSING_MANDATORY_PARAMETER", "general-missing-mandatory-parameter" },
    { QMI_WMS_CDMA_CAUSE_CODE_GENERAL_UNRECOGNIZED_PARAMETER_VALUE, "QMI_WMS_CDMA_CAUSE_CODE_GENERAL_UNRECOGNIZED_PARAMETER_VALUE", "general-unrecognized-parameter-value" },
    { QMI_WMS_CDMA_CAUSE_CODE_GENERAL_UNEXPECTED_PARAMETER_VALUE, "QMI_WMS_CDMA_CAUSE_CODE_GENERAL_UNEXPECTED_PARAMETER_VALUE", "general-unexpected-parameter-value" },
    { QMI_WMS_CDMA_CAUSE_CODE_GENERAL_USER_DATA_SIZE_ERROR, "QMI_WMS_CDMA_CAUSE_CODE_GENERAL_USER_DATA_SIZE_ERROR", "general-user-data-size-error" },
    { QMI_WMS_CDMA_CAUSE_CODE_GENERAL_OTHER, "QMI_WMS_CDMA_CAUSE_CODE_GENERAL_OTHER", "general-other" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_cdma_cause_code_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsCdmaCauseCode"),
                                      qmi_wms_cdma_cause_code_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_CDMA_CAUSE_CODE_IS_ENUM__
const gchar *
qmi_wms_cdma_cause_code_get_string (QmiWmsCdmaCauseCode val)
{
    guint i;

    for (i = 0; qmi_wms_cdma_cause_code_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_cdma_cause_code_values[i].value)
            return qmi_wms_cdma_cause_code_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_CDMA_CAUSE_CODE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_CDMA_CAUSE_CODE_IS_FLAGS__
gchar *
qmi_wms_cdma_cause_code_build_string_from_mask (QmiWmsCdmaCauseCode mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_cdma_cause_code_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_cdma_cause_code_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_cdma_cause_code_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_cdma_cause_code_values[i].value) {
            guint c;
            gulong number = qmi_wms_cdma_cause_code_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_cdma_cause_code_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_CDMA_CAUSE_CODE_IS_FLAGS__ */
static const GEnumValue qmi_wms_cdma_error_class_values[] = {
    { QMI_WMS_CDMA_ERROR_CLASS_TEMPORARY, "QMI_WMS_CDMA_ERROR_CLASS_TEMPORARY", "temporary" },
    { QMI_WMS_CDMA_ERROR_CLASS_PERMANENT, "QMI_WMS_CDMA_ERROR_CLASS_PERMANENT", "permanent" },
    { QMI_WMS_CDMA_ERROR_CLASS_TEMPORARY_DEVICE, "QMI_WMS_CDMA_ERROR_CLASS_TEMPORARY_DEVICE", "temporary-device" },
    { QMI_WMS_CDMA_ERROR_CLASS_PERMANENT_DEVICE, "QMI_WMS_CDMA_ERROR_CLASS_PERMANENT_DEVICE", "permanent-device" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_cdma_error_class_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsCdmaErrorClass"),
                                      qmi_wms_cdma_error_class_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_CDMA_ERROR_CLASS_IS_ENUM__
const gchar *
qmi_wms_cdma_error_class_get_string (QmiWmsCdmaErrorClass val)
{
    guint i;

    for (i = 0; qmi_wms_cdma_error_class_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_cdma_error_class_values[i].value)
            return qmi_wms_cdma_error_class_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_CDMA_ERROR_CLASS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_CDMA_ERROR_CLASS_IS_FLAGS__
gchar *
qmi_wms_cdma_error_class_build_string_from_mask (QmiWmsCdmaErrorClass mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_cdma_error_class_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_cdma_error_class_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_cdma_error_class_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_cdma_error_class_values[i].value) {
            guint c;
            gulong number = qmi_wms_cdma_error_class_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_cdma_error_class_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_CDMA_ERROR_CLASS_IS_FLAGS__ */
static const GEnumValue qmi_wms_gsm_umts_rp_cause_values[] = {
    { QMI_WMS_GSM_UMTS_RP_CAUSE_UNASSIGNED_NUMBER, "QMI_WMS_GSM_UMTS_RP_CAUSE_UNASSIGNED_NUMBER", "unassigned-number" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_OPERATOR_DETERMINED_BARRING, "QMI_WMS_GSM_UMTS_RP_CAUSE_OPERATOR_DETERMINED_BARRING", "operator-determined-barring" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_CALL_BARRED, "QMI_WMS_GSM_UMTS_RP_CAUSE_CALL_BARRED", "call-barred" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_RESERVED, "QMI_WMS_GSM_UMTS_RP_CAUSE_RESERVED", "reserved" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_SMS_TRANSFER_REJECTED, "QMI_WMS_GSM_UMTS_RP_CAUSE_SMS_TRANSFER_REJECTED", "sms-transfer-rejected" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_MEMORY_CAPACITY_EXCEEDED, "QMI_WMS_GSM_UMTS_RP_CAUSE_MEMORY_CAPACITY_EXCEEDED", "memory-capacity-exceeded" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_DESTINATION_OUT_OF_ORDER, "QMI_WMS_GSM_UMTS_RP_CAUSE_DESTINATION_OUT_OF_ORDER", "destination-out-of-order" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_UNIDENTIFIED_SUBSCRIBER, "QMI_WMS_GSM_UMTS_RP_CAUSE_UNIDENTIFIED_SUBSCRIBER", "unidentified-subscriber" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_FACILITY_REJECTED, "QMI_WMS_GSM_UMTS_RP_CAUSE_FACILITY_REJECTED", "facility-rejected" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_UNKNOWN_SUBSCRIBER, "QMI_WMS_GSM_UMTS_RP_CAUSE_UNKNOWN_SUBSCRIBER", "unknown-subscriber" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_NETWORK_OUF_OF_ORDER, "QMI_WMS_GSM_UMTS_RP_CAUSE_NETWORK_OUF_OF_ORDER", "network-ouf-of-order" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_TEMPORARY_FAILURE, "QMI_WMS_GSM_UMTS_RP_CAUSE_TEMPORARY_FAILURE", "temporary-failure" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_CONGESTION, "QMI_WMS_GSM_UMTS_RP_CAUSE_CONGESTION", "congestion" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_RESOURCES_UNAVAILABLE, "QMI_WMS_GSM_UMTS_RP_CAUSE_RESOURCES_UNAVAILABLE", "resources-unavailable" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_FACILITY_NOT_SUBSCRIBED, "QMI_WMS_GSM_UMTS_RP_CAUSE_FACILITY_NOT_SUBSCRIBED", "facility-not-subscribed" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_FACILITY_NOT_IMPLEMENTED, "QMI_WMS_GSM_UMTS_RP_CAUSE_FACILITY_NOT_IMPLEMENTED", "facility-not-implemented" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_INVALID_SMS_TRANSFER_REFERENCE_VALUE, "QMI_WMS_GSM_UMTS_RP_CAUSE_INVALID_SMS_TRANSFER_REFERENCE_VALUE", "invalid-sms-transfer-reference-value" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_SEMANTICALLY_INCORRECT_MESSAGE, "QMI_WMS_GSM_UMTS_RP_CAUSE_SEMANTICALLY_INCORRECT_MESSAGE", "semantically-incorrect-message" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_INVALID_MANDATORY_INFO, "QMI_WMS_GSM_UMTS_RP_CAUSE_INVALID_MANDATORY_INFO", "invalid-mandatory-info" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_MESSAGE_TYPE_NOT_IMPLEMENTED, "QMI_WMS_GSM_UMTS_RP_CAUSE_MESSAGE_TYPE_NOT_IMPLEMENTED", "message-type-not-implemented" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_MESSAGE_NOT_COMPATIBLE_WITH_SMS, "QMI_WMS_GSM_UMTS_RP_CAUSE_MESSAGE_NOT_COMPATIBLE_WITH_SMS", "message-not-compatible-with-sms" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_INFORMATION_ELEMENT_NOT_IMPLEMENTED, "QMI_WMS_GSM_UMTS_RP_CAUSE_INFORMATION_ELEMENT_NOT_IMPLEMENTED", "information-element-not-implemented" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_PROTOCOL_ERROR, "QMI_WMS_GSM_UMTS_RP_CAUSE_PROTOCOL_ERROR", "protocol-error" },
    { QMI_WMS_GSM_UMTS_RP_CAUSE_INTERWORKING, "QMI_WMS_GSM_UMTS_RP_CAUSE_INTERWORKING", "interworking" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_gsm_umts_rp_cause_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsGsmUmtsRpCause"),
                                      qmi_wms_gsm_umts_rp_cause_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_GSM_UMTS_RP_CAUSE_IS_ENUM__
const gchar *
qmi_wms_gsm_umts_rp_cause_get_string (QmiWmsGsmUmtsRpCause val)
{
    guint i;

    for (i = 0; qmi_wms_gsm_umts_rp_cause_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_gsm_umts_rp_cause_values[i].value)
            return qmi_wms_gsm_umts_rp_cause_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_GSM_UMTS_RP_CAUSE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_GSM_UMTS_RP_CAUSE_IS_FLAGS__
gchar *
qmi_wms_gsm_umts_rp_cause_build_string_from_mask (QmiWmsGsmUmtsRpCause mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_gsm_umts_rp_cause_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_gsm_umts_rp_cause_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_gsm_umts_rp_cause_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_gsm_umts_rp_cause_values[i].value) {
            guint c;
            gulong number = qmi_wms_gsm_umts_rp_cause_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_gsm_umts_rp_cause_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_GSM_UMTS_RP_CAUSE_IS_FLAGS__ */
static const GEnumValue qmi_wms_gsm_umts_tp_cause_values[] = {
    { QMI_WMS_GSM_UMTS_TP_CAUSE_TELE_INTERWORKING_NOT_SUPPORTED, "QMI_WMS_GSM_UMTS_TP_CAUSE_TELE_INTERWORKING_NOT_SUPPORTED", "tele-interworking-not-supported" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_SHORT_MESSAGE_TYPE_0_NOT_SUPPORTED, "QMI_WMS_GSM_UMTS_TP_CAUSE_SHORT_MESSAGE_TYPE_0_NOT_SUPPORTED", "short-message-type-0-not-supported" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_SHORT_MESSAGE_CANNOT_BE_REPLACED, "QMI_WMS_GSM_UMTS_TP_CAUSE_SHORT_MESSAGE_CANNOT_BE_REPLACED", "short-message-cannot-be-replaced" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_UNSPECIFIED_PID_ERROR, "QMI_WMS_GSM_UMTS_TP_CAUSE_UNSPECIFIED_PID_ERROR", "unspecified-pid-error" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_DCS_NOT_SUPPORTED, "QMI_WMS_GSM_UMTS_TP_CAUSE_DCS_NOT_SUPPORTED", "dcs-not-supported" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_MESSAGE_CLASS_NOT_SUPPORTED, "QMI_WMS_GSM_UMTS_TP_CAUSE_MESSAGE_CLASS_NOT_SUPPORTED", "message-class-not-supported" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_UNSPECIFIED_DCS_ERROR, "QMI_WMS_GSM_UMTS_TP_CAUSE_UNSPECIFIED_DCS_ERROR", "unspecified-dcs-error" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_COMMAND_CANNOT_BE_ACTIONED, "QMI_WMS_GSM_UMTS_TP_CAUSE_COMMAND_CANNOT_BE_ACTIONED", "command-cannot-be-actioned" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_COMMAND_UNSUPPORTED, "QMI_WMS_GSM_UMTS_TP_CAUSE_COMMAND_UNSUPPORTED", "command-unsupported" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_UNSPECIFIED_COMMAND_ERROR, "QMI_WMS_GSM_UMTS_TP_CAUSE_UNSPECIFIED_COMMAND_ERROR", "unspecified-command-error" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_TPDU_NOT_SUPPORTED, "QMI_WMS_GSM_UMTS_TP_CAUSE_TPDU_NOT_SUPPORTED", "tpdu-not-supported" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_SC_BUSY, "QMI_WMS_GSM_UMTS_TP_CAUSE_SC_BUSY", "sc-busy" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_NO_SC_SUBSCRIPTION, "QMI_WMS_GSM_UMTS_TP_CAUSE_NO_SC_SUBSCRIPTION", "no-sc-subscription" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_SC_SYSTEM_FAILURE, "QMI_WMS_GSM_UMTS_TP_CAUSE_SC_SYSTEM_FAILURE", "sc-system-failure" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_INVALID_SME_ADDRESS, "QMI_WMS_GSM_UMTS_TP_CAUSE_INVALID_SME_ADDRESS", "invalid-sme-address" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_DESTINATION_SME_BARRED, "QMI_WMS_GSM_UMTS_TP_CAUSE_DESTINATION_SME_BARRED", "destination-sme-barred" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_SM_REJECTED_OR_DUPLICATE, "QMI_WMS_GSM_UMTS_TP_CAUSE_SM_REJECTED_OR_DUPLICATE", "sm-rejected-or-duplicate" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_VPF_NOT_SUPPORTED, "QMI_WMS_GSM_UMTS_TP_CAUSE_VPF_NOT_SUPPORTED", "vpf-not-supported" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_VP_NOT_SUPPORTED, "QMI_WMS_GSM_UMTS_TP_CAUSE_VP_NOT_SUPPORTED", "vp-not-supported" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_SIM_SMS_STORAGE_FULL, "QMI_WMS_GSM_UMTS_TP_CAUSE_SIM_SMS_STORAGE_FULL", "sim-sms-storage-full" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_NO_SMS_STORAGE_CAPABILITY_IN_SIM, "QMI_WMS_GSM_UMTS_TP_CAUSE_NO_SMS_STORAGE_CAPABILITY_IN_SIM", "no-sms-storage-capability-in-sim" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_MS_ERROR, "QMI_WMS_GSM_UMTS_TP_CAUSE_MS_ERROR", "ms-error" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_MEMORY_CAPACITY_EXCEEDED, "QMI_WMS_GSM_UMTS_TP_CAUSE_MEMORY_CAPACITY_EXCEEDED", "memory-capacity-exceeded" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_SIM_APPLICATION_TOOLKIT_BUSY, "QMI_WMS_GSM_UMTS_TP_CAUSE_SIM_APPLICATION_TOOLKIT_BUSY", "sim-application-toolkit-busy" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_SIM_DATA_DOWNLOAD_ERROR, "QMI_WMS_GSM_UMTS_TP_CAUSE_SIM_DATA_DOWNLOAD_ERROR", "sim-data-download-error" },
    { QMI_WMS_GSM_UMTS_TP_CAUSE_UNSPECIFIED_ERROR, "QMI_WMS_GSM_UMTS_TP_CAUSE_UNSPECIFIED_ERROR", "unspecified-error" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_gsm_umts_tp_cause_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsGsmUmtsTpCause"),
                                      qmi_wms_gsm_umts_tp_cause_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_GSM_UMTS_TP_CAUSE_IS_ENUM__
const gchar *
qmi_wms_gsm_umts_tp_cause_get_string (QmiWmsGsmUmtsTpCause val)
{
    guint i;

    for (i = 0; qmi_wms_gsm_umts_tp_cause_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_gsm_umts_tp_cause_values[i].value)
            return qmi_wms_gsm_umts_tp_cause_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_GSM_UMTS_TP_CAUSE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_GSM_UMTS_TP_CAUSE_IS_FLAGS__
gchar *
qmi_wms_gsm_umts_tp_cause_build_string_from_mask (QmiWmsGsmUmtsTpCause mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_gsm_umts_tp_cause_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_gsm_umts_tp_cause_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_gsm_umts_tp_cause_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_gsm_umts_tp_cause_values[i].value) {
            guint c;
            gulong number = qmi_wms_gsm_umts_tp_cause_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_gsm_umts_tp_cause_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_GSM_UMTS_TP_CAUSE_IS_FLAGS__ */
static const GEnumValue qmi_wms_message_delivery_failure_type_values[] = {
    { QMI_WMS_MESSAGE_DELIVERY_FAILURE_TYPE_TEMPORARY, "QMI_WMS_MESSAGE_DELIVERY_FAILURE_TYPE_TEMPORARY", "temporary" },
    { QMI_WMS_MESSAGE_DELIVERY_FAILURE_TYPE_PERMANENT, "QMI_WMS_MESSAGE_DELIVERY_FAILURE_TYPE_PERMANENT", "permanent" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_message_delivery_failure_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsMessageDeliveryFailureType"),
                                      qmi_wms_message_delivery_failure_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_MESSAGE_DELIVERY_FAILURE_TYPE_IS_ENUM__
const gchar *
qmi_wms_message_delivery_failure_type_get_string (QmiWmsMessageDeliveryFailureType val)
{
    guint i;

    for (i = 0; qmi_wms_message_delivery_failure_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_message_delivery_failure_type_values[i].value)
            return qmi_wms_message_delivery_failure_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_MESSAGE_DELIVERY_FAILURE_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_MESSAGE_DELIVERY_FAILURE_TYPE_IS_FLAGS__
gchar *
qmi_wms_message_delivery_failure_type_build_string_from_mask (QmiWmsMessageDeliveryFailureType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_message_delivery_failure_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_message_delivery_failure_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_message_delivery_failure_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_message_delivery_failure_type_values[i].value) {
            guint c;
            gulong number = qmi_wms_message_delivery_failure_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_message_delivery_failure_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_MESSAGE_DELIVERY_FAILURE_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wms_message_tag_type_values[] = {
    { QMI_WMS_MESSAGE_TAG_TYPE_MT_READ, "QMI_WMS_MESSAGE_TAG_TYPE_MT_READ", "mt-read" },
    { QMI_WMS_MESSAGE_TAG_TYPE_MT_NOT_READ, "QMI_WMS_MESSAGE_TAG_TYPE_MT_NOT_READ", "mt-not-read" },
    { QMI_WMS_MESSAGE_TAG_TYPE_MO_SENT, "QMI_WMS_MESSAGE_TAG_TYPE_MO_SENT", "mo-sent" },
    { QMI_WMS_MESSAGE_TAG_TYPE_MO_NOT_SENT, "QMI_WMS_MESSAGE_TAG_TYPE_MO_NOT_SENT", "mo-not-sent" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_message_tag_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsMessageTagType"),
                                      qmi_wms_message_tag_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_MESSAGE_TAG_TYPE_IS_ENUM__
const gchar *
qmi_wms_message_tag_type_get_string (QmiWmsMessageTagType val)
{
    guint i;

    for (i = 0; qmi_wms_message_tag_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_message_tag_type_values[i].value)
            return qmi_wms_message_tag_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_MESSAGE_TAG_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_MESSAGE_TAG_TYPE_IS_FLAGS__
gchar *
qmi_wms_message_tag_type_build_string_from_mask (QmiWmsMessageTagType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_message_tag_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_message_tag_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_message_tag_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_message_tag_type_values[i].value) {
            guint c;
            gulong number = qmi_wms_message_tag_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_message_tag_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_MESSAGE_TAG_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wms_message_protocol_values[] = {
    { QMI_WMS_MESSAGE_PROTOCOL_CDMA, "QMI_WMS_MESSAGE_PROTOCOL_CDMA", "cdma" },
    { QMI_WMS_MESSAGE_PROTOCOL_WCDMA, "QMI_WMS_MESSAGE_PROTOCOL_WCDMA", "wcdma" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_message_protocol_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsMessageProtocol"),
                                      qmi_wms_message_protocol_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_MESSAGE_PROTOCOL_IS_ENUM__
const gchar *
qmi_wms_message_protocol_get_string (QmiWmsMessageProtocol val)
{
    guint i;

    for (i = 0; qmi_wms_message_protocol_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_message_protocol_values[i].value)
            return qmi_wms_message_protocol_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_MESSAGE_PROTOCOL_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_MESSAGE_PROTOCOL_IS_FLAGS__
gchar *
qmi_wms_message_protocol_build_string_from_mask (QmiWmsMessageProtocol mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_message_protocol_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_message_protocol_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_message_protocol_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_message_protocol_values[i].value) {
            guint c;
            gulong number = qmi_wms_message_protocol_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_message_protocol_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_MESSAGE_PROTOCOL_IS_FLAGS__ */
static const GEnumValue qmi_wms_message_type_values[] = {
    { QMI_WMS_MESSAGE_TYPE_POINT_TO_POINT, "QMI_WMS_MESSAGE_TYPE_POINT_TO_POINT", "point" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_message_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsMessageType"),
                                      qmi_wms_message_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_MESSAGE_TYPE_IS_ENUM__
const gchar *
qmi_wms_message_type_get_string (QmiWmsMessageType val)
{
    guint i;

    for (i = 0; qmi_wms_message_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_message_type_values[i].value)
            return qmi_wms_message_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_MESSAGE_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_MESSAGE_TYPE_IS_FLAGS__
gchar *
qmi_wms_message_type_build_string_from_mask (QmiWmsMessageType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_message_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_message_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_message_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_message_type_values[i].value) {
            guint c;
            gulong number = qmi_wms_message_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_message_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_MESSAGE_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_wms_message_class_values[] = {
    { QMI_WMS_MESSAGE_CLASS_0, "QMI_WMS_MESSAGE_CLASS_0", "0" },
    { QMI_WMS_MESSAGE_CLASS_1, "QMI_WMS_MESSAGE_CLASS_1", "1" },
    { QMI_WMS_MESSAGE_CLASS_2, "QMI_WMS_MESSAGE_CLASS_2", "2" },
    { QMI_WMS_MESSAGE_CLASS_3, "QMI_WMS_MESSAGE_CLASS_3", "3" },
    { QMI_WMS_MESSAGE_CLASS_NONE, "QMI_WMS_MESSAGE_CLASS_NONE", "none" },
    { QMI_WMS_MESSAGE_CLASS_CDMA, "QMI_WMS_MESSAGE_CLASS_CDMA", "cdma" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_message_class_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsMessageClass"),
                                      qmi_wms_message_class_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_MESSAGE_CLASS_IS_ENUM__
const gchar *
qmi_wms_message_class_get_string (QmiWmsMessageClass val)
{
    guint i;

    for (i = 0; qmi_wms_message_class_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_message_class_values[i].value)
            return qmi_wms_message_class_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_MESSAGE_CLASS_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_MESSAGE_CLASS_IS_FLAGS__
gchar *
qmi_wms_message_class_build_string_from_mask (QmiWmsMessageClass mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_message_class_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_message_class_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_message_class_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_message_class_values[i].value) {
            guint c;
            gulong number = qmi_wms_message_class_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_message_class_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_MESSAGE_CLASS_IS_FLAGS__ */
static const GEnumValue qmi_wms_receipt_action_values[] = {
    { QMI_WMS_RECEIPT_ACTION_DISCARD, "QMI_WMS_RECEIPT_ACTION_DISCARD", "discard" },
    { QMI_WMS_RECEIPT_ACTION_STORE_AND_NOTIFY, "QMI_WMS_RECEIPT_ACTION_STORE_AND_NOTIFY", "store-and-notify" },
    { QMI_WMS_RECEIPT_ACTION_TRANSFER_ONLY, "QMI_WMS_RECEIPT_ACTION_TRANSFER_ONLY", "transfer-only" },
    { QMI_WMS_RECEIPT_ACTION_TRANSFER_AND_ACK, "QMI_WMS_RECEIPT_ACTION_TRANSFER_AND_ACK", "transfer-and-ack" },
    { QMI_WMS_RECEIPT_ACTION_UNKNOWN, "QMI_WMS_RECEIPT_ACTION_UNKNOWN", "unknown" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_receipt_action_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsReceiptAction"),
                                      qmi_wms_receipt_action_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_RECEIPT_ACTION_IS_ENUM__
const gchar *
qmi_wms_receipt_action_get_string (QmiWmsReceiptAction val)
{
    guint i;

    for (i = 0; qmi_wms_receipt_action_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_receipt_action_values[i].value)
            return qmi_wms_receipt_action_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_RECEIPT_ACTION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_RECEIPT_ACTION_IS_FLAGS__
gchar *
qmi_wms_receipt_action_build_string_from_mask (QmiWmsReceiptAction mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_receipt_action_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_receipt_action_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_receipt_action_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_receipt_action_values[i].value) {
            guint c;
            gulong number = qmi_wms_receipt_action_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_receipt_action_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_RECEIPT_ACTION_IS_FLAGS__ */
static const GEnumValue qmi_wms_transfer_indication_values[] = {
    { QMI_WMS_TRANSFER_INDICATION_CLIENT, "QMI_WMS_TRANSFER_INDICATION_CLIENT", "client" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_transfer_indication_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsTransferIndication"),
                                      qmi_wms_transfer_indication_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_TRANSFER_INDICATION_IS_ENUM__
const gchar *
qmi_wms_transfer_indication_get_string (QmiWmsTransferIndication val)
{
    guint i;

    for (i = 0; qmi_wms_transfer_indication_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_transfer_indication_values[i].value)
            return qmi_wms_transfer_indication_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_TRANSFER_INDICATION_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_TRANSFER_INDICATION_IS_FLAGS__
gchar *
qmi_wms_transfer_indication_build_string_from_mask (QmiWmsTransferIndication mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_transfer_indication_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_transfer_indication_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_transfer_indication_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_transfer_indication_values[i].value) {
            guint c;
            gulong number = qmi_wms_transfer_indication_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_transfer_indication_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_TRANSFER_INDICATION_IS_FLAGS__ */
static const GEnumValue qmi_wms_ack_failure_cause_values[] = {
    { QMI_WMS_ACK_FAILURE_CAUSE_NO_NETWORK_RESPONSE, "QMI_WMS_ACK_FAILURE_CAUSE_NO_NETWORK_RESPONSE", "no-network-response" },
    { QMI_WMS_ACK_FAILURE_CAUSE_NETWORK_RELEASED_LINK, "QMI_WMS_ACK_FAILURE_CAUSE_NETWORK_RELEASED_LINK", "network-released-link" },
    { QMI_WMS_ACK_FAILURE_CAUSE_NOT_SENT, "QMI_WMS_ACK_FAILURE_CAUSE_NOT_SENT", "not-sent" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_wms_ack_failure_cause_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiWmsAckFailureCause"),
                                      qmi_wms_ack_failure_cause_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_WMS_ACK_FAILURE_CAUSE_IS_ENUM__
const gchar *
qmi_wms_ack_failure_cause_get_string (QmiWmsAckFailureCause val)
{
    guint i;

    for (i = 0; qmi_wms_ack_failure_cause_values[i].value_nick; i++) {
      if ((gint)val == qmi_wms_ack_failure_cause_values[i].value)
            return qmi_wms_ack_failure_cause_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_WMS_ACK_FAILURE_CAUSE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_WMS_ACK_FAILURE_CAUSE_IS_FLAGS__
gchar *
qmi_wms_ack_failure_cause_build_string_from_mask (QmiWmsAckFailureCause mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_wms_ack_failure_cause_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_wms_ack_failure_cause_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_wms_ack_failure_cause_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_wms_ack_failure_cause_values[i].value) {
            guint c;
            gulong number = qmi_wms_ack_failure_cause_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_wms_ack_failure_cause_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_WMS_ACK_FAILURE_CAUSE_IS_FLAGS__ */
/* enumerations from "../../../src/libqmi-glib/qmi-enums.h" */
static const GEnumValue qmi_service_values[] = {
    { QMI_SERVICE_UNKNOWN, "QMI_SERVICE_UNKNOWN", "unknown" },
    { QMI_SERVICE_CTL, "QMI_SERVICE_CTL", "ctl" },
    { QMI_SERVICE_WDS, "QMI_SERVICE_WDS", "wds" },
    { QMI_SERVICE_DMS, "QMI_SERVICE_DMS", "dms" },
    { QMI_SERVICE_NAS, "QMI_SERVICE_NAS", "nas" },
    { QMI_SERVICE_QOS, "QMI_SERVICE_QOS", "qos" },
    { QMI_SERVICE_WMS, "QMI_SERVICE_WMS", "wms" },
    { QMI_SERVICE_PDS, "QMI_SERVICE_PDS", "pds" },
    { QMI_SERVICE_AUTH, "QMI_SERVICE_AUTH", "auth" },
    { QMI_SERVICE_AT, "QMI_SERVICE_AT", "at" },
    { QMI_SERVICE_VOICE, "QMI_SERVICE_VOICE", "voice" },
    { QMI_SERVICE_CAT2, "QMI_SERVICE_CAT2", "cat2" },
    { QMI_SERVICE_UIM, "QMI_SERVICE_UIM", "uim" },
    { QMI_SERVICE_PBM, "QMI_SERVICE_PBM", "pbm" },
    { QMI_SERVICE_QCHAT, "QMI_SERVICE_QCHAT", "qchat" },
    { QMI_SERVICE_RMTFS, "QMI_SERVICE_RMTFS", "rmtfs" },
    { QMI_SERVICE_TEST, "QMI_SERVICE_TEST", "test" },
    { QMI_SERVICE_LOC, "QMI_SERVICE_LOC", "loc" },
    { QMI_SERVICE_SAR, "QMI_SERVICE_SAR", "sar" },
    { QMI_SERVICE_IMS, "QMI_SERVICE_IMS", "ims" },
    { QMI_SERVICE_ADC, "QMI_SERVICE_ADC", "adc" },
    { QMI_SERVICE_CSD, "QMI_SERVICE_CSD", "csd" },
    { QMI_SERVICE_MFS, "QMI_SERVICE_MFS", "mfs" },
    { QMI_SERVICE_TIME, "QMI_SERVICE_TIME", "time" },
    { QMI_SERVICE_TS, "QMI_SERVICE_TS", "ts" },
    { QMI_SERVICE_TMD, "QMI_SERVICE_TMD", "tmd" },
    { QMI_SERVICE_SAP, "QMI_SERVICE_SAP", "sap" },
    { QMI_SERVICE_WDA, "QMI_SERVICE_WDA", "wda" },
    { QMI_SERVICE_TSYNC, "QMI_SERVICE_TSYNC", "tsync" },
    { QMI_SERVICE_RFSA, "QMI_SERVICE_RFSA", "rfsa" },
    { QMI_SERVICE_CSVT, "QMI_SERVICE_CSVT", "csvt" },
    { QMI_SERVICE_QCMAP, "QMI_SERVICE_QCMAP", "qcmap" },
    { QMI_SERVICE_IMSP, "QMI_SERVICE_IMSP", "imsp" },
    { QMI_SERVICE_IMSVT, "QMI_SERVICE_IMSVT", "imsvt" },
    { QMI_SERVICE_IMSA, "QMI_SERVICE_IMSA", "imsa" },
    { QMI_SERVICE_COEX, "QMI_SERVICE_COEX", "coex" },
    { QMI_SERVICE_PDC, "QMI_SERVICE_PDC", "pdc" },
    { QMI_SERVICE_STX, "QMI_SERVICE_STX", "stx" },
    { QMI_SERVICE_BIT, "QMI_SERVICE_BIT", "bit" },
    { QMI_SERVICE_IMSRTP, "QMI_SERVICE_IMSRTP", "imsrtp" },
    { QMI_SERVICE_RFRPE, "QMI_SERVICE_RFRPE", "rfrpe" },
    { QMI_SERVICE_DSD, "QMI_SERVICE_DSD", "dsd" },
    { QMI_SERVICE_SSCTL, "QMI_SERVICE_SSCTL", "ssctl" },
    { QMI_SERVICE_DPM, "QMI_SERVICE_DPM", "dpm" },
    { QMI_SERVICE_CAT, "QMI_SERVICE_CAT", "cat" },
    { QMI_SERVICE_RMS, "QMI_SERVICE_RMS", "rms" },
    { QMI_SERVICE_OMA, "QMI_SERVICE_OMA", "oma" },
    { QMI_SERVICE_FOTA, "QMI_SERVICE_FOTA", "fota" },
    { QMI_SERVICE_GMS, "QMI_SERVICE_GMS", "gms" },
    { QMI_SERVICE_GAS, "QMI_SERVICE_GAS", "gas" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_service_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiService"),
                                      qmi_service_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_SERVICE_IS_ENUM__
const gchar *
qmi_service_get_string (QmiService val)
{
    guint i;

    for (i = 0; qmi_service_values[i].value_nick; i++) {
      if ((gint)val == qmi_service_values[i].value)
            return qmi_service_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_SERVICE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_SERVICE_IS_FLAGS__
gchar *
qmi_service_build_string_from_mask (QmiService mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_service_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_service_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_service_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_service_values[i].value) {
            guint c;
            gulong number = qmi_service_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_service_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_SERVICE_IS_FLAGS__ */
static const GEnumValue qmi_endian_values[] = {
    { QMI_ENDIAN_LITTLE, "QMI_ENDIAN_LITTLE", "little" },
    { QMI_ENDIAN_BIG, "QMI_ENDIAN_BIG", "big" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_endian_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiEndian"),
                                      qmi_endian_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_ENDIAN_IS_ENUM__
const gchar *
qmi_endian_get_string (QmiEndian val)
{
    guint i;

    for (i = 0; qmi_endian_values[i].value_nick; i++) {
      if ((gint)val == qmi_endian_values[i].value)
            return qmi_endian_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_ENDIAN_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_ENDIAN_IS_FLAGS__
gchar *
qmi_endian_build_string_from_mask (QmiEndian mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_endian_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_endian_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_endian_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_endian_values[i].value) {
            guint c;
            gulong number = qmi_endian_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_endian_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_ENDIAN_IS_FLAGS__ */
static const GEnumValue qmi_data_endpoint_type_values[] = {
    { QMI_DATA_ENDPOINT_TYPE_UNKNOWN, "QMI_DATA_ENDPOINT_TYPE_UNKNOWN", "unknown" },
    { QMI_DATA_ENDPOINT_TYPE_HSIC, "QMI_DATA_ENDPOINT_TYPE_HSIC", "hsic" },
    { QMI_DATA_ENDPOINT_TYPE_HSUSB, "QMI_DATA_ENDPOINT_TYPE_HSUSB", "hsusb" },
    { QMI_DATA_ENDPOINT_TYPE_PCIE, "QMI_DATA_ENDPOINT_TYPE_PCIE", "pcie" },
    { QMI_DATA_ENDPOINT_TYPE_EMBEDDED, "QMI_DATA_ENDPOINT_TYPE_EMBEDDED", "embedded" },
    { QMI_DATA_ENDPOINT_TYPE_BAM_DMUX, "QMI_DATA_ENDPOINT_TYPE_BAM_DMUX", "bam-dmux" },
    { QMI_DATA_ENDPOINT_TYPE_UNDEFINED, "QMI_DATA_ENDPOINT_TYPE_UNDEFINED", "undefined" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_data_endpoint_type_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiDataEndpointType"),
                                      qmi_data_endpoint_type_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_DATA_ENDPOINT_TYPE_IS_ENUM__
const gchar *
qmi_data_endpoint_type_get_string (QmiDataEndpointType val)
{
    guint i;

    for (i = 0; qmi_data_endpoint_type_values[i].value_nick; i++) {
      if ((gint)val == qmi_data_endpoint_type_values[i].value)
            return qmi_data_endpoint_type_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_DATA_ENDPOINT_TYPE_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_DATA_ENDPOINT_TYPE_IS_FLAGS__
gchar *
qmi_data_endpoint_type_build_string_from_mask (QmiDataEndpointType mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_data_endpoint_type_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_data_endpoint_type_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_data_endpoint_type_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_data_endpoint_type_values[i].value) {
            guint c;
            gulong number = qmi_data_endpoint_type_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_data_endpoint_type_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_DATA_ENDPOINT_TYPE_IS_FLAGS__ */
static const GEnumValue qmi_sio_port_values[] = {
    { QMI_SIO_PORT_NONE, "QMI_SIO_PORT_NONE", "none" },
    { QMI_SIO_PORT_A2_MUX_RMNET0, "QMI_SIO_PORT_A2_MUX_RMNET0", "a2-mux-rmnet0" },
    { QMI_SIO_PORT_A2_MUX_RMNET1, "QMI_SIO_PORT_A2_MUX_RMNET1", "a2-mux-rmnet1" },
    { QMI_SIO_PORT_A2_MUX_RMNET2, "QMI_SIO_PORT_A2_MUX_RMNET2", "a2-mux-rmnet2" },
    { QMI_SIO_PORT_A2_MUX_RMNET3, "QMI_SIO_PORT_A2_MUX_RMNET3", "a2-mux-rmnet3" },
    { QMI_SIO_PORT_A2_MUX_RMNET4, "QMI_SIO_PORT_A2_MUX_RMNET4", "a2-mux-rmnet4" },
    { QMI_SIO_PORT_A2_MUX_RMNET5, "QMI_SIO_PORT_A2_MUX_RMNET5", "a2-mux-rmnet5" },
    { QMI_SIO_PORT_A2_MUX_RMNET6, "QMI_SIO_PORT_A2_MUX_RMNET6", "a2-mux-rmnet6" },
    { QMI_SIO_PORT_A2_MUX_RMNET7, "QMI_SIO_PORT_A2_MUX_RMNET7", "a2-mux-rmnet7" },
    { 0, NULL, NULL }
};

/* Define type-specific symbols */

GType
qmi_sio_port_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_enum_register_static (g_intern_static_string ("QmiSioPort"),
                                      qmi_sio_port_values);
        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

/* Enum-specific method to get the value as a string.
 * We get the nick of the GEnumValue. Note that this will be
 * valid even if the GEnumClass is not referenced anywhere. */
#if defined __QMI_SIO_PORT_IS_ENUM__
const gchar *
qmi_sio_port_get_string (QmiSioPort val)
{
    guint i;

    for (i = 0; qmi_sio_port_values[i].value_nick; i++) {
      if ((gint)val == qmi_sio_port_values[i].value)
            return qmi_sio_port_values[i].value_nick;
    }

    return NULL;
}
#endif /* __QMI_SIO_PORT_IS_ENUM__ */

/* Flags-specific method to build a string with the given mask.
 * We get a comma separated list of the nicks of the GFlagsValues.
 * Note that this will be valid even if the GFlagsClass is not referenced
 * anywhere. */
#if defined __QMI_SIO_PORT_IS_FLAGS__
gchar *
qmi_sio_port_build_string_from_mask (QmiSioPort mask)
{
    guint i;
    gboolean first = TRUE;
    GString *str = NULL;

    for (i = 0; qmi_sio_port_values[i].value_nick; i++) {
        /* We also look for exact matches */
      if ((guint)mask == qmi_sio_port_values[i].value) {
            if (str)
                g_string_free (str, TRUE);
            return g_strdup (qmi_sio_port_values[i].value_nick);
        }

        /* Build list with single-bit masks */
        if (mask & qmi_sio_port_values[i].value) {
            guint c;
            gulong number = qmi_sio_port_values[i].value;

            for (c = 0; number; c++)
                number &= number - 1;

            if (c == 1) {
                if (!str)
                    str = g_string_new ("");
                g_string_append_printf (str, "%s%s",
                                        first ? "" : ", ",
                                        qmi_sio_port_values[i].value_nick);
                if (first)
                    first = FALSE;
            }
        }
    }

    return (str ? g_string_free (str, FALSE) : NULL);
}
#endif /* __QMI_SIO_PORT_IS_FLAGS__ */

/* Generated data ends here */

