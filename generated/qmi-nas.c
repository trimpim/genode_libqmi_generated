
/* GENERATED CODE... DO NOT EDIT */

/*
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301 USA.
 *
 * Copyright (C) 2012 Lanedo GmbH
 * Copyright (C) 2012-2017 Aleksander Morgado <aleksander@aleksander.es>
 */


#include <string.h>

#include "qmi-nas.h"
#include "qmi-enum-types.h"
#include "qmi-enum-types-private.h"
#include "qmi-flags64-types.h"
#include "qmi-error-types.h"
#include "qmi-device.h"
#include "qmi-helpers.h"

#define QMI_STATUS_SUCCESS 0x0000
#define QMI_STATUS_FAILURE 0x0001


typedef enum {
    QMI_MESSAGE_NAS_RESET = 0x0000,
    QMI_MESSAGE_NAS_ABORT = 0x0001,
    QMI_MESSAGE_NAS_SET_EVENT_REPORT = 0x0002,
    QMI_MESSAGE_NAS_REGISTER_INDICATIONS = 0x0003,
    QMI_MESSAGE_NAS_GET_SUPPORTED_MESSAGES = 0x001E,
    QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH = 0x0020,
    QMI_MESSAGE_NAS_NETWORK_SCAN = 0x0021,
    QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER = 0x0022,
    QMI_MESSAGE_NAS_ATTACH_DETACH = 0x0023,
    QMI_MESSAGE_NAS_GET_SERVING_SYSTEM = 0x0024,
    QMI_MESSAGE_NAS_GET_HOME_NETWORK = 0x0025,
    QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS = 0x0026,
    QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS = 0x0027,
    QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE = 0x002A,
    QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE = 0x002B,
    QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION = 0x0031,
    QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE = 0x0033,
    QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE = 0x0034,
    QMI_MESSAGE_NAS_GET_OPERATOR_NAME = 0x0039,
    QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO = 0x0043,
    QMI_MESSAGE_NAS_GET_PLMN_NAME = 0x0044,
    QMI_MESSAGE_NAS_GET_SYSTEM_INFO = 0x004D,
    QMI_MESSAGE_NAS_GET_SIGNAL_INFO = 0x004F,
    QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO = 0x0050,
    QMI_MESSAGE_NAS_GET_TX_RX_INFO = 0x005A,
    QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO = 0x0065,
    QMI_MESSAGE_NAS_FORCE_NETWORK_SEARCH = 0x0067,
    QMI_MESSAGE_NAS_GET_DRX = 0x0089,
    QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO = 0x00AC,
    QMI_MESSAGE_NAS_SWI_GET_STATUS = 0x5556, /* vendor 0x1199 */
} QmiMessageNas;


typedef enum {
    QMI_INDICATION_NAS_EVENT_REPORT = 0x0002,
    QMI_INDICATION_NAS_SERVING_SYSTEM = 0x0024,
    QMI_INDICATION_NAS_OPERATOR_NAME = 0x003A,
    QMI_INDICATION_NAS_NETWORK_TIME = 0x004C,
    QMI_INDICATION_NAS_SYSTEM_INFO = 0x004E,
    QMI_INDICATION_NAS_SIGNAL_INFO = 0x0051,
    QMI_INDICATION_NAS_NETWORK_REJECT = 0x0068,
} QmiIndicationNas;


/*****************************************************************************/
/* INDICATION: Qmi Indication NAS Event Report */


/* --- Output -- */

struct _QmiIndicationNasEventReportOutput {
    volatile gint ref_count;

    /* LTE RSRP */
    gboolean arg_lte_rsrp_set;
    gint16 arg_lte_rsrp;

    /* LTE SNR */
    gboolean arg_lte_snr_set;
    gint16 arg_lte_snr;

    /* RSRQ */
    gboolean arg_rsrq_set;
    gint8 arg_rsrq_rsrq;
    gint8 arg_rsrq_radio_interface;

    /* Error Rate */
    gboolean arg_error_rate_set;
    guint16 arg_error_rate_rate;
    gint8 arg_error_rate_radio_interface;

    /* SINR */
    gboolean arg_sinr_set;
    guint8 arg_sinr;

    /* IO */
    gboolean arg_io_set;
    gint32 arg_io;

    /* ECIO */
    gboolean arg_ecio_set;
    guint8 arg_ecio_ecio;
    gint8 arg_ecio_radio_interface;

    /* RSSI */
    gboolean arg_rssi_set;
    guint8 arg_rssi_rssi;
    gint8 arg_rssi_radio_interface;

    /* Registration Reject Reason */
    gboolean arg_registration_reject_reason_set;
    guint8 arg_registration_reject_reason_service_domain;
    guint16 arg_registration_reject_reason_reject_cause;

    /* RF Band Information */
    gboolean arg_rf_band_information_set;
    GArray *arg_rf_band_information;

    /* Signal Strength */
    gboolean arg_signal_strength_set;
    gint8 arg_signal_strength_strength;
    gint8 arg_signal_strength_radio_interface;
};

#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_RSRP 0x1A
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_SNR 0x19
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSRQ 0x18
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ERROR_RATE 0x17
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SINR 0x16
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_IO 0x15
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ECIO 0x14
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSSI 0x13
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_REGISTRATION_REJECT_REASON 0x12
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RF_BAND_INFORMATION 0x11
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SIGNAL_STRENGTH 0x10

gboolean
qmi_indication_nas_event_report_output_get_lte_rsrp (
    QmiIndicationNasEventReportOutput *self,
    gint16 *value_lte_rsrp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_rsrp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE RSRP' was not found in the message");
        return FALSE;
    }

    if (value_lte_rsrp)
        *value_lte_rsrp = self->arg_lte_rsrp;

    return TRUE;
}

gboolean
qmi_indication_nas_event_report_output_get_lte_snr (
    QmiIndicationNasEventReportOutput *self,
    gint16 *value_lte_snr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_snr_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE SNR' was not found in the message");
        return FALSE;
    }

    if (value_lte_snr)
        *value_lte_snr = self->arg_lte_snr;

    return TRUE;
}

gboolean
qmi_indication_nas_event_report_output_get_rsrq (
    QmiIndicationNasEventReportOutput *self,
    gint8 *value_rsrq_rsrq,
    QmiNasRadioInterface *value_rsrq_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rsrq_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSRQ' was not found in the message");
        return FALSE;
    }

    if (value_rsrq_rsrq)
        *value_rsrq_rsrq = self->arg_rsrq_rsrq;
    if (value_rsrq_radio_interface)
        *value_rsrq_radio_interface = (QmiNasRadioInterface)(self->arg_rsrq_radio_interface);

    return TRUE;
}

gboolean
qmi_indication_nas_event_report_output_get_error_rate (
    QmiIndicationNasEventReportOutput *self,
    guint16 *value_error_rate_rate,
    QmiNasRadioInterface *value_error_rate_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_error_rate_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Error Rate' was not found in the message");
        return FALSE;
    }

    if (value_error_rate_rate)
        *value_error_rate_rate = self->arg_error_rate_rate;
    if (value_error_rate_radio_interface)
        *value_error_rate_radio_interface = (QmiNasRadioInterface)(self->arg_error_rate_radio_interface);

    return TRUE;
}

gboolean
qmi_indication_nas_event_report_output_get_sinr (
    QmiIndicationNasEventReportOutput *self,
    QmiNasEvdoSinrLevel *value_sinr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sinr_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SINR' was not found in the message");
        return FALSE;
    }

    if (value_sinr)
        *value_sinr = (QmiNasEvdoSinrLevel)(self->arg_sinr);

    return TRUE;
}

gboolean
qmi_indication_nas_event_report_output_get_io (
    QmiIndicationNasEventReportOutput *self,
    gint32 *value_io,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_io_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'IO' was not found in the message");
        return FALSE;
    }

    if (value_io)
        *value_io = self->arg_io;

    return TRUE;
}

gboolean
qmi_indication_nas_event_report_output_get_ecio (
    QmiIndicationNasEventReportOutput *self,
    guint8 *value_ecio_ecio,
    QmiNasRadioInterface *value_ecio_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ecio_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ECIO' was not found in the message");
        return FALSE;
    }

    if (value_ecio_ecio)
        *value_ecio_ecio = self->arg_ecio_ecio;
    if (value_ecio_radio_interface)
        *value_ecio_radio_interface = (QmiNasRadioInterface)(self->arg_ecio_radio_interface);

    return TRUE;
}

gboolean
qmi_indication_nas_event_report_output_get_rssi (
    QmiIndicationNasEventReportOutput *self,
    guint8 *value_rssi_rssi,
    QmiNasRadioInterface *value_rssi_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rssi_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSSI' was not found in the message");
        return FALSE;
    }

    if (value_rssi_rssi)
        *value_rssi_rssi = self->arg_rssi_rssi;
    if (value_rssi_radio_interface)
        *value_rssi_radio_interface = (QmiNasRadioInterface)(self->arg_rssi_radio_interface);

    return TRUE;
}

gboolean
qmi_indication_nas_event_report_output_get_registration_reject_reason (
    QmiIndicationNasEventReportOutput *self,
    QmiNasNetworkServiceDomain *value_registration_reject_reason_service_domain,
    guint16 *value_registration_reject_reason_reject_cause,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_registration_reject_reason_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Registration Reject Reason' was not found in the message");
        return FALSE;
    }

    if (value_registration_reject_reason_service_domain)
        *value_registration_reject_reason_service_domain = (QmiNasNetworkServiceDomain)(self->arg_registration_reject_reason_service_domain);
    if (value_registration_reject_reason_reject_cause)
        *value_registration_reject_reason_reject_cause = self->arg_registration_reject_reason_reject_cause;

    return TRUE;
}

gboolean
qmi_indication_nas_event_report_output_get_rf_band_information (
    QmiIndicationNasEventReportOutput *self,
    GArray **value_rf_band_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rf_band_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RF Band Information' was not found in the message");
        return FALSE;
    }

    if (value_rf_band_information)
        *value_rf_band_information = self->arg_rf_band_information;

    return TRUE;
}

gboolean
qmi_indication_nas_event_report_output_get_signal_strength (
    QmiIndicationNasEventReportOutput *self,
    gint8 *value_signal_strength_strength,
    QmiNasRadioInterface *value_signal_strength_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_signal_strength_strength)
        *value_signal_strength_strength = self->arg_signal_strength_strength;
    if (value_signal_strength_radio_interface)
        *value_signal_strength_radio_interface = (QmiNasRadioInterface)(self->arg_signal_strength_radio_interface);

    return TRUE;
}

GType
qmi_indication_nas_event_report_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasEventReportOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_event_report_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_event_report_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiIndicationNasEventReportOutput *
qmi_indication_nas_event_report_output_ref (QmiIndicationNasEventReportOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_indication_nas_event_report_output_unref (QmiIndicationNasEventReportOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_rf_band_information)
            g_array_unref (self->arg_rf_band_information);
        g_slice_free (QmiIndicationNasEventReportOutput, self);
    }
}

static gchar *
qmi_indication_nas_event_report_output_lte_rsrp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_RSRP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_event_report_output_lte_snr_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_SNR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_event_report_output_rsrq_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSRQ, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rsrq = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " radio_interface = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_event_report_output_error_rate_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ERROR_RATE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rate = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " radio_interface = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_event_report_output_sinr_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SINR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_evdo_sinr_level_get_string ((QmiNasEvdoSinrLevel)tmp));
#elif defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_evdo_sinr_level_build_string_from_mask ((QmiNasEvdoSinrLevel)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasEvdoSinrLevel
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_event_report_output_io_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_IO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_event_report_output_ecio_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ECIO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " ecio = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " radio_interface = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_event_report_output_rssi_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSSI, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rssi = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " radio_interface = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_event_report_output_registration_reject_reason_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_REGISTRATION_REJECT_REASON, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " reject_cause = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_event_report_output_rf_band_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RF_BAND_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint rf_band_information_i;
        guint8 rf_band_information_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(rf_band_information_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (rf_band_information_i = 0; rf_band_information_i < rf_band_information_n_items; rf_band_information_i++) {
            g_string_append_printf (printable, " [%u] = '", rf_band_information_i);
            g_string_append (printable, "[");
            g_string_append (printable, " radio_interface = '");

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " active_band_class = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_ACTIVE_BAND_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_active_band_get_string ((QmiNasActiveBand)tmp));
#elif defined  __QMI_NAS_ACTIVE_BAND_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_active_band_build_string_from_mask ((QmiNasActiveBand)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasActiveBand
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " active_channel = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_event_report_output_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " strength = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " radio_interface = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct indication_event_report_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_event_report_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_event_report_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    {
        switch (type) {
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_RSRP:
            tlv_type_str = "LTE RSRP";
            translated_value = qmi_indication_nas_event_report_output_lte_rsrp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_SNR:
            tlv_type_str = "LTE SNR";
            translated_value = qmi_indication_nas_event_report_output_lte_snr_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSRQ:
            tlv_type_str = "RSRQ";
            translated_value = qmi_indication_nas_event_report_output_rsrq_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ERROR_RATE:
            tlv_type_str = "Error Rate";
            translated_value = qmi_indication_nas_event_report_output_error_rate_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SINR:
            tlv_type_str = "SINR";
            translated_value = qmi_indication_nas_event_report_output_sinr_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_IO:
            tlv_type_str = "IO";
            translated_value = qmi_indication_nas_event_report_output_io_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ECIO:
            tlv_type_str = "ECIO";
            translated_value = qmi_indication_nas_event_report_output_ecio_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSSI:
            tlv_type_str = "RSSI";
            translated_value = qmi_indication_nas_event_report_output_rssi_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_REGISTRATION_REJECT_REASON:
            tlv_type_str = "Registration Reject Reason";
            translated_value = qmi_indication_nas_event_report_output_registration_reject_reason_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RF_BAND_INFORMATION:
            tlv_type_str = "RF Band Information";
            translated_value = qmi_indication_nas_event_report_output_rf_band_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SIGNAL_STRENGTH:
            tlv_type_str = "Signal Strength";
            translated_value = qmi_indication_nas_event_report_output_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
indication_event_report_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Event Report\" (0x0002)\n",
                            line_prefix);

    {
        struct indication_event_report_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_event_report_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasEventReportOutput *
__qmi_indication_nas_event_report_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasEventReportOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_INDICATION_NAS_EVENT_REPORT);

    self = g_slice_new0 (QmiIndicationNasEventReportOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_RSRP, NULL, NULL)) == 0) {
                goto qmi_indication_nas_event_report_output_lte_rsrp_out;
            }
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_rsrp), NULL))
                goto qmi_indication_nas_event_report_output_lte_rsrp_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE RSRP' TLV", offset);
            }

            self->arg_lte_rsrp_set = TRUE;

qmi_indication_nas_event_report_output_lte_rsrp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_SNR, NULL, NULL)) == 0) {
                goto qmi_indication_nas_event_report_output_lte_snr_out;
            }
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_snr), NULL))
                goto qmi_indication_nas_event_report_output_lte_snr_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE SNR' TLV", offset);
            }

            self->arg_lte_snr_set = TRUE;

qmi_indication_nas_event_report_output_lte_snr_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSRQ, NULL, NULL)) == 0) {
                goto qmi_indication_nas_event_report_output_rsrq_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_rsrq_rsrq), NULL))
                goto qmi_indication_nas_event_report_output_rsrq_out;
            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_event_report_output_rsrq_out;
                self->arg_rsrq_radio_interface = (QmiNasRadioInterface)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'RSRQ' TLV", offset);
            }

            self->arg_rsrq_set = TRUE;

qmi_indication_nas_event_report_output_rsrq_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ERROR_RATE, NULL, NULL)) == 0) {
                goto qmi_indication_nas_event_report_output_error_rate_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_error_rate_rate), NULL))
                goto qmi_indication_nas_event_report_output_error_rate_out;
            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_event_report_output_error_rate_out;
                self->arg_error_rate_radio_interface = (QmiNasRadioInterface)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Error Rate' TLV", offset);
            }

            self->arg_error_rate_set = TRUE;

qmi_indication_nas_event_report_output_error_rate_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SINR, NULL, NULL)) == 0) {
                goto qmi_indication_nas_event_report_output_sinr_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_event_report_output_sinr_out;
                self->arg_sinr = (QmiNasEvdoSinrLevel)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'SINR' TLV", offset);
            }

            self->arg_sinr_set = TRUE;

qmi_indication_nas_event_report_output_sinr_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_IO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_event_report_output_io_out;
            }
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_io), NULL))
                goto qmi_indication_nas_event_report_output_io_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'IO' TLV", offset);
            }

            self->arg_io_set = TRUE;

qmi_indication_nas_event_report_output_io_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ECIO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_event_report_output_ecio_out;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_ecio_ecio), NULL))
                goto qmi_indication_nas_event_report_output_ecio_out;
            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_event_report_output_ecio_out;
                self->arg_ecio_radio_interface = (QmiNasRadioInterface)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'ECIO' TLV", offset);
            }

            self->arg_ecio_set = TRUE;

qmi_indication_nas_event_report_output_ecio_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSSI, NULL, NULL)) == 0) {
                goto qmi_indication_nas_event_report_output_rssi_out;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_rssi_rssi), NULL))
                goto qmi_indication_nas_event_report_output_rssi_out;
            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_event_report_output_rssi_out;
                self->arg_rssi_radio_interface = (QmiNasRadioInterface)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'RSSI' TLV", offset);
            }

            self->arg_rssi_set = TRUE;

qmi_indication_nas_event_report_output_rssi_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_REGISTRATION_REJECT_REASON, NULL, NULL)) == 0) {
                goto qmi_indication_nas_event_report_output_registration_reject_reason_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_event_report_output_registration_reject_reason_out;
                self->arg_registration_reject_reason_service_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_registration_reject_reason_reject_cause), NULL))
                goto qmi_indication_nas_event_report_output_registration_reject_reason_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Registration Reject Reason' TLV", offset);
            }

            self->arg_registration_reject_reason_set = TRUE;

qmi_indication_nas_event_report_output_registration_reject_reason_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RF_BAND_INFORMATION, NULL, NULL)) == 0) {
                goto qmi_indication_nas_event_report_output_rf_band_information_out;
            }
            {
                guint rf_band_information_i;
                guint8 rf_band_information_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(rf_band_information_n_items), NULL))
                    goto qmi_indication_nas_event_report_output_rf_band_information_out;

                self->arg_rf_band_information = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiIndicationNasEventReportOutputRfBandInformationElement),
                    (guint)rf_band_information_n_items);

                for (rf_band_information_i = 0; rf_band_information_i < rf_band_information_n_items; rf_band_information_i++) {
                    QmiIndicationNasEventReportOutputRfBandInformationElement rf_band_information_aux;

                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_indication_nas_event_report_output_rf_band_information_out;
                        rf_band_information_aux.radio_interface = (QmiNasRadioInterface)tmp;
                    }
                    {
                        guint16 tmp;

                        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                            goto qmi_indication_nas_event_report_output_rf_band_information_out;
                        rf_band_information_aux.active_band_class = (QmiNasActiveBand)tmp;
                    }
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(rf_band_information_aux.active_channel), NULL))
                        goto qmi_indication_nas_event_report_output_rf_band_information_out;
                    g_array_insert_val (self->arg_rf_band_information, rf_band_information_i, rf_band_information_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'RF Band Information' TLV", offset);
            }

            self->arg_rf_band_information_set = TRUE;

qmi_indication_nas_event_report_output_rf_band_information_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_indication_nas_event_report_output_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_signal_strength_strength), NULL))
                goto qmi_indication_nas_event_report_output_signal_strength_out;
            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_event_report_output_signal_strength_out;
                self->arg_signal_strength_radio_interface = (QmiNasRadioInterface)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Signal Strength' TLV", offset);
            }

            self->arg_signal_strength_set = TRUE;

qmi_indication_nas_event_report_output_signal_strength_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication NAS Serving System */


/* --- Output -- */

struct _QmiIndicationNasServingSystemOutput {
    volatile gint ref_count;

    /* Network Name Source */
    gboolean arg_network_name_source_set;
    guint32 arg_network_name_source;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    guint16 arg_mnc_pcs_digit_include_status_mcc;
    guint16 arg_mnc_pcs_digit_include_status_mnc;
    guint8 arg_mnc_pcs_digit_include_status_includes_pcs_digit;

    /* UMTS Primary Scrambling Code */
    gboolean arg_umts_primary_scrambling_code_set;
    guint16 arg_umts_primary_scrambling_code;

    /* PLMN Not Changed Indication */
    gboolean arg_plmn_not_changed_indication_set;
    guint8 arg_plmn_not_changed_indication;

    /* Call Barring Status */
    gboolean arg_call_barring_status_set;
    gint32 arg_call_barring_status_cs_status;
    gint32 arg_call_barring_status_ps_status;

    /* LTE TAC */
    gboolean arg_lte_tac_set;
    guint16 arg_lte_tac;

    /* HDR Personality */
    gboolean arg_hdr_personality_set;
    guint8 arg_hdr_personality;

    /* CDMA System Info */
    gboolean arg_cdma_system_info_set;
    guint16 arg_cdma_system_info_mcc;
    guint8 arg_cdma_system_info_imsi_11_12;

    /* Detailed Service Status */
    gboolean arg_detailed_service_status_set;
    guint8 arg_detailed_service_status_status;
    guint8 arg_detailed_service_status_capability;
    guint8 arg_detailed_service_status_hdr_status;
    guint8 arg_detailed_service_status_hdr_hybrid;
    guint8 arg_detailed_service_status_forbidden;

    /* DTM Support */
    gboolean arg_dtm_support_set;
    guint8 arg_dtm_support;

    /* PRL Indicator 3GPP2 */
    gboolean arg_prl_indicator_3gpp2_set;
    guint8 arg_prl_indicator_3gpp2;

    /* Concurrent Service Info 3GPP2 */
    gboolean arg_concurrent_service_info_3gpp2_set;
    guint8 arg_concurrent_service_info_3gpp2;

    /* CID 3GPP */
    gboolean arg_cid_3gpp_set;
    guint32 arg_cid_3gpp;

    /* LAC 3GPP */
    gboolean arg_lac_3gpp_set;
    guint16 arg_lac_3gpp;

    /* Universal Time and Local Time Zone 3GPP */
    gboolean arg_universal_time_and_local_time_zone_3gpp_set;
    guint16 arg_universal_time_and_local_time_zone_3gpp_year;
    guint8 arg_universal_time_and_local_time_zone_3gpp_month;
    guint8 arg_universal_time_and_local_time_zone_3gpp_day;
    guint8 arg_universal_time_and_local_time_zone_3gpp_hour;
    guint8 arg_universal_time_and_local_time_zone_3gpp_minute;
    guint8 arg_universal_time_and_local_time_zone_3gpp_second;
    guint8 arg_universal_time_and_local_time_zone_3gpp_time_zone;

    /* Daylight Saving Time Adjustment 3GPP */
    gboolean arg_daylight_saving_time_adjustment_3gpp_set;
    guint8 arg_daylight_saving_time_adjustment_3gpp;

    /* Time Zone 3GPP */
    gboolean arg_time_zone_3gpp_set;
    gint8 arg_time_zone_3gpp;

    /* PLMN Name Flag 3GPP */
    gboolean arg_plmn_name_flag_3gpp_set;
    gint8 arg_plmn_name_flag_3gpp;

    /* CDMA P Rev */
    gboolean arg_cdma_p_rev_set;
    guint8 arg_cdma_p_rev;

    /* Time Zone 3GPP2 */
    gboolean arg_time_zone_3gpp2_set;
    guint8 arg_time_zone_3gpp2_leap_seconds;
    gint8 arg_time_zone_3gpp2_local_time_offset;
    guint8 arg_time_zone_3gpp2_daylight_saving_time;

    /* Default Roaming Indicator */
    gboolean arg_default_roaming_indicator_set;
    guint8 arg_default_roaming_indicator;

    /* Roaming Indicator List */
    gboolean arg_roaming_indicator_list_set;
    GArray *arg_roaming_indicator_list;

    /* CDMA Base Station Info */
    gboolean arg_cdma_base_station_info_set;
    guint16 arg_cdma_base_station_info_base_station_id;
    gint32 arg_cdma_base_station_info_base_station_latitude;
    gint32 arg_cdma_base_station_info_base_station_longitude;

    /* CDMA System ID */
    gboolean arg_cdma_system_id_set;
    guint16 arg_cdma_system_id_sid;
    guint16 arg_cdma_system_id_nid;

    /* Current PLMN */
    gboolean arg_current_plmn_set;
    guint16 arg_current_plmn_mcc;
    guint16 arg_current_plmn_mnc;
    gchar *arg_current_plmn_description;

    /* Data Service Capability */
    gboolean arg_data_service_capability_set;
    GArray *arg_data_service_capability;

    /* Roaming Indicator */
    gboolean arg_roaming_indicator_set;
    guint8 arg_roaming_indicator;

    /* Serving System */
    gboolean arg_serving_system_set;
    guint8 arg_serving_system_registration_state;
    guint8 arg_serving_system_cs_attach_state;
    guint8 arg_serving_system_ps_attach_state;
    guint8 arg_serving_system_selected_network;
    GArray *arg_serving_system_radio_interfaces;
};

#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_NETWORK_NAME_SOURCE 0x2B
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x29
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE 0x28
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION 0x27
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS 0x26
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC 0x25
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY 0x24
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO 0x23
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS 0x22
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT 0x21
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2 0x20
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2 0x1F
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP 0x1E
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP 0x1D
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UNIVERSAL_TIME_AND_LOCAL_TIME_ZONE_3GPP 0x1C
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP 0x1B
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP 0x1A
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NAME_FLAG_3GPP 0x19
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV 0x18
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2 0x17
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR 0x16
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST 0x15
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO 0x14
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID 0x13
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN 0x12
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY 0x11
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR 0x10
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM 0x01

gboolean
qmi_indication_nas_serving_system_output_get_network_name_source (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasNetworkNameSource *value_network_name_source,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_name_source_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Name Source' was not found in the message");
        return FALSE;
    }

    if (value_network_name_source)
        *value_network_name_source = (QmiNasNetworkNameSource)(self->arg_network_name_source);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_mnc_pcs_digit_include_status (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *value_mnc_pcs_digit_include_status_mcc,
    guint16 *value_mnc_pcs_digit_include_status_mnc,
    gboolean *value_mnc_pcs_digit_include_status_includes_pcs_digit,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (value_mnc_pcs_digit_include_status_mcc)
        *value_mnc_pcs_digit_include_status_mcc = self->arg_mnc_pcs_digit_include_status_mcc;
    if (value_mnc_pcs_digit_include_status_mnc)
        *value_mnc_pcs_digit_include_status_mnc = self->arg_mnc_pcs_digit_include_status_mnc;
    if (value_mnc_pcs_digit_include_status_includes_pcs_digit)
        *value_mnc_pcs_digit_include_status_includes_pcs_digit = (gboolean)(self->arg_mnc_pcs_digit_include_status_includes_pcs_digit);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_umts_primary_scrambling_code (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *value_umts_primary_scrambling_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_umts_primary_scrambling_code_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'UMTS Primary Scrambling Code' was not found in the message");
        return FALSE;
    }

    if (value_umts_primary_scrambling_code)
        *value_umts_primary_scrambling_code = self->arg_umts_primary_scrambling_code;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_plmn_not_changed_indication (
    QmiIndicationNasServingSystemOutput *self,
    gboolean *value_plmn_not_changed_indication,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_plmn_not_changed_indication_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PLMN Not Changed Indication' was not found in the message");
        return FALSE;
    }

    if (value_plmn_not_changed_indication)
        *value_plmn_not_changed_indication = (gboolean)(self->arg_plmn_not_changed_indication);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_call_barring_status (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasCallBarringStatus *value_call_barring_status_cs_status,
    QmiNasCallBarringStatus *value_call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (value_call_barring_status_cs_status)
        *value_call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_call_barring_status_cs_status);
    if (value_call_barring_status_ps_status)
        *value_call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_call_barring_status_ps_status);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_lte_tac (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *value_lte_tac,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_tac_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE TAC' was not found in the message");
        return FALSE;
    }

    if (value_lte_tac)
        *value_lte_tac = self->arg_lte_tac;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_hdr_personality (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasHdrPersonality *value_hdr_personality,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_personality_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Personality' was not found in the message");
        return FALSE;
    }

    if (value_hdr_personality)
        *value_hdr_personality = (QmiNasHdrPersonality)(self->arg_hdr_personality);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_cdma_system_info (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *value_cdma_system_info_mcc,
    guint8 *value_cdma_system_info_imsi_11_12,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (value_cdma_system_info_mcc)
        *value_cdma_system_info_mcc = self->arg_cdma_system_info_mcc;
    if (value_cdma_system_info_imsi_11_12)
        *value_cdma_system_info_imsi_11_12 = self->arg_cdma_system_info_imsi_11_12;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_detailed_service_status (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasServiceStatus *value_detailed_service_status_status,
    QmiNasNetworkServiceDomain *value_detailed_service_status_capability,
    QmiNasServiceStatus *value_detailed_service_status_hdr_status,
    gboolean *value_detailed_service_status_hdr_hybrid,
    gboolean *value_detailed_service_status_forbidden,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_detailed_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Detailed Service Status' was not found in the message");
        return FALSE;
    }

    if (value_detailed_service_status_status)
        *value_detailed_service_status_status = (QmiNasServiceStatus)(self->arg_detailed_service_status_status);
    if (value_detailed_service_status_capability)
        *value_detailed_service_status_capability = (QmiNasNetworkServiceDomain)(self->arg_detailed_service_status_capability);
    if (value_detailed_service_status_hdr_status)
        *value_detailed_service_status_hdr_status = (QmiNasServiceStatus)(self->arg_detailed_service_status_hdr_status);
    if (value_detailed_service_status_hdr_hybrid)
        *value_detailed_service_status_hdr_hybrid = (gboolean)(self->arg_detailed_service_status_hdr_hybrid);
    if (value_detailed_service_status_forbidden)
        *value_detailed_service_status_forbidden = (gboolean)(self->arg_detailed_service_status_forbidden);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_dtm_support (
    QmiIndicationNasServingSystemOutput *self,
    gboolean *value_dtm_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_dtm_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'DTM Support' was not found in the message");
        return FALSE;
    }

    if (value_dtm_support)
        *value_dtm_support = (gboolean)(self->arg_dtm_support);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_prl_indicator_3gpp2 (
    QmiIndicationNasServingSystemOutput *self,
    gboolean *value_prl_indicator_3gpp2,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_prl_indicator_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PRL Indicator 3GPP2' was not found in the message");
        return FALSE;
    }

    if (value_prl_indicator_3gpp2)
        *value_prl_indicator_3gpp2 = (gboolean)(self->arg_prl_indicator_3gpp2);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_concurrent_service_info_3gpp2 (
    QmiIndicationNasServingSystemOutput *self,
    gboolean *value_concurrent_service_info_3gpp2,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_concurrent_service_info_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Concurrent Service Info 3GPP2' was not found in the message");
        return FALSE;
    }

    if (value_concurrent_service_info_3gpp2)
        *value_concurrent_service_info_3gpp2 = (gboolean)(self->arg_concurrent_service_info_3gpp2);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_cid_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    guint32 *value_cid_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cid_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CID 3GPP' was not found in the message");
        return FALSE;
    }

    if (value_cid_3gpp)
        *value_cid_3gpp = self->arg_cid_3gpp;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_lac_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *value_lac_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lac_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LAC 3GPP' was not found in the message");
        return FALSE;
    }

    if (value_lac_3gpp)
        *value_lac_3gpp = self->arg_lac_3gpp;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_universal_time_and_local_time_zone_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *value_universal_time_and_local_time_zone_3gpp_year,
    guint8 *value_universal_time_and_local_time_zone_3gpp_month,
    guint8 *value_universal_time_and_local_time_zone_3gpp_day,
    guint8 *value_universal_time_and_local_time_zone_3gpp_hour,
    guint8 *value_universal_time_and_local_time_zone_3gpp_minute,
    guint8 *value_universal_time_and_local_time_zone_3gpp_second,
    guint8 *value_universal_time_and_local_time_zone_3gpp_time_zone,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_universal_time_and_local_time_zone_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Universal Time and Local Time Zone 3GPP' was not found in the message");
        return FALSE;
    }

    if (value_universal_time_and_local_time_zone_3gpp_year)
        *value_universal_time_and_local_time_zone_3gpp_year = self->arg_universal_time_and_local_time_zone_3gpp_year;
    if (value_universal_time_and_local_time_zone_3gpp_month)
        *value_universal_time_and_local_time_zone_3gpp_month = self->arg_universal_time_and_local_time_zone_3gpp_month;
    if (value_universal_time_and_local_time_zone_3gpp_day)
        *value_universal_time_and_local_time_zone_3gpp_day = self->arg_universal_time_and_local_time_zone_3gpp_day;
    if (value_universal_time_and_local_time_zone_3gpp_hour)
        *value_universal_time_and_local_time_zone_3gpp_hour = self->arg_universal_time_and_local_time_zone_3gpp_hour;
    if (value_universal_time_and_local_time_zone_3gpp_minute)
        *value_universal_time_and_local_time_zone_3gpp_minute = self->arg_universal_time_and_local_time_zone_3gpp_minute;
    if (value_universal_time_and_local_time_zone_3gpp_second)
        *value_universal_time_and_local_time_zone_3gpp_second = self->arg_universal_time_and_local_time_zone_3gpp_second;
    if (value_universal_time_and_local_time_zone_3gpp_time_zone)
        *value_universal_time_and_local_time_zone_3gpp_time_zone = self->arg_universal_time_and_local_time_zone_3gpp_time_zone;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_daylight_saving_time_adjustment_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    guint8 *value_daylight_saving_time_adjustment_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_daylight_saving_time_adjustment_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Daylight Saving Time Adjustment 3GPP' was not found in the message");
        return FALSE;
    }

    if (value_daylight_saving_time_adjustment_3gpp)
        *value_daylight_saving_time_adjustment_3gpp = self->arg_daylight_saving_time_adjustment_3gpp;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_time_zone_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    gint8 *value_time_zone_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_time_zone_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Time Zone 3GPP' was not found in the message");
        return FALSE;
    }

    if (value_time_zone_3gpp)
        *value_time_zone_3gpp = self->arg_time_zone_3gpp;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_plmn_name_flag_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    gboolean *value_plmn_name_flag_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_plmn_name_flag_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PLMN Name Flag 3GPP' was not found in the message");
        return FALSE;
    }

    if (value_plmn_name_flag_3gpp)
        *value_plmn_name_flag_3gpp = (gboolean)(self->arg_plmn_name_flag_3gpp);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_cdma_p_rev (
    QmiIndicationNasServingSystemOutput *self,
    guint8 *value_cdma_p_rev,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_p_rev_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA P Rev' was not found in the message");
        return FALSE;
    }

    if (value_cdma_p_rev)
        *value_cdma_p_rev = self->arg_cdma_p_rev;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_time_zone_3gpp2 (
    QmiIndicationNasServingSystemOutput *self,
    guint8 *value_time_zone_3gpp2_leap_seconds,
    gint8 *value_time_zone_3gpp2_local_time_offset,
    gboolean *value_time_zone_3gpp2_daylight_saving_time,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_time_zone_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Time Zone 3GPP2' was not found in the message");
        return FALSE;
    }

    if (value_time_zone_3gpp2_leap_seconds)
        *value_time_zone_3gpp2_leap_seconds = self->arg_time_zone_3gpp2_leap_seconds;
    if (value_time_zone_3gpp2_local_time_offset)
        *value_time_zone_3gpp2_local_time_offset = self->arg_time_zone_3gpp2_local_time_offset;
    if (value_time_zone_3gpp2_daylight_saving_time)
        *value_time_zone_3gpp2_daylight_saving_time = (gboolean)(self->arg_time_zone_3gpp2_daylight_saving_time);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_default_roaming_indicator (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasRoamingIndicatorStatus *value_default_roaming_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_default_roaming_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Default Roaming Indicator' was not found in the message");
        return FALSE;
    }

    if (value_default_roaming_indicator)
        *value_default_roaming_indicator = (QmiNasRoamingIndicatorStatus)(self->arg_default_roaming_indicator);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_roaming_indicator_list (
    QmiIndicationNasServingSystemOutput *self,
    GArray **value_roaming_indicator_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_indicator_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Indicator List' was not found in the message");
        return FALSE;
    }

    if (value_roaming_indicator_list)
        *value_roaming_indicator_list = self->arg_roaming_indicator_list;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_cdma_base_station_info (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *value_cdma_base_station_info_base_station_id,
    gint32 *value_cdma_base_station_info_base_station_latitude,
    gint32 *value_cdma_base_station_info_base_station_longitude,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_base_station_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Base Station Info' was not found in the message");
        return FALSE;
    }

    if (value_cdma_base_station_info_base_station_id)
        *value_cdma_base_station_info_base_station_id = self->arg_cdma_base_station_info_base_station_id;
    if (value_cdma_base_station_info_base_station_latitude)
        *value_cdma_base_station_info_base_station_latitude = self->arg_cdma_base_station_info_base_station_latitude;
    if (value_cdma_base_station_info_base_station_longitude)
        *value_cdma_base_station_info_base_station_longitude = self->arg_cdma_base_station_info_base_station_longitude;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_cdma_system_id (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *value_cdma_system_id_sid,
    guint16 *value_cdma_system_id_nid,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System ID' was not found in the message");
        return FALSE;
    }

    if (value_cdma_system_id_sid)
        *value_cdma_system_id_sid = self->arg_cdma_system_id_sid;
    if (value_cdma_system_id_nid)
        *value_cdma_system_id_nid = self->arg_cdma_system_id_nid;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_current_plmn (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *value_current_plmn_mcc,
    guint16 *value_current_plmn_mnc,
    const gchar **value_current_plmn_description,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_current_plmn_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Current PLMN' was not found in the message");
        return FALSE;
    }

    if (value_current_plmn_mcc)
        *value_current_plmn_mcc = self->arg_current_plmn_mcc;
    if (value_current_plmn_mnc)
        *value_current_plmn_mnc = self->arg_current_plmn_mnc;
    if (value_current_plmn_description)
        *value_current_plmn_description = self->arg_current_plmn_description;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_data_service_capability (
    QmiIndicationNasServingSystemOutput *self,
    GArray **value_data_service_capability,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_data_service_capability_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Data Service Capability' was not found in the message");
        return FALSE;
    }

    if (value_data_service_capability)
        *value_data_service_capability = self->arg_data_service_capability;

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_roaming_indicator (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasRoamingIndicatorStatus *value_roaming_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Indicator' was not found in the message");
        return FALSE;
    }

    if (value_roaming_indicator)
        *value_roaming_indicator = (QmiNasRoamingIndicatorStatus)(self->arg_roaming_indicator);

    return TRUE;
}

gboolean
qmi_indication_nas_serving_system_output_get_serving_system (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasRegistrationState *value_serving_system_registration_state,
    QmiNasAttachState *value_serving_system_cs_attach_state,
    QmiNasAttachState *value_serving_system_ps_attach_state,
    QmiNasNetworkType *value_serving_system_selected_network,
    GArray **value_serving_system_radio_interfaces,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_serving_system_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Serving System' was not found in the message");
        return FALSE;
    }

    if (value_serving_system_registration_state)
        *value_serving_system_registration_state = (QmiNasRegistrationState)(self->arg_serving_system_registration_state);
    if (value_serving_system_cs_attach_state)
        *value_serving_system_cs_attach_state = (QmiNasAttachState)(self->arg_serving_system_cs_attach_state);
    if (value_serving_system_ps_attach_state)
        *value_serving_system_ps_attach_state = (QmiNasAttachState)(self->arg_serving_system_ps_attach_state);
    if (value_serving_system_selected_network)
        *value_serving_system_selected_network = (QmiNasNetworkType)(self->arg_serving_system_selected_network);
    if (value_serving_system_radio_interfaces)
        *value_serving_system_radio_interfaces = self->arg_serving_system_radio_interfaces;

    return TRUE;
}

GType
qmi_indication_nas_serving_system_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasServingSystemOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_serving_system_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_serving_system_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiIndicationNasServingSystemOutput *
qmi_indication_nas_serving_system_output_ref (QmiIndicationNasServingSystemOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_indication_nas_serving_system_output_unref (QmiIndicationNasServingSystemOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_roaming_indicator_list)
            g_array_unref (self->arg_roaming_indicator_list);
        g_free (self->arg_current_plmn_description);
        if (self->arg_data_service_capability)
            g_array_unref (self->arg_data_service_capability);
        if (self->arg_serving_system_radio_interfaces)
            g_array_unref (self->arg_serving_system_radio_interfaces);
        g_slice_free (QmiIndicationNasServingSystemOutput, self);
    }
}

static gchar *
qmi_indication_nas_serving_system_output_network_name_source_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_NETWORK_NAME_SOURCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_NAME_SOURCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_name_source_get_string ((QmiNasNetworkNameSource)tmp));
#elif defined  __QMI_NAS_NETWORK_NAME_SOURCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_name_source_build_string_from_mask ((QmiNasNetworkNameSource)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkNameSource
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " includes_pcs_digit = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_umts_primary_scrambling_code_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_plmn_not_changed_indication_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " cs_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_lte_tac_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_hdr_personality_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_HDR_PERSONALITY_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_hdr_personality_get_string ((QmiNasHdrPersonality)tmp));
#elif defined  __QMI_NAS_HDR_PERSONALITY_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_hdr_personality_build_string_from_mask ((QmiNasHdrPersonality)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasHdrPersonality
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " imsi_11_12 = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_detailed_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hdr_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hdr_hybrid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_dtm_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_prl_indicator_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_concurrent_service_info_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_cid_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_lac_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UNIVERSAL_TIME_AND_LOCAL_TIME_ZONE_3GPP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " year = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " month = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " day = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hour = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " minute = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " second = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " time_zone = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_daylight_saving_time_adjustment_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_time_zone_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_plmn_name_flag_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NAME_FLAG_3GPP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_cdma_p_rev_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_time_zone_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " leap_seconds = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " local_time_offset = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " daylight_saving_time = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_default_roaming_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_roaming_indicator_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint roaming_indicator_list_i;
        guint8 roaming_indicator_list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(roaming_indicator_list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (roaming_indicator_list_i = 0; roaming_indicator_list_i < roaming_indicator_list_n_items; roaming_indicator_list_i++) {
            g_string_append_printf (printable, " [%u] = '", roaming_indicator_list_i);
            g_string_append (printable, "[");
            g_string_append (printable, " radio_interface = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " roaming_indicator = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_cdma_base_station_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " base_station_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_latitude = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_longitude = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_cdma_system_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " sid = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " nid = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_current_plmn_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " description = '");

    {
        g_autofree gchar *tmp = NULL;

        if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &tmp, &error))
            goto out;
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_data_service_capability_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint data_service_capability_i;
        guint8 data_service_capability_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(data_service_capability_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (data_service_capability_i = 0; data_service_capability_i < data_service_capability_n_items; data_service_capability_i++) {
            g_string_append_printf (printable, " [%u] = '", data_service_capability_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_DATA_CAPABILITY_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_data_capability_get_string ((QmiNasDataCapability)tmp));
#elif defined  __QMI_NAS_DATA_CAPABILITY_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_data_capability_build_string_from_mask ((QmiNasDataCapability)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasDataCapability
#endif
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_roaming_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_serving_system_output_serving_system_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " registration_state = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_REGISTRATION_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_registration_state_get_string ((QmiNasRegistrationState)tmp));
#elif defined  __QMI_NAS_REGISTRATION_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_registration_state_build_string_from_mask ((QmiNasRegistrationState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRegistrationState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cs_attach_state = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ATTACH_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_attach_state_get_string ((QmiNasAttachState)tmp));
#elif defined  __QMI_NAS_ATTACH_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_attach_state_build_string_from_mask ((QmiNasAttachState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasAttachState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_attach_state = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ATTACH_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_attach_state_get_string ((QmiNasAttachState)tmp));
#elif defined  __QMI_NAS_ATTACH_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_attach_state_build_string_from_mask ((QmiNasAttachState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasAttachState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " selected_network = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_TYPE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_type_get_string ((QmiNasNetworkType)tmp));
#elif defined  __QMI_NAS_NETWORK_TYPE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_type_build_string_from_mask ((QmiNasNetworkType)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkType
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " radio_interfaces = '");
    {
        guint radio_interfaces_i;
        guint8 radio_interfaces_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(radio_interfaces_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (radio_interfaces_i = 0; radio_interfaces_i < radio_interfaces_n_items; radio_interfaces_i++) {
            g_string_append_printf (printable, " [%u] = '", radio_interfaces_i);

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct indication_serving_system_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_serving_system_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_serving_system_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    {
        switch (type) {
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_NETWORK_NAME_SOURCE:
            tlv_type_str = "Network Name Source";
            translated_value = qmi_indication_nas_serving_system_output_network_name_source_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE:
            tlv_type_str = "UMTS Primary Scrambling Code";
            translated_value = qmi_indication_nas_serving_system_output_umts_primary_scrambling_code_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION:
            tlv_type_str = "PLMN Not Changed Indication";
            translated_value = qmi_indication_nas_serving_system_output_plmn_not_changed_indication_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS:
            tlv_type_str = "Call Barring Status";
            translated_value = qmi_indication_nas_serving_system_output_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC:
            tlv_type_str = "LTE TAC";
            translated_value = qmi_indication_nas_serving_system_output_lte_tac_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY:
            tlv_type_str = "HDR Personality";
            translated_value = qmi_indication_nas_serving_system_output_hdr_personality_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO:
            tlv_type_str = "CDMA System Info";
            translated_value = qmi_indication_nas_serving_system_output_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS:
            tlv_type_str = "Detailed Service Status";
            translated_value = qmi_indication_nas_serving_system_output_detailed_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT:
            tlv_type_str = "DTM Support";
            translated_value = qmi_indication_nas_serving_system_output_dtm_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2:
            tlv_type_str = "PRL Indicator 3GPP2";
            translated_value = qmi_indication_nas_serving_system_output_prl_indicator_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2:
            tlv_type_str = "Concurrent Service Info 3GPP2";
            translated_value = qmi_indication_nas_serving_system_output_concurrent_service_info_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP:
            tlv_type_str = "CID 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_cid_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP:
            tlv_type_str = "LAC 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_lac_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UNIVERSAL_TIME_AND_LOCAL_TIME_ZONE_3GPP:
            tlv_type_str = "Universal Time and Local Time Zone 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP:
            tlv_type_str = "Daylight Saving Time Adjustment 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_daylight_saving_time_adjustment_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP:
            tlv_type_str = "Time Zone 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_time_zone_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NAME_FLAG_3GPP:
            tlv_type_str = "PLMN Name Flag 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_plmn_name_flag_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV:
            tlv_type_str = "CDMA P Rev";
            translated_value = qmi_indication_nas_serving_system_output_cdma_p_rev_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2:
            tlv_type_str = "Time Zone 3GPP2";
            translated_value = qmi_indication_nas_serving_system_output_time_zone_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR:
            tlv_type_str = "Default Roaming Indicator";
            translated_value = qmi_indication_nas_serving_system_output_default_roaming_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST:
            tlv_type_str = "Roaming Indicator List";
            translated_value = qmi_indication_nas_serving_system_output_roaming_indicator_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO:
            tlv_type_str = "CDMA Base Station Info";
            translated_value = qmi_indication_nas_serving_system_output_cdma_base_station_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID:
            tlv_type_str = "CDMA System ID";
            translated_value = qmi_indication_nas_serving_system_output_cdma_system_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN:
            tlv_type_str = "Current PLMN";
            translated_value = qmi_indication_nas_serving_system_output_current_plmn_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY:
            tlv_type_str = "Data Service Capability";
            translated_value = qmi_indication_nas_serving_system_output_data_service_capability_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR:
            tlv_type_str = "Roaming Indicator";
            translated_value = qmi_indication_nas_serving_system_output_roaming_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM:
            tlv_type_str = "Serving System";
            translated_value = qmi_indication_nas_serving_system_output_serving_system_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
indication_serving_system_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Serving System\" (0x0024)\n",
                            line_prefix);

    {
        struct indication_serving_system_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_serving_system_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasServingSystemOutput *
__qmi_indication_nas_serving_system_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasServingSystemOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_INDICATION_NAS_SERVING_SYSTEM);

    self = g_slice_new0 (QmiIndicationNasServingSystemOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_NETWORK_NAME_SOURCE, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_network_name_source_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_network_name_source_out;
                self->arg_network_name_source = (QmiNasNetworkNameSource)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Network Name Source' TLV", offset);
            }

            self->arg_network_name_source_set = TRUE;

qmi_indication_nas_serving_system_output_network_name_source_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_mnc_pcs_digit_include_status_mcc), NULL))
                goto qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_mnc_pcs_digit_include_status_mnc), NULL))
                goto qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_out;
                self->arg_mnc_pcs_digit_include_status_includes_pcs_digit = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'MNC PCS Digit Include Status' TLV", offset);
            }

            self->arg_mnc_pcs_digit_include_status_set = TRUE;

qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_umts_primary_scrambling_code_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_umts_primary_scrambling_code), NULL))
                goto qmi_indication_nas_serving_system_output_umts_primary_scrambling_code_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'UMTS Primary Scrambling Code' TLV", offset);
            }

            self->arg_umts_primary_scrambling_code_set = TRUE;

qmi_indication_nas_serving_system_output_umts_primary_scrambling_code_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_plmn_not_changed_indication_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_plmn_not_changed_indication_out;
                self->arg_plmn_not_changed_indication = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'PLMN Not Changed Indication' TLV", offset);
            }

            self->arg_plmn_not_changed_indication_set = TRUE;

qmi_indication_nas_serving_system_output_plmn_not_changed_indication_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_call_barring_status_out;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_call_barring_status_out;
                self->arg_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_call_barring_status_out;
                self->arg_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Call Barring Status' TLV", offset);
            }

            self->arg_call_barring_status_set = TRUE;

qmi_indication_nas_serving_system_output_call_barring_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_lte_tac_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_tac), NULL))
                goto qmi_indication_nas_serving_system_output_lte_tac_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE TAC' TLV", offset);
            }

            self->arg_lte_tac_set = TRUE;

qmi_indication_nas_serving_system_output_lte_tac_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_hdr_personality_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_hdr_personality_out;
                self->arg_hdr_personality = (QmiNasHdrPersonality)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'HDR Personality' TLV", offset);
            }

            self->arg_hdr_personality_set = TRUE;

qmi_indication_nas_serving_system_output_hdr_personality_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_cdma_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_mcc), NULL))
                goto qmi_indication_nas_serving_system_output_cdma_system_info_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_cdma_system_info_imsi_11_12), NULL))
                goto qmi_indication_nas_serving_system_output_cdma_system_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA System Info' TLV", offset);
            }

            self->arg_cdma_system_info_set = TRUE;

qmi_indication_nas_serving_system_output_cdma_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_detailed_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_detailed_service_status_out;
                self->arg_detailed_service_status_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_detailed_service_status_out;
                self->arg_detailed_service_status_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_detailed_service_status_out;
                self->arg_detailed_service_status_hdr_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_detailed_service_status_out;
                self->arg_detailed_service_status_hdr_hybrid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_detailed_service_status_out;
                self->arg_detailed_service_status_forbidden = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Detailed Service Status' TLV", offset);
            }

            self->arg_detailed_service_status_set = TRUE;

qmi_indication_nas_serving_system_output_detailed_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_dtm_support_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_dtm_support_out;
                self->arg_dtm_support = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'DTM Support' TLV", offset);
            }

            self->arg_dtm_support_set = TRUE;

qmi_indication_nas_serving_system_output_dtm_support_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_prl_indicator_3gpp2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_prl_indicator_3gpp2_out;
                self->arg_prl_indicator_3gpp2 = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'PRL Indicator 3GPP2' TLV", offset);
            }

            self->arg_prl_indicator_3gpp2_set = TRUE;

qmi_indication_nas_serving_system_output_prl_indicator_3gpp2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_concurrent_service_info_3gpp2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_concurrent_service_info_3gpp2_out;
                self->arg_concurrent_service_info_3gpp2 = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Concurrent Service Info 3GPP2' TLV", offset);
            }

            self->arg_concurrent_service_info_3gpp2_set = TRUE;

qmi_indication_nas_serving_system_output_concurrent_service_info_3gpp2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_cid_3gpp_out;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cid_3gpp), NULL))
                goto qmi_indication_nas_serving_system_output_cid_3gpp_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CID 3GPP' TLV", offset);
            }

            self->arg_cid_3gpp_set = TRUE;

qmi_indication_nas_serving_system_output_cid_3gpp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_lac_3gpp_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lac_3gpp), NULL))
                goto qmi_indication_nas_serving_system_output_lac_3gpp_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LAC 3GPP' TLV", offset);
            }

            self->arg_lac_3gpp_set = TRUE;

qmi_indication_nas_serving_system_output_lac_3gpp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UNIVERSAL_TIME_AND_LOCAL_TIME_ZONE_3GPP, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_universal_time_and_local_time_zone_3gpp_year), NULL))
                goto qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_universal_time_and_local_time_zone_3gpp_month), NULL))
                goto qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_universal_time_and_local_time_zone_3gpp_day), NULL))
                goto qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_universal_time_and_local_time_zone_3gpp_hour), NULL))
                goto qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_universal_time_and_local_time_zone_3gpp_minute), NULL))
                goto qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_universal_time_and_local_time_zone_3gpp_second), NULL))
                goto qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_universal_time_and_local_time_zone_3gpp_time_zone), NULL))
                goto qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Universal Time and Local Time Zone 3GPP' TLV", offset);
            }

            self->arg_universal_time_and_local_time_zone_3gpp_set = TRUE;

qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_daylight_saving_time_adjustment_3gpp_out;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_daylight_saving_time_adjustment_3gpp), NULL))
                goto qmi_indication_nas_serving_system_output_daylight_saving_time_adjustment_3gpp_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Daylight Saving Time Adjustment 3GPP' TLV", offset);
            }

            self->arg_daylight_saving_time_adjustment_3gpp_set = TRUE;

qmi_indication_nas_serving_system_output_daylight_saving_time_adjustment_3gpp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_time_zone_3gpp_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_time_zone_3gpp), NULL))
                goto qmi_indication_nas_serving_system_output_time_zone_3gpp_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Time Zone 3GPP' TLV", offset);
            }

            self->arg_time_zone_3gpp_set = TRUE;

qmi_indication_nas_serving_system_output_time_zone_3gpp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NAME_FLAG_3GPP, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_plmn_name_flag_3gpp_out;
            }
            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_plmn_name_flag_3gpp_out;
                self->arg_plmn_name_flag_3gpp = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'PLMN Name Flag 3GPP' TLV", offset);
            }

            self->arg_plmn_name_flag_3gpp_set = TRUE;

qmi_indication_nas_serving_system_output_plmn_name_flag_3gpp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_cdma_p_rev_out;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_cdma_p_rev), NULL))
                goto qmi_indication_nas_serving_system_output_cdma_p_rev_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA P Rev' TLV", offset);
            }

            self->arg_cdma_p_rev_set = TRUE;

qmi_indication_nas_serving_system_output_cdma_p_rev_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_time_zone_3gpp2_out;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_time_zone_3gpp2_leap_seconds), NULL))
                goto qmi_indication_nas_serving_system_output_time_zone_3gpp2_out;
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_time_zone_3gpp2_local_time_offset), NULL))
                goto qmi_indication_nas_serving_system_output_time_zone_3gpp2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_time_zone_3gpp2_out;
                self->arg_time_zone_3gpp2_daylight_saving_time = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Time Zone 3GPP2' TLV", offset);
            }

            self->arg_time_zone_3gpp2_set = TRUE;

qmi_indication_nas_serving_system_output_time_zone_3gpp2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_default_roaming_indicator_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_default_roaming_indicator_out;
                self->arg_default_roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Default Roaming Indicator' TLV", offset);
            }

            self->arg_default_roaming_indicator_set = TRUE;

qmi_indication_nas_serving_system_output_default_roaming_indicator_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_roaming_indicator_list_out;
            }
            {
                guint roaming_indicator_list_i;
                guint8 roaming_indicator_list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(roaming_indicator_list_n_items), NULL))
                    goto qmi_indication_nas_serving_system_output_roaming_indicator_list_out;

                self->arg_roaming_indicator_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiIndicationNasServingSystemOutputRoamingIndicatorListElement),
                    (guint)roaming_indicator_list_n_items);

                for (roaming_indicator_list_i = 0; roaming_indicator_list_i < roaming_indicator_list_n_items; roaming_indicator_list_i++) {
                    QmiIndicationNasServingSystemOutputRoamingIndicatorListElement roaming_indicator_list_aux;

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_indication_nas_serving_system_output_roaming_indicator_list_out;
                        roaming_indicator_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                    }
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_indication_nas_serving_system_output_roaming_indicator_list_out;
                        roaming_indicator_list_aux.roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
                    }
                    g_array_insert_val (self->arg_roaming_indicator_list, roaming_indicator_list_i, roaming_indicator_list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Roaming Indicator List' TLV", offset);
            }

            self->arg_roaming_indicator_list_set = TRUE;

qmi_indication_nas_serving_system_output_roaming_indicator_list_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_cdma_base_station_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_base_station_info_base_station_id), NULL))
                goto qmi_indication_nas_serving_system_output_cdma_base_station_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_base_station_info_base_station_latitude), NULL))
                goto qmi_indication_nas_serving_system_output_cdma_base_station_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_base_station_info_base_station_longitude), NULL))
                goto qmi_indication_nas_serving_system_output_cdma_base_station_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA Base Station Info' TLV", offset);
            }

            self->arg_cdma_base_station_info_set = TRUE;

qmi_indication_nas_serving_system_output_cdma_base_station_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_cdma_system_id_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_id_sid), NULL))
                goto qmi_indication_nas_serving_system_output_cdma_system_id_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_id_nid), NULL))
                goto qmi_indication_nas_serving_system_output_cdma_system_id_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA System ID' TLV", offset);
            }

            self->arg_cdma_system_id_set = TRUE;

qmi_indication_nas_serving_system_output_cdma_system_id_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_current_plmn_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_current_plmn_mcc), NULL))
                goto qmi_indication_nas_serving_system_output_current_plmn_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_current_plmn_mnc), NULL))
                goto qmi_indication_nas_serving_system_output_current_plmn_out;
            if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &(self->arg_current_plmn_description), NULL))
                goto qmi_indication_nas_serving_system_output_current_plmn_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Current PLMN' TLV", offset);
            }

            self->arg_current_plmn_set = TRUE;

qmi_indication_nas_serving_system_output_current_plmn_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_data_service_capability_out;
            }
            {
                guint data_service_capability_i;
                guint8 data_service_capability_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(data_service_capability_n_items), NULL))
                    goto qmi_indication_nas_serving_system_output_data_service_capability_out;

                self->arg_data_service_capability = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiNasDataCapability),
                    (guint)data_service_capability_n_items);

                for (data_service_capability_i = 0; data_service_capability_i < data_service_capability_n_items; data_service_capability_i++) {
                    QmiNasDataCapability data_service_capability_aux;

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_indication_nas_serving_system_output_data_service_capability_out;
                        data_service_capability_aux = (QmiNasDataCapability)tmp;
                    }
                    g_array_insert_val (self->arg_data_service_capability, data_service_capability_i, data_service_capability_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Data Service Capability' TLV", offset);
            }

            self->arg_data_service_capability_set = TRUE;

qmi_indication_nas_serving_system_output_data_service_capability_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR, NULL, NULL)) == 0) {
                goto qmi_indication_nas_serving_system_output_roaming_indicator_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_serving_system_output_roaming_indicator_out;
                self->arg_roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Roaming Indicator' TLV", offset);
            }

            self->arg_roaming_indicator_set = TRUE;

qmi_indication_nas_serving_system_output_roaming_indicator_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Serving System TLV: ");
                qmi_indication_nas_serving_system_output_unref (self);
                return NULL;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_indication_nas_serving_system_output_serving_system_out;
                self->arg_serving_system_registration_state = (QmiNasRegistrationState)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_indication_nas_serving_system_output_serving_system_out;
                self->arg_serving_system_cs_attach_state = (QmiNasAttachState)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_indication_nas_serving_system_output_serving_system_out;
                self->arg_serving_system_ps_attach_state = (QmiNasAttachState)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_indication_nas_serving_system_output_serving_system_out;
                self->arg_serving_system_selected_network = (QmiNasNetworkType)tmp;
            }
            {
                guint radio_interfaces_i;
                guint8 radio_interfaces_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(radio_interfaces_n_items), error))
                    goto qmi_indication_nas_serving_system_output_serving_system_out;

                self->arg_serving_system_radio_interfaces = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiNasRadioInterface),
                    (guint)radio_interfaces_n_items);

                for (radio_interfaces_i = 0; radio_interfaces_i < radio_interfaces_n_items; radio_interfaces_i++) {
                    QmiNasRadioInterface radio_interfaces_aux;

                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, error))
                            goto qmi_indication_nas_serving_system_output_serving_system_out;
                        radio_interfaces_aux = (QmiNasRadioInterface)tmp;
                    }
                    g_array_insert_val (self->arg_serving_system_radio_interfaces, radio_interfaces_i, radio_interfaces_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Serving System' TLV", offset);
            }

            self->arg_serving_system_set = TRUE;

qmi_indication_nas_serving_system_output_serving_system_out:
            if (!self->arg_serving_system_set) {
                qmi_indication_nas_serving_system_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication NAS Operator Name */


/* --- Output -- */

static void
operator_plmn_name_qmiindicationnasoperatornameoutputoperatorplmnnameelement_clear (QmiIndicationNasOperatorNameOutputOperatorPlmnNameElement *p)
{
    if ((*p).long_name)
        g_array_unref ((*p).long_name);
    if ((*p).short_name)
        g_array_unref ((*p).short_name);
}

static void
operator_plmn_list_qmiindicationnasoperatornameoutputoperatorplmnlistelement_clear (QmiIndicationNasOperatorNameOutputOperatorPlmnListElement *p)
{
    g_free ((*p).mcc);
    g_free ((*p).mnc);
}

struct _QmiIndicationNasOperatorNameOutput {
    volatile gint ref_count;

    /* NITZ Information */
    gboolean arg_nitz_information_set;
    guint8 arg_nitz_information_name_encoding;
    guint8 arg_nitz_information_short_country_initials;
    guint8 arg_nitz_information_long_name_spare_bits;
    guint8 arg_nitz_information_short_name_spare_bits;
    GArray *arg_nitz_information_long_name;
    GArray *arg_nitz_information_short_name;

    /* Operator String Name */
    gboolean arg_operator_string_name_set;
    gchar *arg_operator_string_name;

    /* Operator PLMN Name */
    gboolean arg_operator_plmn_name_set;
    GArray *arg_operator_plmn_name;

    /* Operator PLMN List */
    gboolean arg_operator_plmn_list_set;
    GArray *arg_operator_plmn_list;

    /* Service Provider Name */
    gboolean arg_service_provider_name_set;
    guint8 arg_service_provider_name_name_display_condition;
    gchar *arg_service_provider_name_name;
};

#define QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_NITZ_INFORMATION 0x14
#define QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_STRING_NAME 0x13
#define QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_NAME 0x12
#define QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_LIST 0x11
#define QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_SERVICE_PROVIDER_NAME 0x10

gboolean
qmi_indication_nas_operator_name_output_get_nitz_information (
    QmiIndicationNasOperatorNameOutput *self,
    QmiNasPlmnEncodingScheme *value_nitz_information_name_encoding,
    QmiNasPlmnNameCountryInitials *value_nitz_information_short_country_initials,
    QmiNasPlmnNameSpareBits *value_nitz_information_long_name_spare_bits,
    QmiNasPlmnNameSpareBits *value_nitz_information_short_name_spare_bits,
    GArray **value_nitz_information_long_name,
    GArray **value_nitz_information_short_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_nitz_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'NITZ Information' was not found in the message");
        return FALSE;
    }

    if (value_nitz_information_name_encoding)
        *value_nitz_information_name_encoding = (QmiNasPlmnEncodingScheme)(self->arg_nitz_information_name_encoding);
    if (value_nitz_information_short_country_initials)
        *value_nitz_information_short_country_initials = (QmiNasPlmnNameCountryInitials)(self->arg_nitz_information_short_country_initials);
    if (value_nitz_information_long_name_spare_bits)
        *value_nitz_information_long_name_spare_bits = (QmiNasPlmnNameSpareBits)(self->arg_nitz_information_long_name_spare_bits);
    if (value_nitz_information_short_name_spare_bits)
        *value_nitz_information_short_name_spare_bits = (QmiNasPlmnNameSpareBits)(self->arg_nitz_information_short_name_spare_bits);
    if (value_nitz_information_long_name)
        *value_nitz_information_long_name = self->arg_nitz_information_long_name;
    if (value_nitz_information_short_name)
        *value_nitz_information_short_name = self->arg_nitz_information_short_name;

    return TRUE;
}

gboolean
qmi_indication_nas_operator_name_output_get_operator_string_name (
    QmiIndicationNasOperatorNameOutput *self,
    const gchar **value_operator_string_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_operator_string_name_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Operator String Name' was not found in the message");
        return FALSE;
    }

    if (value_operator_string_name)
        *value_operator_string_name = self->arg_operator_string_name;

    return TRUE;
}

gboolean
qmi_indication_nas_operator_name_output_get_operator_plmn_name (
    QmiIndicationNasOperatorNameOutput *self,
    GArray **value_operator_plmn_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_operator_plmn_name_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Operator PLMN Name' was not found in the message");
        return FALSE;
    }

    if (value_operator_plmn_name)
        *value_operator_plmn_name = self->arg_operator_plmn_name;

    return TRUE;
}

gboolean
qmi_indication_nas_operator_name_output_get_operator_plmn_list (
    QmiIndicationNasOperatorNameOutput *self,
    GArray **value_operator_plmn_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_operator_plmn_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Operator PLMN List' was not found in the message");
        return FALSE;
    }

    if (value_operator_plmn_list)
        *value_operator_plmn_list = self->arg_operator_plmn_list;

    return TRUE;
}

gboolean
qmi_indication_nas_operator_name_output_get_service_provider_name (
    QmiIndicationNasOperatorNameOutput *self,
    QmiNasNetworkNameDisplayCondition *value_service_provider_name_name_display_condition,
    const gchar **value_service_provider_name_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_service_provider_name_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Service Provider Name' was not found in the message");
        return FALSE;
    }

    if (value_service_provider_name_name_display_condition)
        *value_service_provider_name_name_display_condition = (QmiNasNetworkNameDisplayCondition)(self->arg_service_provider_name_name_display_condition);
    if (value_service_provider_name_name)
        *value_service_provider_name_name = self->arg_service_provider_name_name;

    return TRUE;
}

GType
qmi_indication_nas_operator_name_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasOperatorNameOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_operator_name_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_operator_name_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiIndicationNasOperatorNameOutput *
qmi_indication_nas_operator_name_output_ref (QmiIndicationNasOperatorNameOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_indication_nas_operator_name_output_unref (QmiIndicationNasOperatorNameOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_nitz_information_long_name)
            g_array_unref (self->arg_nitz_information_long_name);
        if (self->arg_nitz_information_short_name)
            g_array_unref (self->arg_nitz_information_short_name);
        g_free (self->arg_operator_string_name);
        if (self->arg_operator_plmn_name)
            g_array_unref (self->arg_operator_plmn_name);
        if (self->arg_operator_plmn_list)
            g_array_unref (self->arg_operator_plmn_list);
        g_free (self->arg_service_provider_name_name);
        g_slice_free (QmiIndicationNasOperatorNameOutput, self);
    }
}

static gchar *
qmi_indication_nas_operator_name_output_nitz_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_NITZ_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " name_encoding = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_ENCODING_SCHEME_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_encoding_scheme_get_string ((QmiNasPlmnEncodingScheme)tmp));
#elif defined  __QMI_NAS_PLMN_ENCODING_SCHEME_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_encoding_scheme_build_string_from_mask ((QmiNasPlmnEncodingScheme)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnEncodingScheme
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " short_country_initials = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_name_country_initials_get_string ((QmiNasPlmnNameCountryInitials)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_name_country_initials_build_string_from_mask ((QmiNasPlmnNameCountryInitials)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnNameCountryInitials
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " long_name_spare_bits = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_name_spare_bits_get_string ((QmiNasPlmnNameSpareBits)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_name_spare_bits_build_string_from_mask ((QmiNasPlmnNameSpareBits)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnNameSpareBits
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " short_name_spare_bits = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_name_spare_bits_get_string ((QmiNasPlmnNameSpareBits)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_name_spare_bits_build_string_from_mask ((QmiNasPlmnNameSpareBits)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnNameSpareBits
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " long_name = '");
    {
        guint long_name_i;
        guint8 long_name_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
            g_string_append_printf (printable, " [%u] = '", long_name_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " short_name = '");
    {
        guint short_name_i;
        guint8 short_name_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
            g_string_append_printf (printable, " [%u] = '", short_name_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_operator_name_output_operator_string_name_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_STRING_NAME, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        g_autofree gchar *tmp = NULL;

        if (!qmi_message_tlv_read_string (message, init_offset, &offset, 0, 0, &tmp, &error))
            goto out;
        g_string_append (printable, tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_operator_name_output_operator_plmn_name_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_NAME, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint operator_plmn_name_i;
        guint8 operator_plmn_name_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(operator_plmn_name_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (operator_plmn_name_i = 0; operator_plmn_name_i < operator_plmn_name_n_items; operator_plmn_name_i++) {
            g_string_append_printf (printable, " [%u] = '", operator_plmn_name_i);
            g_string_append (printable, "[");
            g_string_append (printable, " name_encoding = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_PLMN_ENCODING_SCHEME_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_plmn_encoding_scheme_get_string ((QmiNasPlmnEncodingScheme)tmp));
#elif defined  __QMI_NAS_PLMN_ENCODING_SCHEME_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_plmn_encoding_scheme_build_string_from_mask ((QmiNasPlmnEncodingScheme)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasPlmnEncodingScheme
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " short_country_initials = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_plmn_name_country_initials_get_string ((QmiNasPlmnNameCountryInitials)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_plmn_name_country_initials_build_string_from_mask ((QmiNasPlmnNameCountryInitials)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasPlmnNameCountryInitials
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " long_name_spare_bits = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_plmn_name_spare_bits_get_string ((QmiNasPlmnNameSpareBits)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_plmn_name_spare_bits_build_string_from_mask ((QmiNasPlmnNameSpareBits)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasPlmnNameSpareBits
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " short_name_spare_bits = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_plmn_name_spare_bits_get_string ((QmiNasPlmnNameSpareBits)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_plmn_name_spare_bits_build_string_from_mask ((QmiNasPlmnNameSpareBits)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasPlmnNameSpareBits
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " long_name = '");
            {
                guint long_name_i;
                guint8 long_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), &error))
                    goto out;

                g_string_append (printable, "{");

                for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
                    g_string_append_printf (printable, " [%u] = '", long_name_i);

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%u", (guint)tmp);
                    }
                    g_string_append (printable, " '");
                }

                g_string_append (printable, "}");
            }            g_string_append (printable, "'");
            g_string_append (printable, " short_name = '");
            {
                guint short_name_i;
                guint8 short_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), &error))
                    goto out;

                g_string_append (printable, "{");

                for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
                    g_string_append_printf (printable, " [%u] = '", short_name_i);

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%u", (guint)tmp);
                    }
                    g_string_append (printable, " '");
                }

                g_string_append (printable, "}");
            }            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_operator_name_output_operator_plmn_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint operator_plmn_list_i;
        guint16 operator_plmn_list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(operator_plmn_list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (operator_plmn_list_i = 0; operator_plmn_list_i < operator_plmn_list_n_items; operator_plmn_list_i++) {
            g_string_append_printf (printable, " [%u] = '", operator_plmn_list_i);
            g_string_append (printable, "[");
            g_string_append (printable, " mcc = '");

            {
                gchar tmp[4];

                if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
                    goto out;
                tmp[3] = '\0';
                g_string_append (printable, tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " mnc = '");

            {
                gchar tmp[4];

                if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
                    goto out;
                tmp[3] = '\0';
                g_string_append (printable, tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " lac1 = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " lac2 = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " plmn_name_record_identifier = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_operator_name_output_service_provider_name_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_SERVICE_PROVIDER_NAME, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " name_display_condition = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_name_display_condition_get_string ((QmiNasNetworkNameDisplayCondition)tmp));
#elif defined  __QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_name_display_condition_build_string_from_mask ((QmiNasNetworkNameDisplayCondition)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkNameDisplayCondition
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " name = '");

    {
        g_autofree gchar *tmp = NULL;

        if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &tmp, &error))
            goto out;
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct indication_operator_name_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_operator_name_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_operator_name_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    {
        switch (type) {
        case QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_NITZ_INFORMATION:
            tlv_type_str = "NITZ Information";
            translated_value = qmi_indication_nas_operator_name_output_nitz_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_STRING_NAME:
            tlv_type_str = "Operator String Name";
            translated_value = qmi_indication_nas_operator_name_output_operator_string_name_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_NAME:
            tlv_type_str = "Operator PLMN Name";
            translated_value = qmi_indication_nas_operator_name_output_operator_plmn_name_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_LIST:
            tlv_type_str = "Operator PLMN List";
            translated_value = qmi_indication_nas_operator_name_output_operator_plmn_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_SERVICE_PROVIDER_NAME:
            tlv_type_str = "Service Provider Name";
            translated_value = qmi_indication_nas_operator_name_output_service_provider_name_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
indication_operator_name_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Operator Name\" (0x003A)\n",
                            line_prefix);

    {
        struct indication_operator_name_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_operator_name_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasOperatorNameOutput *
__qmi_indication_nas_operator_name_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasOperatorNameOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_INDICATION_NAS_OPERATOR_NAME);

    self = g_slice_new0 (QmiIndicationNasOperatorNameOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_NITZ_INFORMATION, NULL, NULL)) == 0) {
                goto qmi_indication_nas_operator_name_output_nitz_information_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_operator_name_output_nitz_information_out;
                self->arg_nitz_information_name_encoding = (QmiNasPlmnEncodingScheme)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_operator_name_output_nitz_information_out;
                self->arg_nitz_information_short_country_initials = (QmiNasPlmnNameCountryInitials)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_operator_name_output_nitz_information_out;
                self->arg_nitz_information_long_name_spare_bits = (QmiNasPlmnNameSpareBits)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_operator_name_output_nitz_information_out;
                self->arg_nitz_information_short_name_spare_bits = (QmiNasPlmnNameSpareBits)tmp;
            }
            {
                guint long_name_i;
                guint8 long_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), NULL))
                    goto qmi_indication_nas_operator_name_output_nitz_information_out;

                self->arg_nitz_information_long_name = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)long_name_n_items);

                for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
                    guint8 long_name_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_aux), NULL))
                        goto qmi_indication_nas_operator_name_output_nitz_information_out;
                    g_array_insert_val (self->arg_nitz_information_long_name, long_name_i, long_name_aux);
                }
            }
            {
                guint short_name_i;
                guint8 short_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), NULL))
                    goto qmi_indication_nas_operator_name_output_nitz_information_out;

                self->arg_nitz_information_short_name = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)short_name_n_items);

                for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
                    guint8 short_name_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_aux), NULL))
                        goto qmi_indication_nas_operator_name_output_nitz_information_out;
                    g_array_insert_val (self->arg_nitz_information_short_name, short_name_i, short_name_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'NITZ Information' TLV", offset);
            }

            self->arg_nitz_information_set = TRUE;

qmi_indication_nas_operator_name_output_nitz_information_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_STRING_NAME, NULL, NULL)) == 0) {
                goto qmi_indication_nas_operator_name_output_operator_string_name_out;
            }
            if (!qmi_message_tlv_read_string (message, init_offset, &offset, 0, 0, &(self->arg_operator_string_name), NULL))
                goto qmi_indication_nas_operator_name_output_operator_string_name_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Operator String Name' TLV", offset);
            }

            self->arg_operator_string_name_set = TRUE;

qmi_indication_nas_operator_name_output_operator_string_name_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_NAME, NULL, NULL)) == 0) {
                goto qmi_indication_nas_operator_name_output_operator_plmn_name_out;
            }
            {
                guint operator_plmn_name_i;
                guint8 operator_plmn_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(operator_plmn_name_n_items), NULL))
                    goto qmi_indication_nas_operator_name_output_operator_plmn_name_out;

                self->arg_operator_plmn_name = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiIndicationNasOperatorNameOutputOperatorPlmnNameElement),
                    (guint)operator_plmn_name_n_items);

                g_array_set_clear_func (self->arg_operator_plmn_name,
                                        (GDestroyNotify)operator_plmn_name_qmiindicationnasoperatornameoutputoperatorplmnnameelement_clear);

                for (operator_plmn_name_i = 0; operator_plmn_name_i < operator_plmn_name_n_items; operator_plmn_name_i++) {
                    QmiIndicationNasOperatorNameOutputOperatorPlmnNameElement operator_plmn_name_aux;

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_indication_nas_operator_name_output_operator_plmn_name_out;
                        operator_plmn_name_aux.name_encoding = (QmiNasPlmnEncodingScheme)tmp;
                    }
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_indication_nas_operator_name_output_operator_plmn_name_out;
                        operator_plmn_name_aux.short_country_initials = (QmiNasPlmnNameCountryInitials)tmp;
                    }
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_indication_nas_operator_name_output_operator_plmn_name_out;
                        operator_plmn_name_aux.long_name_spare_bits = (QmiNasPlmnNameSpareBits)tmp;
                    }
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_indication_nas_operator_name_output_operator_plmn_name_out;
                        operator_plmn_name_aux.short_name_spare_bits = (QmiNasPlmnNameSpareBits)tmp;
                    }
                    {
                        guint long_name_i;
                        guint8 long_name_n_items;

                        /* Read number of items in the array */
                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), NULL))
                            goto qmi_indication_nas_operator_name_output_operator_plmn_name_out;

                        operator_plmn_name_aux.long_name = g_array_sized_new (
                            FALSE,
                            FALSE,
                            sizeof (guint8),
                            (guint)long_name_n_items);

                        for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
                            guint8 long_name_aux;

                            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_aux), NULL))
                                goto qmi_indication_nas_operator_name_output_operator_plmn_name_out;
                            g_array_insert_val (operator_plmn_name_aux.long_name, long_name_i, long_name_aux);
                        }
                    }
                    {
                        guint short_name_i;
                        guint8 short_name_n_items;

                        /* Read number of items in the array */
                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), NULL))
                            goto qmi_indication_nas_operator_name_output_operator_plmn_name_out;

                        operator_plmn_name_aux.short_name = g_array_sized_new (
                            FALSE,
                            FALSE,
                            sizeof (guint8),
                            (guint)short_name_n_items);

                        for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
                            guint8 short_name_aux;

                            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_aux), NULL))
                                goto qmi_indication_nas_operator_name_output_operator_plmn_name_out;
                            g_array_insert_val (operator_plmn_name_aux.short_name, short_name_i, short_name_aux);
                        }
                    }
                    g_array_insert_val (self->arg_operator_plmn_name, operator_plmn_name_i, operator_plmn_name_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Operator PLMN Name' TLV", offset);
            }

            self->arg_operator_plmn_name_set = TRUE;

qmi_indication_nas_operator_name_output_operator_plmn_name_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_LIST, NULL, NULL)) == 0) {
                goto qmi_indication_nas_operator_name_output_operator_plmn_list_out;
            }
            {
                guint operator_plmn_list_i;
                guint16 operator_plmn_list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(operator_plmn_list_n_items), NULL))
                    goto qmi_indication_nas_operator_name_output_operator_plmn_list_out;

                self->arg_operator_plmn_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiIndicationNasOperatorNameOutputOperatorPlmnListElement),
                    (guint)operator_plmn_list_n_items);

                g_array_set_clear_func (self->arg_operator_plmn_list,
                                        (GDestroyNotify)operator_plmn_list_qmiindicationnasoperatornameoutputoperatorplmnlistelement_clear);

                for (operator_plmn_list_i = 0; operator_plmn_list_i < operator_plmn_list_n_items; operator_plmn_list_i++) {
                    QmiIndicationNasOperatorNameOutputOperatorPlmnListElement operator_plmn_list_aux;

                    operator_plmn_list_aux.mcc = g_malloc (4);
                    if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &operator_plmn_list_aux.mcc[0], NULL)) {
                        g_free (operator_plmn_list_aux.mcc);
                        operator_plmn_list_aux.mcc = NULL;
                        goto qmi_indication_nas_operator_name_output_operator_plmn_list_out;
                    }
                    operator_plmn_list_aux.mcc[3] = '\0';
                    operator_plmn_list_aux.mnc = g_malloc (4);
                    if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &operator_plmn_list_aux.mnc[0], NULL)) {
                        g_free (operator_plmn_list_aux.mnc);
                        operator_plmn_list_aux.mnc = NULL;
                        goto qmi_indication_nas_operator_name_output_operator_plmn_list_out;
                    }
                    operator_plmn_list_aux.mnc[3] = '\0';
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(operator_plmn_list_aux.lac1), NULL))
                        goto qmi_indication_nas_operator_name_output_operator_plmn_list_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(operator_plmn_list_aux.lac2), NULL))
                        goto qmi_indication_nas_operator_name_output_operator_plmn_list_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(operator_plmn_list_aux.plmn_name_record_identifier), NULL))
                        goto qmi_indication_nas_operator_name_output_operator_plmn_list_out;
                    g_array_insert_val (self->arg_operator_plmn_list, operator_plmn_list_i, operator_plmn_list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Operator PLMN List' TLV", offset);
            }

            self->arg_operator_plmn_list_set = TRUE;

qmi_indication_nas_operator_name_output_operator_plmn_list_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_OPERATOR_NAME_OUTPUT_TLV_SERVICE_PROVIDER_NAME, NULL, NULL)) == 0) {
                goto qmi_indication_nas_operator_name_output_service_provider_name_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_operator_name_output_service_provider_name_out;
                self->arg_service_provider_name_name_display_condition = (QmiNasNetworkNameDisplayCondition)tmp;
            }
            if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &(self->arg_service_provider_name_name), NULL))
                goto qmi_indication_nas_operator_name_output_service_provider_name_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Service Provider Name' TLV", offset);
            }

            self->arg_service_provider_name_set = TRUE;

qmi_indication_nas_operator_name_output_service_provider_name_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication NAS Network Time */


/* --- Output -- */

struct _QmiIndicationNasNetworkTimeOutput {
    volatile gint ref_count;

    /* Radio Interface */
    gboolean arg_radio_interface_set;
    gint8 arg_radio_interface;

    /* Daylight Savings Adjustment */
    gboolean arg_daylight_savings_adjustment_set;
    guint8 arg_daylight_savings_adjustment;

    /* Timezone Offset */
    gboolean arg_timezone_offset_set;
    gint8 arg_timezone_offset;

    /* Universal Time */
    gboolean arg_universal_time_set;
    guint16 arg_universal_time_year;
    guint8 arg_universal_time_month;
    guint8 arg_universal_time_day;
    guint8 arg_universal_time_hour;
    guint8 arg_universal_time_minute;
    guint8 arg_universal_time_second;
    guint8 arg_universal_time_day_of_week;
};

#define QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_RADIO_INTERFACE 0x12
#define QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_DAYLIGHT_SAVINGS_ADJUSTMENT 0x11
#define QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_TIMEZONE_OFFSET 0x10
#define QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_UNIVERSAL_TIME 0x01

gboolean
qmi_indication_nas_network_time_output_get_radio_interface (
    QmiIndicationNasNetworkTimeOutput *self,
    QmiNasRadioInterface *value_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_radio_interface_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Radio Interface' was not found in the message");
        return FALSE;
    }

    if (value_radio_interface)
        *value_radio_interface = (QmiNasRadioInterface)(self->arg_radio_interface);

    return TRUE;
}

gboolean
qmi_indication_nas_network_time_output_get_daylight_savings_adjustment (
    QmiIndicationNasNetworkTimeOutput *self,
    QmiNasDaylightSavingsAdjustment *value_daylight_savings_adjustment,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_daylight_savings_adjustment_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Daylight Savings Adjustment' was not found in the message");
        return FALSE;
    }

    if (value_daylight_savings_adjustment)
        *value_daylight_savings_adjustment = (QmiNasDaylightSavingsAdjustment)(self->arg_daylight_savings_adjustment);

    return TRUE;
}

gboolean
qmi_indication_nas_network_time_output_get_timezone_offset (
    QmiIndicationNasNetworkTimeOutput *self,
    gint8 *value_timezone_offset,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_timezone_offset_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Timezone Offset' was not found in the message");
        return FALSE;
    }

    if (value_timezone_offset)
        *value_timezone_offset = self->arg_timezone_offset;

    return TRUE;
}

gboolean
qmi_indication_nas_network_time_output_get_universal_time (
    QmiIndicationNasNetworkTimeOutput *self,
    guint16 *value_universal_time_year,
    guint8 *value_universal_time_month,
    guint8 *value_universal_time_day,
    guint8 *value_universal_time_hour,
    guint8 *value_universal_time_minute,
    guint8 *value_universal_time_second,
    QmiNasDayOfWeek *value_universal_time_day_of_week,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_universal_time_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Universal Time' was not found in the message");
        return FALSE;
    }

    if (value_universal_time_year)
        *value_universal_time_year = self->arg_universal_time_year;
    if (value_universal_time_month)
        *value_universal_time_month = self->arg_universal_time_month;
    if (value_universal_time_day)
        *value_universal_time_day = self->arg_universal_time_day;
    if (value_universal_time_hour)
        *value_universal_time_hour = self->arg_universal_time_hour;
    if (value_universal_time_minute)
        *value_universal_time_minute = self->arg_universal_time_minute;
    if (value_universal_time_second)
        *value_universal_time_second = self->arg_universal_time_second;
    if (value_universal_time_day_of_week)
        *value_universal_time_day_of_week = (QmiNasDayOfWeek)(self->arg_universal_time_day_of_week);

    return TRUE;
}

GType
qmi_indication_nas_network_time_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasNetworkTimeOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_network_time_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_network_time_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiIndicationNasNetworkTimeOutput *
qmi_indication_nas_network_time_output_ref (QmiIndicationNasNetworkTimeOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_indication_nas_network_time_output_unref (QmiIndicationNasNetworkTimeOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiIndicationNasNetworkTimeOutput, self);
    }
}

static gchar *
qmi_indication_nas_network_time_output_radio_interface_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_RADIO_INTERFACE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_network_time_output_daylight_savings_adjustment_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_DAYLIGHT_SAVINGS_ADJUSTMENT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_daylight_savings_adjustment_get_string ((QmiNasDaylightSavingsAdjustment)tmp));
#elif defined  __QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_daylight_savings_adjustment_build_string_from_mask ((QmiNasDaylightSavingsAdjustment)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasDaylightSavingsAdjustment
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_network_time_output_timezone_offset_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_TIMEZONE_OFFSET, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_network_time_output_universal_time_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_UNIVERSAL_TIME, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " year = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " month = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " day = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hour = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " minute = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " second = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " day_of_week = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_DAY_OF_WEEK_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_day_of_week_get_string ((QmiNasDayOfWeek)tmp));
#elif defined  __QMI_NAS_DAY_OF_WEEK_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_day_of_week_build_string_from_mask ((QmiNasDayOfWeek)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasDayOfWeek
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct indication_network_time_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_network_time_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_network_time_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    {
        switch (type) {
        case QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_RADIO_INTERFACE:
            tlv_type_str = "Radio Interface";
            translated_value = qmi_indication_nas_network_time_output_radio_interface_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_DAYLIGHT_SAVINGS_ADJUSTMENT:
            tlv_type_str = "Daylight Savings Adjustment";
            translated_value = qmi_indication_nas_network_time_output_daylight_savings_adjustment_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_TIMEZONE_OFFSET:
            tlv_type_str = "Timezone Offset";
            translated_value = qmi_indication_nas_network_time_output_timezone_offset_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_UNIVERSAL_TIME:
            tlv_type_str = "Universal Time";
            translated_value = qmi_indication_nas_network_time_output_universal_time_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
indication_network_time_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Network Time\" (0x004C)\n",
                            line_prefix);

    {
        struct indication_network_time_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_network_time_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasNetworkTimeOutput *
__qmi_indication_nas_network_time_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasNetworkTimeOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_INDICATION_NAS_NETWORK_TIME);

    self = g_slice_new0 (QmiIndicationNasNetworkTimeOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_RADIO_INTERFACE, NULL, NULL)) == 0) {
                goto qmi_indication_nas_network_time_output_radio_interface_out;
            }
            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_network_time_output_radio_interface_out;
                self->arg_radio_interface = (QmiNasRadioInterface)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Radio Interface' TLV", offset);
            }

            self->arg_radio_interface_set = TRUE;

qmi_indication_nas_network_time_output_radio_interface_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_DAYLIGHT_SAVINGS_ADJUSTMENT, NULL, NULL)) == 0) {
                goto qmi_indication_nas_network_time_output_daylight_savings_adjustment_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_network_time_output_daylight_savings_adjustment_out;
                self->arg_daylight_savings_adjustment = (QmiNasDaylightSavingsAdjustment)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Daylight Savings Adjustment' TLV", offset);
            }

            self->arg_daylight_savings_adjustment_set = TRUE;

qmi_indication_nas_network_time_output_daylight_savings_adjustment_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_TIMEZONE_OFFSET, NULL, NULL)) == 0) {
                goto qmi_indication_nas_network_time_output_timezone_offset_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_timezone_offset), NULL))
                goto qmi_indication_nas_network_time_output_timezone_offset_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Timezone Offset' TLV", offset);
            }

            self->arg_timezone_offset_set = TRUE;

qmi_indication_nas_network_time_output_timezone_offset_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_UNIVERSAL_TIME, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Universal Time TLV: ");
                qmi_indication_nas_network_time_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_universal_time_year), error))
                goto qmi_indication_nas_network_time_output_universal_time_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_universal_time_month), error))
                goto qmi_indication_nas_network_time_output_universal_time_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_universal_time_day), error))
                goto qmi_indication_nas_network_time_output_universal_time_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_universal_time_hour), error))
                goto qmi_indication_nas_network_time_output_universal_time_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_universal_time_minute), error))
                goto qmi_indication_nas_network_time_output_universal_time_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_universal_time_second), error))
                goto qmi_indication_nas_network_time_output_universal_time_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_indication_nas_network_time_output_universal_time_out;
                self->arg_universal_time_day_of_week = (QmiNasDayOfWeek)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Universal Time' TLV", offset);
            }

            self->arg_universal_time_set = TRUE;

qmi_indication_nas_network_time_output_universal_time_out:
            if (!self->arg_universal_time_set) {
                qmi_indication_nas_network_time_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication NAS System Info */


/* --- Output -- */

struct _QmiIndicationNasSystemInfoOutput {
    volatile gint ref_count;

    /* NR5G Tracking Area Code */
    gboolean arg_nr5g_tracking_area_code_set;
    GArray *arg_nr5g_tracking_area_code;

    /* DCNR restriction Info */
    gboolean arg_dcnr_restriction_info_set;
    guint8 arg_dcnr_restriction_info;

    /* EUTRA with NR5G availability */
    gboolean arg_eutra_with_nr5g_availability_set;
    guint8 arg_eutra_with_nr5g_availability;

    /* NR5G System Info */
    gboolean arg_nr5g_system_info_set;
    guint8 arg_nr5g_system_info_domain_valid;
    guint8 arg_nr5g_system_info_domain;
    guint8 arg_nr5g_system_info_service_capability_valid;
    guint8 arg_nr5g_system_info_service_capability;
    guint8 arg_nr5g_system_info_roaming_status_valid;
    guint8 arg_nr5g_system_info_roaming_status;
    guint8 arg_nr5g_system_info_forbidden_valid;
    guint8 arg_nr5g_system_info_forbidden;
    guint8 arg_nr5g_system_info_lac_valid;
    guint16 arg_nr5g_system_info_lac;
    guint8 arg_nr5g_system_info_cid_valid;
    guint32 arg_nr5g_system_info_cid;
    guint8 arg_nr5g_system_info_registration_reject_info_valid;
    guint8 arg_nr5g_system_info_registration_reject_domain;
    guint8 arg_nr5g_system_info_registration_reject_cause;
    guint8 arg_nr5g_system_info_network_id_valid;
    gchar arg_nr5g_system_info_mcc[4];
    gchar arg_nr5g_system_info_mnc[4];
    guint8 arg_nr5g_system_info_tac_valid;
    guint16 arg_nr5g_system_info_tac;

    /* NR5G Service Status Info */
    gboolean arg_nr5g_service_status_info_set;
    guint8 arg_nr5g_service_status_info_service_status;
    guint8 arg_nr5g_service_status_info_true_service_status;
    guint8 arg_nr5g_service_status_info_preferred_data_path;

    /* SIM Reject Info */
    gboolean arg_sim_reject_info_set;
    guint32 arg_sim_reject_info;

    /* LTE eMBMS Coverage Info Support */
    gboolean arg_lte_embms_coverage_info_support_set;
    guint8 arg_lte_embms_coverage_info_support;

    /* TD SCMA System Info v2 */
    gboolean arg_td_scma_system_info_v2_set;
    guint8 arg_td_scma_system_info_v2_domain_valid;
    guint8 arg_td_scma_system_info_v2_domain;
    guint8 arg_td_scma_system_info_v2_service_capability_valid;
    guint8 arg_td_scma_system_info_v2_service_capability;
    guint8 arg_td_scma_system_info_v2_roaming_status_valid;
    guint8 arg_td_scma_system_info_v2_roaming_status;
    guint8 arg_td_scma_system_info_v2_forbidden_valid;
    guint8 arg_td_scma_system_info_v2_forbidden;
    guint8 arg_td_scma_system_info_v2_lac_valid;
    guint16 arg_td_scma_system_info_v2_lac;
    guint8 arg_td_scma_system_info_v2_cid_valid;
    guint32 arg_td_scma_system_info_v2_cid;
    guint8 arg_td_scma_system_info_v2_registration_reject_info_valid;
    guint8 arg_td_scma_system_info_v2_registration_reject_domain;
    guint8 arg_td_scma_system_info_v2_registration_reject_cause;
    guint8 arg_td_scma_system_info_v2_network_id_valid;
    gchar arg_td_scma_system_info_v2_mcc[4];
    gchar arg_td_scma_system_info_v2_mnc[4];
    guint8 arg_td_scma_system_info_v2_hs_call_status_valid;
    guint8 arg_td_scma_system_info_v2_hs_call_status;
    guint8 arg_td_scma_system_info_v2_hs_service_valid;
    guint8 arg_td_scma_system_info_v2_hs_service;
    guint8 arg_td_scma_system_info_v2_cell_parameter_id_valid;
    guint16 arg_td_scma_system_info_v2_cell_parameter_id;
    guint8 arg_td_scma_system_info_v2_cell_broadcast_support_valid;
    guint32 arg_td_scma_system_info_v2_cell_broadcast_support;
    guint8 arg_td_scma_system_info_v2_cs_call_barring_status_valid;
    gint32 arg_td_scma_system_info_v2_cs_call_barring_status;
    guint8 arg_td_scma_system_info_v2_ps_call_barring_status_valid;
    gint32 arg_td_scma_system_info_v2_ps_call_barring_status;
    guint8 arg_td_scma_system_info_v2_cipher_domain_valid;
    guint8 arg_td_scma_system_info_v2_cipher_domain;

    /* TD SCDMA Service Status */
    gboolean arg_td_scdma_service_status_set;
    guint8 arg_td_scdma_service_status_service_status;
    guint8 arg_td_scdma_service_status_true_service_status;
    guint8 arg_td_scdma_service_status_preferred_data_path;

    /* PLMN Not Changed Indication */
    gboolean arg_plmn_not_changed_indication_set;
    guint8 arg_plmn_not_changed_indication;

    /* WCDMA Cipher Domain */
    gboolean arg_wcdma_cipher_domain_set;
    guint8 arg_wcdma_cipher_domain;

    /* GSM Cipher Domain */
    gboolean arg_gsm_cipher_domain_set;
    guint8 arg_gsm_cipher_domain;

    /* LTE Voice Support */
    gboolean arg_lte_voice_support_set;
    guint8 arg_lte_voice_support;

    /* WCDMA Call Barring Status */
    gboolean arg_wcdma_call_barring_status_set;
    gint32 arg_wcdma_call_barring_status_cs_status;
    gint32 arg_wcdma_call_barring_status_ps_status;

    /* GSM Call Barring Status */
    gboolean arg_gsm_call_barring_status_set;
    gint32 arg_gsm_call_barring_status_cs_status;
    gint32 arg_gsm_call_barring_status_ps_status;

    /* Additional LTE System Info */
    gboolean arg_additional_lte_system_info_set;
    guint16 arg_additional_lte_system_info_geo_system_index;

    /* Additional WCDMA System Info */
    gboolean arg_additional_wcdma_system_info_set;
    guint16 arg_additional_wcdma_system_info_geo_system_index;
    guint32 arg_additional_wcdma_system_info_cell_broadcast_support;

    /* Additional GSM System Info */
    gboolean arg_additional_gsm_system_info_set;
    guint16 arg_additional_gsm_system_info_geo_system_index;
    guint32 arg_additional_gsm_system_info_cell_broadcast_support;

    /* Additional HDR System Info */
    gboolean arg_additional_hdr_system_info_set;
    guint16 arg_additional_hdr_system_info_geo_system_index;

    /* Additional CDMA System Info */
    gboolean arg_additional_cdma_system_info_set;
    guint16 arg_additional_cdma_system_info_geo_system_index;
    guint16 arg_additional_cdma_system_info_registration_period;

    /* LTE System Info v2 */
    gboolean arg_lte_system_info_v2_set;
    guint8 arg_lte_system_info_v2_domain_valid;
    guint8 arg_lte_system_info_v2_domain;
    guint8 arg_lte_system_info_v2_service_capability_valid;
    guint8 arg_lte_system_info_v2_service_capability;
    guint8 arg_lte_system_info_v2_roaming_status_valid;
    guint8 arg_lte_system_info_v2_roaming_status;
    guint8 arg_lte_system_info_v2_forbidden_valid;
    guint8 arg_lte_system_info_v2_forbidden;
    guint8 arg_lte_system_info_v2_lac_valid;
    guint16 arg_lte_system_info_v2_lac;
    guint8 arg_lte_system_info_v2_cid_valid;
    guint32 arg_lte_system_info_v2_cid;
    guint8 arg_lte_system_info_v2_registration_reject_info_valid;
    guint8 arg_lte_system_info_v2_registration_reject_domain;
    guint8 arg_lte_system_info_v2_registration_reject_cause;
    guint8 arg_lte_system_info_v2_network_id_valid;
    gchar arg_lte_system_info_v2_mcc[4];
    gchar arg_lte_system_info_v2_mnc[4];
    guint8 arg_lte_system_info_v2_tac_valid;
    guint16 arg_lte_system_info_v2_tac;

    /* WCDMA System Info v2 */
    gboolean arg_wcdma_system_info_v2_set;
    guint8 arg_wcdma_system_info_v2_domain_valid;
    guint8 arg_wcdma_system_info_v2_domain;
    guint8 arg_wcdma_system_info_v2_service_capability_valid;
    guint8 arg_wcdma_system_info_v2_service_capability;
    guint8 arg_wcdma_system_info_v2_roaming_status_valid;
    guint8 arg_wcdma_system_info_v2_roaming_status;
    guint8 arg_wcdma_system_info_v2_forbidden_valid;
    guint8 arg_wcdma_system_info_v2_forbidden;
    guint8 arg_wcdma_system_info_v2_lac_valid;
    guint16 arg_wcdma_system_info_v2_lac;
    guint8 arg_wcdma_system_info_v2_cid_valid;
    guint32 arg_wcdma_system_info_v2_cid;
    guint8 arg_wcdma_system_info_v2_registration_reject_info_valid;
    guint8 arg_wcdma_system_info_v2_registration_reject_domain;
    guint8 arg_wcdma_system_info_v2_registration_reject_cause;
    guint8 arg_wcdma_system_info_v2_network_id_valid;
    gchar arg_wcdma_system_info_v2_mcc[4];
    gchar arg_wcdma_system_info_v2_mnc[4];
    guint8 arg_wcdma_system_info_v2_hs_call_status_valid;
    guint8 arg_wcdma_system_info_v2_hs_call_status;
    guint8 arg_wcdma_system_info_v2_hs_service_valid;
    guint8 arg_wcdma_system_info_v2_hs_service;
    guint8 arg_wcdma_system_info_v2_primary_scrambling_code_valid;
    guint16 arg_wcdma_system_info_v2_primary_scrambling_code;

    /* GSM System Info v2 */
    gboolean arg_gsm_system_info_v2_set;
    guint8 arg_gsm_system_info_v2_domain_valid;
    guint8 arg_gsm_system_info_v2_domain;
    guint8 arg_gsm_system_info_v2_service_capability_valid;
    guint8 arg_gsm_system_info_v2_service_capability;
    guint8 arg_gsm_system_info_v2_roaming_status_valid;
    guint8 arg_gsm_system_info_v2_roaming_status;
    guint8 arg_gsm_system_info_v2_forbidden_valid;
    guint8 arg_gsm_system_info_v2_forbidden;
    guint8 arg_gsm_system_info_v2_lac_valid;
    guint16 arg_gsm_system_info_v2_lac;
    guint8 arg_gsm_system_info_v2_cid_valid;
    guint32 arg_gsm_system_info_v2_cid;
    guint8 arg_gsm_system_info_v2_registration_reject_info_valid;
    guint8 arg_gsm_system_info_v2_registration_reject_domain;
    guint8 arg_gsm_system_info_v2_registration_reject_cause;
    guint8 arg_gsm_system_info_v2_network_id_valid;
    gchar arg_gsm_system_info_v2_mcc[4];
    gchar arg_gsm_system_info_v2_mnc[4];
    guint8 arg_gsm_system_info_v2_egprs_support_valid;
    guint8 arg_gsm_system_info_v2_egprs_support;
    guint8 arg_gsm_system_info_v2_dtm_support_valid;
    guint8 arg_gsm_system_info_v2_dtm_support;

    /* HDR System Info */
    gboolean arg_hdr_system_info_set;
    guint8 arg_hdr_system_info_domain_valid;
    guint8 arg_hdr_system_info_domain;
    guint8 arg_hdr_system_info_service_capability_valid;
    guint8 arg_hdr_system_info_service_capability;
    guint8 arg_hdr_system_info_roaming_status_valid;
    guint8 arg_hdr_system_info_roaming_status;
    guint8 arg_hdr_system_info_forbidden_valid;
    guint8 arg_hdr_system_info_forbidden;
    guint8 arg_hdr_system_info_prl_match_valid;
    guint8 arg_hdr_system_info_prl_match;
    guint8 arg_hdr_system_info_personality_valid;
    guint8 arg_hdr_system_info_personality;
    guint8 arg_hdr_system_info_protocol_revision_valid;
    guint8 arg_hdr_system_info_protocol_revision;
    guint8 arg_hdr_system_info_is_856_system_id_valid;
    gchar arg_hdr_system_info_is_856_system_id[17];

    /* CDMA System Info */
    gboolean arg_cdma_system_info_set;
    guint8 arg_cdma_system_info_domain_valid;
    guint8 arg_cdma_system_info_domain;
    guint8 arg_cdma_system_info_service_capability_valid;
    guint8 arg_cdma_system_info_service_capability;
    guint8 arg_cdma_system_info_roaming_status_valid;
    guint8 arg_cdma_system_info_roaming_status;
    guint8 arg_cdma_system_info_forbidden_valid;
    guint8 arg_cdma_system_info_forbidden;
    guint8 arg_cdma_system_info_prl_match_valid;
    guint8 arg_cdma_system_info_prl_match;
    guint8 arg_cdma_system_info_p_rev_valid;
    guint8 arg_cdma_system_info_p_rev;
    guint8 arg_cdma_system_info_base_station_p_rev_valid;
    guint8 arg_cdma_system_info_base_station_p_rev;
    guint8 arg_cdma_system_info_concurrent_service_support_valid;
    guint8 arg_cdma_system_info_concurrent_service_support;
    guint8 arg_cdma_system_info_cdma_system_id_valid;
    guint16 arg_cdma_system_info_sid;
    guint16 arg_cdma_system_info_nid;
    guint8 arg_cdma_system_info_base_station_info_valid;
    guint16 arg_cdma_system_info_base_station_id;
    gint32 arg_cdma_system_info_base_station_latitude;
    gint32 arg_cdma_system_info_base_station_longitude;
    guint8 arg_cdma_system_info_packet_zone_valid;
    guint16 arg_cdma_system_info_packet_zone;
    guint8 arg_cdma_system_info_network_id_valid;
    gchar arg_cdma_system_info_mcc[4];
    gchar arg_cdma_system_info_mnc[4];

    /* LTE Service Status */
    gboolean arg_lte_service_status_set;
    guint8 arg_lte_service_status_service_status;
    guint8 arg_lte_service_status_true_service_status;
    guint8 arg_lte_service_status_preferred_data_path;

    /* WCDMA Service Status */
    gboolean arg_wcdma_service_status_set;
    guint8 arg_wcdma_service_status_service_status;
    guint8 arg_wcdma_service_status_true_service_status;
    guint8 arg_wcdma_service_status_preferred_data_path;

    /* GSM Service Status */
    gboolean arg_gsm_service_status_set;
    guint8 arg_gsm_service_status_service_status;
    guint8 arg_gsm_service_status_true_service_status;
    guint8 arg_gsm_service_status_preferred_data_path;

    /* HDR Service Status */
    gboolean arg_hdr_service_status_set;
    guint8 arg_hdr_service_status_service_status;
    guint8 arg_hdr_service_status_preferred_data_path;

    /* CDMA Service Status */
    gboolean arg_cdma_service_status_set;
    guint8 arg_cdma_service_status_service_status;
    guint8 arg_cdma_service_status_preferred_data_path;
};

#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_TRACKING_AREA_CODE 0x52
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_DCNR_RESTRICTION_INFO 0x51
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_EUTRA_WITH_NR5G_AVAILABILITY 0x50
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_SYSTEM_INFO 0x4D
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_SERVICE_STATUS_INFO 0x4C
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO 0x28
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT 0x27
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCMA_SYSTEM_INFO_V2 0x26
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS 0x25
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION 0x24
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN 0x23
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN 0x22
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT 0x21
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS 0x20
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS 0x1F
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO 0x1E
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO 0x1D
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO 0x1C
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO 0x1B
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO 0x1A
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO_V2 0x19
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO_V2 0x18
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO_V2 0x17
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO 0x16
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO 0x15
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS 0x14
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS 0x13
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS 0x12
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS 0x11
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS 0x10

gboolean
qmi_indication_nas_system_info_output_get_nr5g_tracking_area_code (
    QmiIndicationNasSystemInfoOutput *self,
    GArray **value_nr5g_tracking_area_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_nr5g_tracking_area_code_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'NR5G Tracking Area Code' was not found in the message");
        return FALSE;
    }

    if (value_nr5g_tracking_area_code)
        *value_nr5g_tracking_area_code = self->arg_nr5g_tracking_area_code;

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_dcnr_restriction_info (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_dcnr_restriction_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_dcnr_restriction_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'DCNR restriction Info' was not found in the message");
        return FALSE;
    }

    if (value_dcnr_restriction_info)
        *value_dcnr_restriction_info = (gboolean)(self->arg_dcnr_restriction_info);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_eutra_with_nr5g_availability (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_eutra_with_nr5g_availability,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_eutra_with_nr5g_availability_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'EUTRA with NR5G availability' was not found in the message");
        return FALSE;
    }

    if (value_eutra_with_nr5g_availability)
        *value_eutra_with_nr5g_availability = (gboolean)(self->arg_eutra_with_nr5g_availability);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_nr5g_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_nr5g_system_info_domain_valid,
    QmiNasNetworkServiceDomain *value_nr5g_system_info_domain,
    gboolean *value_nr5g_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *value_nr5g_system_info_service_capability,
    gboolean *value_nr5g_system_info_roaming_status_valid,
    QmiNasRoamingStatus *value_nr5g_system_info_roaming_status,
    gboolean *value_nr5g_system_info_forbidden_valid,
    gboolean *value_nr5g_system_info_forbidden,
    gboolean *value_nr5g_system_info_lac_valid,
    guint16 *value_nr5g_system_info_lac,
    gboolean *value_nr5g_system_info_cid_valid,
    guint32 *value_nr5g_system_info_cid,
    gboolean *value_nr5g_system_info_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *value_nr5g_system_info_registration_reject_domain,
    guint8 *value_nr5g_system_info_registration_reject_cause,
    gboolean *value_nr5g_system_info_network_id_valid,
    const gchar **value_nr5g_system_info_mcc,
    const gchar **value_nr5g_system_info_mnc,
    gboolean *value_nr5g_system_info_tac_valid,
    guint16 *value_nr5g_system_info_tac,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_nr5g_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'NR5G System Info' was not found in the message");
        return FALSE;
    }

    if (value_nr5g_system_info_domain_valid)
        *value_nr5g_system_info_domain_valid = (gboolean)(self->arg_nr5g_system_info_domain_valid);
    if (value_nr5g_system_info_domain)
        *value_nr5g_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_nr5g_system_info_domain);
    if (value_nr5g_system_info_service_capability_valid)
        *value_nr5g_system_info_service_capability_valid = (gboolean)(self->arg_nr5g_system_info_service_capability_valid);
    if (value_nr5g_system_info_service_capability)
        *value_nr5g_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_nr5g_system_info_service_capability);
    if (value_nr5g_system_info_roaming_status_valid)
        *value_nr5g_system_info_roaming_status_valid = (gboolean)(self->arg_nr5g_system_info_roaming_status_valid);
    if (value_nr5g_system_info_roaming_status)
        *value_nr5g_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_nr5g_system_info_roaming_status);
    if (value_nr5g_system_info_forbidden_valid)
        *value_nr5g_system_info_forbidden_valid = (gboolean)(self->arg_nr5g_system_info_forbidden_valid);
    if (value_nr5g_system_info_forbidden)
        *value_nr5g_system_info_forbidden = (gboolean)(self->arg_nr5g_system_info_forbidden);
    if (value_nr5g_system_info_lac_valid)
        *value_nr5g_system_info_lac_valid = (gboolean)(self->arg_nr5g_system_info_lac_valid);
    if (value_nr5g_system_info_lac)
        *value_nr5g_system_info_lac = self->arg_nr5g_system_info_lac;
    if (value_nr5g_system_info_cid_valid)
        *value_nr5g_system_info_cid_valid = (gboolean)(self->arg_nr5g_system_info_cid_valid);
    if (value_nr5g_system_info_cid)
        *value_nr5g_system_info_cid = self->arg_nr5g_system_info_cid;
    if (value_nr5g_system_info_registration_reject_info_valid)
        *value_nr5g_system_info_registration_reject_info_valid = (gboolean)(self->arg_nr5g_system_info_registration_reject_info_valid);
    if (value_nr5g_system_info_registration_reject_domain)
        *value_nr5g_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_nr5g_system_info_registration_reject_domain);
    if (value_nr5g_system_info_registration_reject_cause)
        *value_nr5g_system_info_registration_reject_cause = self->arg_nr5g_system_info_registration_reject_cause;
    if (value_nr5g_system_info_network_id_valid)
        *value_nr5g_system_info_network_id_valid = (gboolean)(self->arg_nr5g_system_info_network_id_valid);
    if (value_nr5g_system_info_mcc)
        *value_nr5g_system_info_mcc = self->arg_nr5g_system_info_mcc;
    if (value_nr5g_system_info_mnc)
        *value_nr5g_system_info_mnc = self->arg_nr5g_system_info_mnc;
    if (value_nr5g_system_info_tac_valid)
        *value_nr5g_system_info_tac_valid = (gboolean)(self->arg_nr5g_system_info_tac_valid);
    if (value_nr5g_system_info_tac)
        *value_nr5g_system_info_tac = self->arg_nr5g_system_info_tac;

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_nr5g_service_status_info (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *value_nr5g_service_status_info_service_status,
    QmiNasServiceStatus *value_nr5g_service_status_info_true_service_status,
    gboolean *value_nr5g_service_status_info_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_nr5g_service_status_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'NR5G Service Status Info' was not found in the message");
        return FALSE;
    }

    if (value_nr5g_service_status_info_service_status)
        *value_nr5g_service_status_info_service_status = (QmiNasServiceStatus)(self->arg_nr5g_service_status_info_service_status);
    if (value_nr5g_service_status_info_true_service_status)
        *value_nr5g_service_status_info_true_service_status = (QmiNasServiceStatus)(self->arg_nr5g_service_status_info_true_service_status);
    if (value_nr5g_service_status_info_preferred_data_path)
        *value_nr5g_service_status_info_preferred_data_path = (gboolean)(self->arg_nr5g_service_status_info_preferred_data_path);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_sim_reject_info (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasSimRejectState *value_sim_reject_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sim_reject_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SIM Reject Info' was not found in the message");
        return FALSE;
    }

    if (value_sim_reject_info)
        *value_sim_reject_info = (QmiNasSimRejectState)(self->arg_sim_reject_info);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_lte_embms_coverage_info_support (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_lte_embms_coverage_info_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_embms_coverage_info_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE eMBMS Coverage Info Support' was not found in the message");
        return FALSE;
    }

    if (value_lte_embms_coverage_info_support)
        *value_lte_embms_coverage_info_support = (gboolean)(self->arg_lte_embms_coverage_info_support);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_td_scma_system_info_v2 (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_td_scma_system_info_v2_domain_valid,
    QmiNasNetworkServiceDomain *value_td_scma_system_info_v2_domain,
    gboolean *value_td_scma_system_info_v2_service_capability_valid,
    QmiNasNetworkServiceDomain *value_td_scma_system_info_v2_service_capability,
    gboolean *value_td_scma_system_info_v2_roaming_status_valid,
    QmiNasRoamingStatus *value_td_scma_system_info_v2_roaming_status,
    gboolean *value_td_scma_system_info_v2_forbidden_valid,
    gboolean *value_td_scma_system_info_v2_forbidden,
    gboolean *value_td_scma_system_info_v2_lac_valid,
    guint16 *value_td_scma_system_info_v2_lac,
    gboolean *value_td_scma_system_info_v2_cid_valid,
    guint32 *value_td_scma_system_info_v2_cid,
    gboolean *value_td_scma_system_info_v2_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *value_td_scma_system_info_v2_registration_reject_domain,
    QmiNasRejectCause *value_td_scma_system_info_v2_registration_reject_cause,
    gboolean *value_td_scma_system_info_v2_network_id_valid,
    const gchar **value_td_scma_system_info_v2_mcc,
    const gchar **value_td_scma_system_info_v2_mnc,
    gboolean *value_td_scma_system_info_v2_hs_call_status_valid,
    QmiNasWcdmaHsService *value_td_scma_system_info_v2_hs_call_status,
    gboolean *value_td_scma_system_info_v2_hs_service_valid,
    QmiNasWcdmaHsService *value_td_scma_system_info_v2_hs_service,
    gboolean *value_td_scma_system_info_v2_cell_parameter_id_valid,
    guint16 *value_td_scma_system_info_v2_cell_parameter_id,
    gboolean *value_td_scma_system_info_v2_cell_broadcast_support_valid,
    QmiNasCellBroadcastCapability *value_td_scma_system_info_v2_cell_broadcast_support,
    gboolean *value_td_scma_system_info_v2_cs_call_barring_status_valid,
    QmiNasCallBarringStatus *value_td_scma_system_info_v2_cs_call_barring_status,
    gboolean *value_td_scma_system_info_v2_ps_call_barring_status_valid,
    QmiNasCallBarringStatus *value_td_scma_system_info_v2_ps_call_barring_status,
    gboolean *value_td_scma_system_info_v2_cipher_domain_valid,
    QmiNasNetworkServiceDomain *value_td_scma_system_info_v2_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scma_system_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCMA System Info v2' was not found in the message");
        return FALSE;
    }

    if (value_td_scma_system_info_v2_domain_valid)
        *value_td_scma_system_info_v2_domain_valid = (gboolean)(self->arg_td_scma_system_info_v2_domain_valid);
    if (value_td_scma_system_info_v2_domain)
        *value_td_scma_system_info_v2_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scma_system_info_v2_domain);
    if (value_td_scma_system_info_v2_service_capability_valid)
        *value_td_scma_system_info_v2_service_capability_valid = (gboolean)(self->arg_td_scma_system_info_v2_service_capability_valid);
    if (value_td_scma_system_info_v2_service_capability)
        *value_td_scma_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)(self->arg_td_scma_system_info_v2_service_capability);
    if (value_td_scma_system_info_v2_roaming_status_valid)
        *value_td_scma_system_info_v2_roaming_status_valid = (gboolean)(self->arg_td_scma_system_info_v2_roaming_status_valid);
    if (value_td_scma_system_info_v2_roaming_status)
        *value_td_scma_system_info_v2_roaming_status = (QmiNasRoamingStatus)(self->arg_td_scma_system_info_v2_roaming_status);
    if (value_td_scma_system_info_v2_forbidden_valid)
        *value_td_scma_system_info_v2_forbidden_valid = (gboolean)(self->arg_td_scma_system_info_v2_forbidden_valid);
    if (value_td_scma_system_info_v2_forbidden)
        *value_td_scma_system_info_v2_forbidden = (gboolean)(self->arg_td_scma_system_info_v2_forbidden);
    if (value_td_scma_system_info_v2_lac_valid)
        *value_td_scma_system_info_v2_lac_valid = (gboolean)(self->arg_td_scma_system_info_v2_lac_valid);
    if (value_td_scma_system_info_v2_lac)
        *value_td_scma_system_info_v2_lac = self->arg_td_scma_system_info_v2_lac;
    if (value_td_scma_system_info_v2_cid_valid)
        *value_td_scma_system_info_v2_cid_valid = (gboolean)(self->arg_td_scma_system_info_v2_cid_valid);
    if (value_td_scma_system_info_v2_cid)
        *value_td_scma_system_info_v2_cid = self->arg_td_scma_system_info_v2_cid;
    if (value_td_scma_system_info_v2_registration_reject_info_valid)
        *value_td_scma_system_info_v2_registration_reject_info_valid = (gboolean)(self->arg_td_scma_system_info_v2_registration_reject_info_valid);
    if (value_td_scma_system_info_v2_registration_reject_domain)
        *value_td_scma_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scma_system_info_v2_registration_reject_domain);
    if (value_td_scma_system_info_v2_registration_reject_cause)
        *value_td_scma_system_info_v2_registration_reject_cause = (QmiNasRejectCause)(self->arg_td_scma_system_info_v2_registration_reject_cause);
    if (value_td_scma_system_info_v2_network_id_valid)
        *value_td_scma_system_info_v2_network_id_valid = (gboolean)(self->arg_td_scma_system_info_v2_network_id_valid);
    if (value_td_scma_system_info_v2_mcc)
        *value_td_scma_system_info_v2_mcc = self->arg_td_scma_system_info_v2_mcc;
    if (value_td_scma_system_info_v2_mnc)
        *value_td_scma_system_info_v2_mnc = self->arg_td_scma_system_info_v2_mnc;
    if (value_td_scma_system_info_v2_hs_call_status_valid)
        *value_td_scma_system_info_v2_hs_call_status_valid = (gboolean)(self->arg_td_scma_system_info_v2_hs_call_status_valid);
    if (value_td_scma_system_info_v2_hs_call_status)
        *value_td_scma_system_info_v2_hs_call_status = (QmiNasWcdmaHsService)(self->arg_td_scma_system_info_v2_hs_call_status);
    if (value_td_scma_system_info_v2_hs_service_valid)
        *value_td_scma_system_info_v2_hs_service_valid = (gboolean)(self->arg_td_scma_system_info_v2_hs_service_valid);
    if (value_td_scma_system_info_v2_hs_service)
        *value_td_scma_system_info_v2_hs_service = (QmiNasWcdmaHsService)(self->arg_td_scma_system_info_v2_hs_service);
    if (value_td_scma_system_info_v2_cell_parameter_id_valid)
        *value_td_scma_system_info_v2_cell_parameter_id_valid = (gboolean)(self->arg_td_scma_system_info_v2_cell_parameter_id_valid);
    if (value_td_scma_system_info_v2_cell_parameter_id)
        *value_td_scma_system_info_v2_cell_parameter_id = self->arg_td_scma_system_info_v2_cell_parameter_id;
    if (value_td_scma_system_info_v2_cell_broadcast_support_valid)
        *value_td_scma_system_info_v2_cell_broadcast_support_valid = (gboolean)(self->arg_td_scma_system_info_v2_cell_broadcast_support_valid);
    if (value_td_scma_system_info_v2_cell_broadcast_support)
        *value_td_scma_system_info_v2_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_td_scma_system_info_v2_cell_broadcast_support);
    if (value_td_scma_system_info_v2_cs_call_barring_status_valid)
        *value_td_scma_system_info_v2_cs_call_barring_status_valid = (gboolean)(self->arg_td_scma_system_info_v2_cs_call_barring_status_valid);
    if (value_td_scma_system_info_v2_cs_call_barring_status)
        *value_td_scma_system_info_v2_cs_call_barring_status = (QmiNasCallBarringStatus)(self->arg_td_scma_system_info_v2_cs_call_barring_status);
    if (value_td_scma_system_info_v2_ps_call_barring_status_valid)
        *value_td_scma_system_info_v2_ps_call_barring_status_valid = (gboolean)(self->arg_td_scma_system_info_v2_ps_call_barring_status_valid);
    if (value_td_scma_system_info_v2_ps_call_barring_status)
        *value_td_scma_system_info_v2_ps_call_barring_status = (QmiNasCallBarringStatus)(self->arg_td_scma_system_info_v2_ps_call_barring_status);
    if (value_td_scma_system_info_v2_cipher_domain_valid)
        *value_td_scma_system_info_v2_cipher_domain_valid = (gboolean)(self->arg_td_scma_system_info_v2_cipher_domain_valid);
    if (value_td_scma_system_info_v2_cipher_domain)
        *value_td_scma_system_info_v2_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scma_system_info_v2_cipher_domain);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_td_scdma_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *value_td_scdma_service_status_service_status,
    QmiNasServiceStatus *value_td_scdma_service_status_true_service_status,
    gboolean *value_td_scdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (value_td_scdma_service_status_service_status)
        *value_td_scdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_td_scdma_service_status_service_status);
    if (value_td_scdma_service_status_true_service_status)
        *value_td_scdma_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_td_scdma_service_status_true_service_status);
    if (value_td_scdma_service_status_preferred_data_path)
        *value_td_scdma_service_status_preferred_data_path = (gboolean)(self->arg_td_scdma_service_status_preferred_data_path);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_plmn_not_changed_indication (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_plmn_not_changed_indication,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_plmn_not_changed_indication_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PLMN Not Changed Indication' was not found in the message");
        return FALSE;
    }

    if (value_plmn_not_changed_indication)
        *value_plmn_not_changed_indication = (gboolean)(self->arg_plmn_not_changed_indication);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_wcdma_cipher_domain (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasNetworkServiceDomain *value_wcdma_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_cipher_domain_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Cipher Domain' was not found in the message");
        return FALSE;
    }

    if (value_wcdma_cipher_domain)
        *value_wcdma_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_cipher_domain);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_gsm_cipher_domain (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasNetworkServiceDomain *value_gsm_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_cipher_domain_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Cipher Domain' was not found in the message");
        return FALSE;
    }

    if (value_gsm_cipher_domain)
        *value_gsm_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_cipher_domain);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_lte_voice_support (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_lte_voice_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_voice_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Voice Support' was not found in the message");
        return FALSE;
    }

    if (value_lte_voice_support)
        *value_lte_voice_support = (gboolean)(self->arg_lte_voice_support);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_wcdma_call_barring_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasCallBarringStatus *value_wcdma_call_barring_status_cs_status,
    QmiNasCallBarringStatus *value_wcdma_call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (value_wcdma_call_barring_status_cs_status)
        *value_wcdma_call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_wcdma_call_barring_status_cs_status);
    if (value_wcdma_call_barring_status_ps_status)
        *value_wcdma_call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_wcdma_call_barring_status_ps_status);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_gsm_call_barring_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasCallBarringStatus *value_gsm_call_barring_status_cs_status,
    QmiNasCallBarringStatus *value_gsm_call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (value_gsm_call_barring_status_cs_status)
        *value_gsm_call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_gsm_call_barring_status_cs_status);
    if (value_gsm_call_barring_status_ps_status)
        *value_gsm_call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_gsm_call_barring_status_ps_status);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_additional_lte_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    guint16 *value_additional_lte_system_info_geo_system_index,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_lte_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional LTE System Info' was not found in the message");
        return FALSE;
    }

    if (value_additional_lte_system_info_geo_system_index)
        *value_additional_lte_system_info_geo_system_index = self->arg_additional_lte_system_info_geo_system_index;

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_additional_wcdma_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    guint16 *value_additional_wcdma_system_info_geo_system_index,
    QmiNasCellBroadcastCapability *value_additional_wcdma_system_info_cell_broadcast_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_wcdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional WCDMA System Info' was not found in the message");
        return FALSE;
    }

    if (value_additional_wcdma_system_info_geo_system_index)
        *value_additional_wcdma_system_info_geo_system_index = self->arg_additional_wcdma_system_info_geo_system_index;
    if (value_additional_wcdma_system_info_cell_broadcast_support)
        *value_additional_wcdma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_additional_wcdma_system_info_cell_broadcast_support);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_additional_gsm_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    guint16 *value_additional_gsm_system_info_geo_system_index,
    QmiNasCellBroadcastCapability *value_additional_gsm_system_info_cell_broadcast_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_gsm_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional GSM System Info' was not found in the message");
        return FALSE;
    }

    if (value_additional_gsm_system_info_geo_system_index)
        *value_additional_gsm_system_info_geo_system_index = self->arg_additional_gsm_system_info_geo_system_index;
    if (value_additional_gsm_system_info_cell_broadcast_support)
        *value_additional_gsm_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_additional_gsm_system_info_cell_broadcast_support);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_additional_hdr_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    guint16 *value_additional_hdr_system_info_geo_system_index,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_hdr_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional HDR System Info' was not found in the message");
        return FALSE;
    }

    if (value_additional_hdr_system_info_geo_system_index)
        *value_additional_hdr_system_info_geo_system_index = self->arg_additional_hdr_system_info_geo_system_index;

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_additional_cdma_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    guint16 *value_additional_cdma_system_info_geo_system_index,
    guint16 *value_additional_cdma_system_info_registration_period,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (value_additional_cdma_system_info_geo_system_index)
        *value_additional_cdma_system_info_geo_system_index = self->arg_additional_cdma_system_info_geo_system_index;
    if (value_additional_cdma_system_info_registration_period)
        *value_additional_cdma_system_info_registration_period = self->arg_additional_cdma_system_info_registration_period;

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_lte_system_info_v2 (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_lte_system_info_v2_domain_valid,
    QmiNasNetworkServiceDomain *value_lte_system_info_v2_domain,
    gboolean *value_lte_system_info_v2_service_capability_valid,
    QmiNasNetworkServiceDomain *value_lte_system_info_v2_service_capability,
    gboolean *value_lte_system_info_v2_roaming_status_valid,
    QmiNasRoamingStatus *value_lte_system_info_v2_roaming_status,
    gboolean *value_lte_system_info_v2_forbidden_valid,
    gboolean *value_lte_system_info_v2_forbidden,
    gboolean *value_lte_system_info_v2_lac_valid,
    guint16 *value_lte_system_info_v2_lac,
    gboolean *value_lte_system_info_v2_cid_valid,
    guint32 *value_lte_system_info_v2_cid,
    gboolean *value_lte_system_info_v2_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *value_lte_system_info_v2_registration_reject_domain,
    QmiNasRejectCause *value_lte_system_info_v2_registration_reject_cause,
    gboolean *value_lte_system_info_v2_network_id_valid,
    const gchar **value_lte_system_info_v2_mcc,
    const gchar **value_lte_system_info_v2_mnc,
    gboolean *value_lte_system_info_v2_tac_valid,
    guint16 *value_lte_system_info_v2_tac,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_system_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE System Info v2' was not found in the message");
        return FALSE;
    }

    if (value_lte_system_info_v2_domain_valid)
        *value_lte_system_info_v2_domain_valid = (gboolean)(self->arg_lte_system_info_v2_domain_valid);
    if (value_lte_system_info_v2_domain)
        *value_lte_system_info_v2_domain = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_v2_domain);
    if (value_lte_system_info_v2_service_capability_valid)
        *value_lte_system_info_v2_service_capability_valid = (gboolean)(self->arg_lte_system_info_v2_service_capability_valid);
    if (value_lte_system_info_v2_service_capability)
        *value_lte_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_v2_service_capability);
    if (value_lte_system_info_v2_roaming_status_valid)
        *value_lte_system_info_v2_roaming_status_valid = (gboolean)(self->arg_lte_system_info_v2_roaming_status_valid);
    if (value_lte_system_info_v2_roaming_status)
        *value_lte_system_info_v2_roaming_status = (QmiNasRoamingStatus)(self->arg_lte_system_info_v2_roaming_status);
    if (value_lte_system_info_v2_forbidden_valid)
        *value_lte_system_info_v2_forbidden_valid = (gboolean)(self->arg_lte_system_info_v2_forbidden_valid);
    if (value_lte_system_info_v2_forbidden)
        *value_lte_system_info_v2_forbidden = (gboolean)(self->arg_lte_system_info_v2_forbidden);
    if (value_lte_system_info_v2_lac_valid)
        *value_lte_system_info_v2_lac_valid = (gboolean)(self->arg_lte_system_info_v2_lac_valid);
    if (value_lte_system_info_v2_lac)
        *value_lte_system_info_v2_lac = self->arg_lte_system_info_v2_lac;
    if (value_lte_system_info_v2_cid_valid)
        *value_lte_system_info_v2_cid_valid = (gboolean)(self->arg_lte_system_info_v2_cid_valid);
    if (value_lte_system_info_v2_cid)
        *value_lte_system_info_v2_cid = self->arg_lte_system_info_v2_cid;
    if (value_lte_system_info_v2_registration_reject_info_valid)
        *value_lte_system_info_v2_registration_reject_info_valid = (gboolean)(self->arg_lte_system_info_v2_registration_reject_info_valid);
    if (value_lte_system_info_v2_registration_reject_domain)
        *value_lte_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_v2_registration_reject_domain);
    if (value_lte_system_info_v2_registration_reject_cause)
        *value_lte_system_info_v2_registration_reject_cause = (QmiNasRejectCause)(self->arg_lte_system_info_v2_registration_reject_cause);
    if (value_lte_system_info_v2_network_id_valid)
        *value_lte_system_info_v2_network_id_valid = (gboolean)(self->arg_lte_system_info_v2_network_id_valid);
    if (value_lte_system_info_v2_mcc)
        *value_lte_system_info_v2_mcc = self->arg_lte_system_info_v2_mcc;
    if (value_lte_system_info_v2_mnc)
        *value_lte_system_info_v2_mnc = self->arg_lte_system_info_v2_mnc;
    if (value_lte_system_info_v2_tac_valid)
        *value_lte_system_info_v2_tac_valid = (gboolean)(self->arg_lte_system_info_v2_tac_valid);
    if (value_lte_system_info_v2_tac)
        *value_lte_system_info_v2_tac = self->arg_lte_system_info_v2_tac;

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_wcdma_system_info_v2 (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_wcdma_system_info_v2_domain_valid,
    QmiNasNetworkServiceDomain *value_wcdma_system_info_v2_domain,
    gboolean *value_wcdma_system_info_v2_service_capability_valid,
    QmiNasNetworkServiceDomain *value_wcdma_system_info_v2_service_capability,
    gboolean *value_wcdma_system_info_v2_roaming_status_valid,
    QmiNasRoamingStatus *value_wcdma_system_info_v2_roaming_status,
    gboolean *value_wcdma_system_info_v2_forbidden_valid,
    gboolean *value_wcdma_system_info_v2_forbidden,
    gboolean *value_wcdma_system_info_v2_lac_valid,
    guint16 *value_wcdma_system_info_v2_lac,
    gboolean *value_wcdma_system_info_v2_cid_valid,
    guint32 *value_wcdma_system_info_v2_cid,
    gboolean *value_wcdma_system_info_v2_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *value_wcdma_system_info_v2_registration_reject_domain,
    QmiNasRejectCause *value_wcdma_system_info_v2_registration_reject_cause,
    gboolean *value_wcdma_system_info_v2_network_id_valid,
    const gchar **value_wcdma_system_info_v2_mcc,
    const gchar **value_wcdma_system_info_v2_mnc,
    gboolean *value_wcdma_system_info_v2_hs_call_status_valid,
    QmiNasWcdmaHsService *value_wcdma_system_info_v2_hs_call_status,
    gboolean *value_wcdma_system_info_v2_hs_service_valid,
    QmiNasWcdmaHsService *value_wcdma_system_info_v2_hs_service,
    gboolean *value_wcdma_system_info_v2_primary_scrambling_code_valid,
    guint16 *value_wcdma_system_info_v2_primary_scrambling_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_system_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA System Info v2' was not found in the message");
        return FALSE;
    }

    if (value_wcdma_system_info_v2_domain_valid)
        *value_wcdma_system_info_v2_domain_valid = (gboolean)(self->arg_wcdma_system_info_v2_domain_valid);
    if (value_wcdma_system_info_v2_domain)
        *value_wcdma_system_info_v2_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_v2_domain);
    if (value_wcdma_system_info_v2_service_capability_valid)
        *value_wcdma_system_info_v2_service_capability_valid = (gboolean)(self->arg_wcdma_system_info_v2_service_capability_valid);
    if (value_wcdma_system_info_v2_service_capability)
        *value_wcdma_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_v2_service_capability);
    if (value_wcdma_system_info_v2_roaming_status_valid)
        *value_wcdma_system_info_v2_roaming_status_valid = (gboolean)(self->arg_wcdma_system_info_v2_roaming_status_valid);
    if (value_wcdma_system_info_v2_roaming_status)
        *value_wcdma_system_info_v2_roaming_status = (QmiNasRoamingStatus)(self->arg_wcdma_system_info_v2_roaming_status);
    if (value_wcdma_system_info_v2_forbidden_valid)
        *value_wcdma_system_info_v2_forbidden_valid = (gboolean)(self->arg_wcdma_system_info_v2_forbidden_valid);
    if (value_wcdma_system_info_v2_forbidden)
        *value_wcdma_system_info_v2_forbidden = (gboolean)(self->arg_wcdma_system_info_v2_forbidden);
    if (value_wcdma_system_info_v2_lac_valid)
        *value_wcdma_system_info_v2_lac_valid = (gboolean)(self->arg_wcdma_system_info_v2_lac_valid);
    if (value_wcdma_system_info_v2_lac)
        *value_wcdma_system_info_v2_lac = self->arg_wcdma_system_info_v2_lac;
    if (value_wcdma_system_info_v2_cid_valid)
        *value_wcdma_system_info_v2_cid_valid = (gboolean)(self->arg_wcdma_system_info_v2_cid_valid);
    if (value_wcdma_system_info_v2_cid)
        *value_wcdma_system_info_v2_cid = self->arg_wcdma_system_info_v2_cid;
    if (value_wcdma_system_info_v2_registration_reject_info_valid)
        *value_wcdma_system_info_v2_registration_reject_info_valid = (gboolean)(self->arg_wcdma_system_info_v2_registration_reject_info_valid);
    if (value_wcdma_system_info_v2_registration_reject_domain)
        *value_wcdma_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_v2_registration_reject_domain);
    if (value_wcdma_system_info_v2_registration_reject_cause)
        *value_wcdma_system_info_v2_registration_reject_cause = (QmiNasRejectCause)(self->arg_wcdma_system_info_v2_registration_reject_cause);
    if (value_wcdma_system_info_v2_network_id_valid)
        *value_wcdma_system_info_v2_network_id_valid = (gboolean)(self->arg_wcdma_system_info_v2_network_id_valid);
    if (value_wcdma_system_info_v2_mcc)
        *value_wcdma_system_info_v2_mcc = self->arg_wcdma_system_info_v2_mcc;
    if (value_wcdma_system_info_v2_mnc)
        *value_wcdma_system_info_v2_mnc = self->arg_wcdma_system_info_v2_mnc;
    if (value_wcdma_system_info_v2_hs_call_status_valid)
        *value_wcdma_system_info_v2_hs_call_status_valid = (gboolean)(self->arg_wcdma_system_info_v2_hs_call_status_valid);
    if (value_wcdma_system_info_v2_hs_call_status)
        *value_wcdma_system_info_v2_hs_call_status = (QmiNasWcdmaHsService)(self->arg_wcdma_system_info_v2_hs_call_status);
    if (value_wcdma_system_info_v2_hs_service_valid)
        *value_wcdma_system_info_v2_hs_service_valid = (gboolean)(self->arg_wcdma_system_info_v2_hs_service_valid);
    if (value_wcdma_system_info_v2_hs_service)
        *value_wcdma_system_info_v2_hs_service = (QmiNasWcdmaHsService)(self->arg_wcdma_system_info_v2_hs_service);
    if (value_wcdma_system_info_v2_primary_scrambling_code_valid)
        *value_wcdma_system_info_v2_primary_scrambling_code_valid = (gboolean)(self->arg_wcdma_system_info_v2_primary_scrambling_code_valid);
    if (value_wcdma_system_info_v2_primary_scrambling_code)
        *value_wcdma_system_info_v2_primary_scrambling_code = self->arg_wcdma_system_info_v2_primary_scrambling_code;

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_gsm_system_info_v2 (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_gsm_system_info_v2_domain_valid,
    QmiNasNetworkServiceDomain *value_gsm_system_info_v2_domain,
    gboolean *value_gsm_system_info_v2_service_capability_valid,
    QmiNasNetworkServiceDomain *value_gsm_system_info_v2_service_capability,
    gboolean *value_gsm_system_info_v2_roaming_status_valid,
    QmiNasRoamingStatus *value_gsm_system_info_v2_roaming_status,
    gboolean *value_gsm_system_info_v2_forbidden_valid,
    gboolean *value_gsm_system_info_v2_forbidden,
    gboolean *value_gsm_system_info_v2_lac_valid,
    guint16 *value_gsm_system_info_v2_lac,
    gboolean *value_gsm_system_info_v2_cid_valid,
    guint32 *value_gsm_system_info_v2_cid,
    gboolean *value_gsm_system_info_v2_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *value_gsm_system_info_v2_registration_reject_domain,
    QmiNasRejectCause *value_gsm_system_info_v2_registration_reject_cause,
    gboolean *value_gsm_system_info_v2_network_id_valid,
    const gchar **value_gsm_system_info_v2_mcc,
    const gchar **value_gsm_system_info_v2_mnc,
    gboolean *value_gsm_system_info_v2_egprs_support_valid,
    gboolean *value_gsm_system_info_v2_egprs_support,
    gboolean *value_gsm_system_info_v2_dtm_support_valid,
    gboolean *value_gsm_system_info_v2_dtm_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_system_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM System Info v2' was not found in the message");
        return FALSE;
    }

    if (value_gsm_system_info_v2_domain_valid)
        *value_gsm_system_info_v2_domain_valid = (gboolean)(self->arg_gsm_system_info_v2_domain_valid);
    if (value_gsm_system_info_v2_domain)
        *value_gsm_system_info_v2_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_v2_domain);
    if (value_gsm_system_info_v2_service_capability_valid)
        *value_gsm_system_info_v2_service_capability_valid = (gboolean)(self->arg_gsm_system_info_v2_service_capability_valid);
    if (value_gsm_system_info_v2_service_capability)
        *value_gsm_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_v2_service_capability);
    if (value_gsm_system_info_v2_roaming_status_valid)
        *value_gsm_system_info_v2_roaming_status_valid = (gboolean)(self->arg_gsm_system_info_v2_roaming_status_valid);
    if (value_gsm_system_info_v2_roaming_status)
        *value_gsm_system_info_v2_roaming_status = (QmiNasRoamingStatus)(self->arg_gsm_system_info_v2_roaming_status);
    if (value_gsm_system_info_v2_forbidden_valid)
        *value_gsm_system_info_v2_forbidden_valid = (gboolean)(self->arg_gsm_system_info_v2_forbidden_valid);
    if (value_gsm_system_info_v2_forbidden)
        *value_gsm_system_info_v2_forbidden = (gboolean)(self->arg_gsm_system_info_v2_forbidden);
    if (value_gsm_system_info_v2_lac_valid)
        *value_gsm_system_info_v2_lac_valid = (gboolean)(self->arg_gsm_system_info_v2_lac_valid);
    if (value_gsm_system_info_v2_lac)
        *value_gsm_system_info_v2_lac = self->arg_gsm_system_info_v2_lac;
    if (value_gsm_system_info_v2_cid_valid)
        *value_gsm_system_info_v2_cid_valid = (gboolean)(self->arg_gsm_system_info_v2_cid_valid);
    if (value_gsm_system_info_v2_cid)
        *value_gsm_system_info_v2_cid = self->arg_gsm_system_info_v2_cid;
    if (value_gsm_system_info_v2_registration_reject_info_valid)
        *value_gsm_system_info_v2_registration_reject_info_valid = (gboolean)(self->arg_gsm_system_info_v2_registration_reject_info_valid);
    if (value_gsm_system_info_v2_registration_reject_domain)
        *value_gsm_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_v2_registration_reject_domain);
    if (value_gsm_system_info_v2_registration_reject_cause)
        *value_gsm_system_info_v2_registration_reject_cause = (QmiNasRejectCause)(self->arg_gsm_system_info_v2_registration_reject_cause);
    if (value_gsm_system_info_v2_network_id_valid)
        *value_gsm_system_info_v2_network_id_valid = (gboolean)(self->arg_gsm_system_info_v2_network_id_valid);
    if (value_gsm_system_info_v2_mcc)
        *value_gsm_system_info_v2_mcc = self->arg_gsm_system_info_v2_mcc;
    if (value_gsm_system_info_v2_mnc)
        *value_gsm_system_info_v2_mnc = self->arg_gsm_system_info_v2_mnc;
    if (value_gsm_system_info_v2_egprs_support_valid)
        *value_gsm_system_info_v2_egprs_support_valid = (gboolean)(self->arg_gsm_system_info_v2_egprs_support_valid);
    if (value_gsm_system_info_v2_egprs_support)
        *value_gsm_system_info_v2_egprs_support = (gboolean)(self->arg_gsm_system_info_v2_egprs_support);
    if (value_gsm_system_info_v2_dtm_support_valid)
        *value_gsm_system_info_v2_dtm_support_valid = (gboolean)(self->arg_gsm_system_info_v2_dtm_support_valid);
    if (value_gsm_system_info_v2_dtm_support)
        *value_gsm_system_info_v2_dtm_support = (gboolean)(self->arg_gsm_system_info_v2_dtm_support);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_hdr_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_hdr_system_info_domain_valid,
    QmiNasNetworkServiceDomain *value_hdr_system_info_domain,
    gboolean *value_hdr_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *value_hdr_system_info_service_capability,
    gboolean *value_hdr_system_info_roaming_status_valid,
    QmiNasRoamingStatus *value_hdr_system_info_roaming_status,
    gboolean *value_hdr_system_info_forbidden_valid,
    gboolean *value_hdr_system_info_forbidden,
    gboolean *value_hdr_system_info_prl_match_valid,
    gboolean *value_hdr_system_info_prl_match,
    gboolean *value_hdr_system_info_personality_valid,
    QmiNasHdrPersonality *value_hdr_system_info_personality,
    gboolean *value_hdr_system_info_protocol_revision_valid,
    QmiNasHdrProtocolRevision *value_hdr_system_info_protocol_revision,
    gboolean *value_hdr_system_info_is_856_system_id_valid,
    const gchar **value_hdr_system_info_is_856_system_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR System Info' was not found in the message");
        return FALSE;
    }

    if (value_hdr_system_info_domain_valid)
        *value_hdr_system_info_domain_valid = (gboolean)(self->arg_hdr_system_info_domain_valid);
    if (value_hdr_system_info_domain)
        *value_hdr_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_hdr_system_info_domain);
    if (value_hdr_system_info_service_capability_valid)
        *value_hdr_system_info_service_capability_valid = (gboolean)(self->arg_hdr_system_info_service_capability_valid);
    if (value_hdr_system_info_service_capability)
        *value_hdr_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_hdr_system_info_service_capability);
    if (value_hdr_system_info_roaming_status_valid)
        *value_hdr_system_info_roaming_status_valid = (gboolean)(self->arg_hdr_system_info_roaming_status_valid);
    if (value_hdr_system_info_roaming_status)
        *value_hdr_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_hdr_system_info_roaming_status);
    if (value_hdr_system_info_forbidden_valid)
        *value_hdr_system_info_forbidden_valid = (gboolean)(self->arg_hdr_system_info_forbidden_valid);
    if (value_hdr_system_info_forbidden)
        *value_hdr_system_info_forbidden = (gboolean)(self->arg_hdr_system_info_forbidden);
    if (value_hdr_system_info_prl_match_valid)
        *value_hdr_system_info_prl_match_valid = (gboolean)(self->arg_hdr_system_info_prl_match_valid);
    if (value_hdr_system_info_prl_match)
        *value_hdr_system_info_prl_match = (gboolean)(self->arg_hdr_system_info_prl_match);
    if (value_hdr_system_info_personality_valid)
        *value_hdr_system_info_personality_valid = (gboolean)(self->arg_hdr_system_info_personality_valid);
    if (value_hdr_system_info_personality)
        *value_hdr_system_info_personality = (QmiNasHdrPersonality)(self->arg_hdr_system_info_personality);
    if (value_hdr_system_info_protocol_revision_valid)
        *value_hdr_system_info_protocol_revision_valid = (gboolean)(self->arg_hdr_system_info_protocol_revision_valid);
    if (value_hdr_system_info_protocol_revision)
        *value_hdr_system_info_protocol_revision = (QmiNasHdrProtocolRevision)(self->arg_hdr_system_info_protocol_revision);
    if (value_hdr_system_info_is_856_system_id_valid)
        *value_hdr_system_info_is_856_system_id_valid = (gboolean)(self->arg_hdr_system_info_is_856_system_id_valid);
    if (value_hdr_system_info_is_856_system_id)
        *value_hdr_system_info_is_856_system_id = self->arg_hdr_system_info_is_856_system_id;

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_cdma_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *value_cdma_system_info_domain_valid,
    QmiNasNetworkServiceDomain *value_cdma_system_info_domain,
    gboolean *value_cdma_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *value_cdma_system_info_service_capability,
    gboolean *value_cdma_system_info_roaming_status_valid,
    QmiNasRoamingStatus *value_cdma_system_info_roaming_status,
    gboolean *value_cdma_system_info_forbidden_valid,
    gboolean *value_cdma_system_info_forbidden,
    gboolean *value_cdma_system_info_prl_match_valid,
    gboolean *value_cdma_system_info_prl_match,
    gboolean *value_cdma_system_info_p_rev_valid,
    guint8 *value_cdma_system_info_p_rev,
    gboolean *value_cdma_system_info_base_station_p_rev_valid,
    guint8 *value_cdma_system_info_base_station_p_rev,
    gboolean *value_cdma_system_info_concurrent_service_support_valid,
    gboolean *value_cdma_system_info_concurrent_service_support,
    gboolean *value_cdma_system_info_cdma_system_id_valid,
    guint16 *value_cdma_system_info_sid,
    guint16 *value_cdma_system_info_nid,
    gboolean *value_cdma_system_info_base_station_info_valid,
    guint16 *value_cdma_system_info_base_station_id,
    gint32 *value_cdma_system_info_base_station_latitude,
    gint32 *value_cdma_system_info_base_station_longitude,
    gboolean *value_cdma_system_info_packet_zone_valid,
    guint16 *value_cdma_system_info_packet_zone,
    gboolean *value_cdma_system_info_network_id_valid,
    const gchar **value_cdma_system_info_mcc,
    const gchar **value_cdma_system_info_mnc,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (value_cdma_system_info_domain_valid)
        *value_cdma_system_info_domain_valid = (gboolean)(self->arg_cdma_system_info_domain_valid);
    if (value_cdma_system_info_domain)
        *value_cdma_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_cdma_system_info_domain);
    if (value_cdma_system_info_service_capability_valid)
        *value_cdma_system_info_service_capability_valid = (gboolean)(self->arg_cdma_system_info_service_capability_valid);
    if (value_cdma_system_info_service_capability)
        *value_cdma_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_cdma_system_info_service_capability);
    if (value_cdma_system_info_roaming_status_valid)
        *value_cdma_system_info_roaming_status_valid = (gboolean)(self->arg_cdma_system_info_roaming_status_valid);
    if (value_cdma_system_info_roaming_status)
        *value_cdma_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_cdma_system_info_roaming_status);
    if (value_cdma_system_info_forbidden_valid)
        *value_cdma_system_info_forbidden_valid = (gboolean)(self->arg_cdma_system_info_forbidden_valid);
    if (value_cdma_system_info_forbidden)
        *value_cdma_system_info_forbidden = (gboolean)(self->arg_cdma_system_info_forbidden);
    if (value_cdma_system_info_prl_match_valid)
        *value_cdma_system_info_prl_match_valid = (gboolean)(self->arg_cdma_system_info_prl_match_valid);
    if (value_cdma_system_info_prl_match)
        *value_cdma_system_info_prl_match = (gboolean)(self->arg_cdma_system_info_prl_match);
    if (value_cdma_system_info_p_rev_valid)
        *value_cdma_system_info_p_rev_valid = (gboolean)(self->arg_cdma_system_info_p_rev_valid);
    if (value_cdma_system_info_p_rev)
        *value_cdma_system_info_p_rev = self->arg_cdma_system_info_p_rev;
    if (value_cdma_system_info_base_station_p_rev_valid)
        *value_cdma_system_info_base_station_p_rev_valid = (gboolean)(self->arg_cdma_system_info_base_station_p_rev_valid);
    if (value_cdma_system_info_base_station_p_rev)
        *value_cdma_system_info_base_station_p_rev = self->arg_cdma_system_info_base_station_p_rev;
    if (value_cdma_system_info_concurrent_service_support_valid)
        *value_cdma_system_info_concurrent_service_support_valid = (gboolean)(self->arg_cdma_system_info_concurrent_service_support_valid);
    if (value_cdma_system_info_concurrent_service_support)
        *value_cdma_system_info_concurrent_service_support = (gboolean)(self->arg_cdma_system_info_concurrent_service_support);
    if (value_cdma_system_info_cdma_system_id_valid)
        *value_cdma_system_info_cdma_system_id_valid = (gboolean)(self->arg_cdma_system_info_cdma_system_id_valid);
    if (value_cdma_system_info_sid)
        *value_cdma_system_info_sid = self->arg_cdma_system_info_sid;
    if (value_cdma_system_info_nid)
        *value_cdma_system_info_nid = self->arg_cdma_system_info_nid;
    if (value_cdma_system_info_base_station_info_valid)
        *value_cdma_system_info_base_station_info_valid = (gboolean)(self->arg_cdma_system_info_base_station_info_valid);
    if (value_cdma_system_info_base_station_id)
        *value_cdma_system_info_base_station_id = self->arg_cdma_system_info_base_station_id;
    if (value_cdma_system_info_base_station_latitude)
        *value_cdma_system_info_base_station_latitude = self->arg_cdma_system_info_base_station_latitude;
    if (value_cdma_system_info_base_station_longitude)
        *value_cdma_system_info_base_station_longitude = self->arg_cdma_system_info_base_station_longitude;
    if (value_cdma_system_info_packet_zone_valid)
        *value_cdma_system_info_packet_zone_valid = (gboolean)(self->arg_cdma_system_info_packet_zone_valid);
    if (value_cdma_system_info_packet_zone)
        *value_cdma_system_info_packet_zone = self->arg_cdma_system_info_packet_zone;
    if (value_cdma_system_info_network_id_valid)
        *value_cdma_system_info_network_id_valid = (gboolean)(self->arg_cdma_system_info_network_id_valid);
    if (value_cdma_system_info_mcc)
        *value_cdma_system_info_mcc = self->arg_cdma_system_info_mcc;
    if (value_cdma_system_info_mnc)
        *value_cdma_system_info_mnc = self->arg_cdma_system_info_mnc;

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_lte_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *value_lte_service_status_service_status,
    QmiNasServiceStatus *value_lte_service_status_true_service_status,
    gboolean *value_lte_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Service Status' was not found in the message");
        return FALSE;
    }

    if (value_lte_service_status_service_status)
        *value_lte_service_status_service_status = (QmiNasServiceStatus)(self->arg_lte_service_status_service_status);
    if (value_lte_service_status_true_service_status)
        *value_lte_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_lte_service_status_true_service_status);
    if (value_lte_service_status_preferred_data_path)
        *value_lte_service_status_preferred_data_path = (gboolean)(self->arg_lte_service_status_preferred_data_path);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_wcdma_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *value_wcdma_service_status_service_status,
    QmiNasServiceStatus *value_wcdma_service_status_true_service_status,
    gboolean *value_wcdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (value_wcdma_service_status_service_status)
        *value_wcdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_wcdma_service_status_service_status);
    if (value_wcdma_service_status_true_service_status)
        *value_wcdma_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_wcdma_service_status_true_service_status);
    if (value_wcdma_service_status_preferred_data_path)
        *value_wcdma_service_status_preferred_data_path = (gboolean)(self->arg_wcdma_service_status_preferred_data_path);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_gsm_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *value_gsm_service_status_service_status,
    QmiNasServiceStatus *value_gsm_service_status_true_service_status,
    gboolean *value_gsm_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Service Status' was not found in the message");
        return FALSE;
    }

    if (value_gsm_service_status_service_status)
        *value_gsm_service_status_service_status = (QmiNasServiceStatus)(self->arg_gsm_service_status_service_status);
    if (value_gsm_service_status_true_service_status)
        *value_gsm_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_gsm_service_status_true_service_status);
    if (value_gsm_service_status_preferred_data_path)
        *value_gsm_service_status_preferred_data_path = (gboolean)(self->arg_gsm_service_status_preferred_data_path);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_hdr_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *value_hdr_service_status_service_status,
    gboolean *value_hdr_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Service Status' was not found in the message");
        return FALSE;
    }

    if (value_hdr_service_status_service_status)
        *value_hdr_service_status_service_status = (QmiNasServiceStatus)(self->arg_hdr_service_status_service_status);
    if (value_hdr_service_status_preferred_data_path)
        *value_hdr_service_status_preferred_data_path = (gboolean)(self->arg_hdr_service_status_preferred_data_path);

    return TRUE;
}

gboolean
qmi_indication_nas_system_info_output_get_cdma_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *value_cdma_service_status_service_status,
    gboolean *value_cdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (value_cdma_service_status_service_status)
        *value_cdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_cdma_service_status_service_status);
    if (value_cdma_service_status_preferred_data_path)
        *value_cdma_service_status_preferred_data_path = (gboolean)(self->arg_cdma_service_status_preferred_data_path);

    return TRUE;
}

GType
qmi_indication_nas_system_info_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasSystemInfoOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_system_info_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_system_info_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiIndicationNasSystemInfoOutput *
qmi_indication_nas_system_info_output_ref (QmiIndicationNasSystemInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_indication_nas_system_info_output_unref (QmiIndicationNasSystemInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_nr5g_tracking_area_code)
            g_array_unref (self->arg_nr5g_tracking_area_code);
        g_slice_free (QmiIndicationNasSystemInfoOutput, self);
    }
}

static gchar *
qmi_indication_nas_system_info_output_nr5g_tracking_area_code_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_TRACKING_AREA_CODE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint nr5g_tracking_area_code_i;
        guint16 nr5g_tracking_area_code_n_items = 3;


        g_string_append (printable, "{");

        for (nr5g_tracking_area_code_i = 0; nr5g_tracking_area_code_i < nr5g_tracking_area_code_n_items; nr5g_tracking_area_code_i++) {
            g_string_append_printf (printable, " [%u] = '", nr5g_tracking_area_code_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_dcnr_restriction_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_DCNR_RESTRICTION_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_eutra_with_nr5g_availability_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_EUTRA_WITH_NR5G_AVAILABILITY, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_nr5g_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_cause = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " tac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " tac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_nr5g_service_status_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_SERVICE_STATUS_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " true_service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_sim_reject_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SIM_REJECT_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_sim_reject_state_get_string ((QmiNasSimRejectState)tmp));
#elif defined  __QMI_NAS_SIM_REJECT_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_sim_reject_state_build_string_from_mask ((QmiNasSimRejectState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasSimRejectState
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_lte_embms_coverage_info_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_td_scma_system_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCMA_SYSTEM_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_cause = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_REJECT_CAUSE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_reject_cause_get_string ((QmiNasRejectCause)tmp));
#elif defined  __QMI_NAS_REJECT_CAUSE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_reject_cause_build_string_from_mask ((QmiNasRejectCause)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRejectCause
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_call_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_call_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_service_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_service = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_parameter_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_parameter_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_broadcast_support_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_broadcast_support = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cs_call_barring_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cs_call_barring_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_call_barring_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_call_barring_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cipher_domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cipher_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_td_scdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " true_service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_plmn_not_changed_indication_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_wcdma_cipher_domain_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_gsm_cipher_domain_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_lte_voice_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_wcdma_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " cs_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_gsm_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " cs_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_additional_lte_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " geo_system_index = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_additional_wcdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " geo_system_index = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_broadcast_support = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_additional_gsm_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " geo_system_index = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_broadcast_support = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_additional_hdr_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " geo_system_index = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_additional_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " geo_system_index = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_period = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_lte_system_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_cause = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_REJECT_CAUSE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_reject_cause_get_string ((QmiNasRejectCause)tmp));
#elif defined  __QMI_NAS_REJECT_CAUSE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_reject_cause_build_string_from_mask ((QmiNasRejectCause)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRejectCause
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " tac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " tac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_wcdma_system_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_cause = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_REJECT_CAUSE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_reject_cause_get_string ((QmiNasRejectCause)tmp));
#elif defined  __QMI_NAS_REJECT_CAUSE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_reject_cause_build_string_from_mask ((QmiNasRejectCause)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRejectCause
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_call_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_call_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_service_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_service = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " primary_scrambling_code_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " primary_scrambling_code = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_gsm_system_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_cause = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_REJECT_CAUSE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_reject_cause_get_string ((QmiNasRejectCause)tmp));
#elif defined  __QMI_NAS_REJECT_CAUSE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_reject_cause_build_string_from_mask ((QmiNasRejectCause)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRejectCause
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " egprs_support_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " egprs_support = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " dtm_support_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " dtm_support = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_hdr_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " prl_match_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " prl_match = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " personality_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " personality = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_HDR_PERSONALITY_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_hdr_personality_get_string ((QmiNasHdrPersonality)tmp));
#elif defined  __QMI_NAS_HDR_PERSONALITY_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_hdr_personality_build_string_from_mask ((QmiNasHdrPersonality)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasHdrPersonality
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " protocol_revision_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " protocol_revision = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_HDR_PROTOCOL_REVISION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_hdr_protocol_revision_get_string ((QmiNasHdrProtocolRevision)tmp));
#elif defined  __QMI_NAS_HDR_PROTOCOL_REVISION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_hdr_protocol_revision_build_string_from_mask ((QmiNasHdrProtocolRevision)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasHdrProtocolRevision
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " is_856_system_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " is_856_system_id = '");

    {
        gchar tmp[17];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 16, &tmp[0], &error))
            goto out;
        tmp[16] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " prl_match_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " prl_match = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " p_rev_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " p_rev = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_p_rev_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_p_rev = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " concurrent_service_support_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " concurrent_service_support = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cdma_system_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " sid = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " nid = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_latitude = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_longitude = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " packet_zone_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " packet_zone = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_lte_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " true_service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_wcdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " true_service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_gsm_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " true_service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_hdr_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_system_info_output_cdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct indication_system_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_system_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_system_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    {
        switch (type) {
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_TRACKING_AREA_CODE:
            tlv_type_str = "NR5G Tracking Area Code";
            translated_value = qmi_indication_nas_system_info_output_nr5g_tracking_area_code_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_DCNR_RESTRICTION_INFO:
            tlv_type_str = "DCNR restriction Info";
            translated_value = qmi_indication_nas_system_info_output_dcnr_restriction_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_EUTRA_WITH_NR5G_AVAILABILITY:
            tlv_type_str = "EUTRA with NR5G availability";
            translated_value = qmi_indication_nas_system_info_output_eutra_with_nr5g_availability_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_SYSTEM_INFO:
            tlv_type_str = "NR5G System Info";
            translated_value = qmi_indication_nas_system_info_output_nr5g_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_SERVICE_STATUS_INFO:
            tlv_type_str = "NR5G Service Status Info";
            translated_value = qmi_indication_nas_system_info_output_nr5g_service_status_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO:
            tlv_type_str = "SIM Reject Info";
            translated_value = qmi_indication_nas_system_info_output_sim_reject_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT:
            tlv_type_str = "LTE eMBMS Coverage Info Support";
            translated_value = qmi_indication_nas_system_info_output_lte_embms_coverage_info_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCMA_SYSTEM_INFO_V2:
            tlv_type_str = "TD SCMA System Info v2";
            translated_value = qmi_indication_nas_system_info_output_td_scma_system_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS:
            tlv_type_str = "TD SCDMA Service Status";
            translated_value = qmi_indication_nas_system_info_output_td_scdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION:
            tlv_type_str = "PLMN Not Changed Indication";
            translated_value = qmi_indication_nas_system_info_output_plmn_not_changed_indication_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN:
            tlv_type_str = "WCDMA Cipher Domain";
            translated_value = qmi_indication_nas_system_info_output_wcdma_cipher_domain_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN:
            tlv_type_str = "GSM Cipher Domain";
            translated_value = qmi_indication_nas_system_info_output_gsm_cipher_domain_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT:
            tlv_type_str = "LTE Voice Support";
            translated_value = qmi_indication_nas_system_info_output_lte_voice_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS:
            tlv_type_str = "WCDMA Call Barring Status";
            translated_value = qmi_indication_nas_system_info_output_wcdma_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS:
            tlv_type_str = "GSM Call Barring Status";
            translated_value = qmi_indication_nas_system_info_output_gsm_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO:
            tlv_type_str = "Additional LTE System Info";
            translated_value = qmi_indication_nas_system_info_output_additional_lte_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO:
            tlv_type_str = "Additional WCDMA System Info";
            translated_value = qmi_indication_nas_system_info_output_additional_wcdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO:
            tlv_type_str = "Additional GSM System Info";
            translated_value = qmi_indication_nas_system_info_output_additional_gsm_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO:
            tlv_type_str = "Additional HDR System Info";
            translated_value = qmi_indication_nas_system_info_output_additional_hdr_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO:
            tlv_type_str = "Additional CDMA System Info";
            translated_value = qmi_indication_nas_system_info_output_additional_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO_V2:
            tlv_type_str = "LTE System Info v2";
            translated_value = qmi_indication_nas_system_info_output_lte_system_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO_V2:
            tlv_type_str = "WCDMA System Info v2";
            translated_value = qmi_indication_nas_system_info_output_wcdma_system_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO_V2:
            tlv_type_str = "GSM System Info v2";
            translated_value = qmi_indication_nas_system_info_output_gsm_system_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO:
            tlv_type_str = "HDR System Info";
            translated_value = qmi_indication_nas_system_info_output_hdr_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO:
            tlv_type_str = "CDMA System Info";
            translated_value = qmi_indication_nas_system_info_output_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS:
            tlv_type_str = "LTE Service Status";
            translated_value = qmi_indication_nas_system_info_output_lte_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS:
            tlv_type_str = "WCDMA Service Status";
            translated_value = qmi_indication_nas_system_info_output_wcdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS:
            tlv_type_str = "GSM Service Status";
            translated_value = qmi_indication_nas_system_info_output_gsm_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS:
            tlv_type_str = "HDR Service Status";
            translated_value = qmi_indication_nas_system_info_output_hdr_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS:
            tlv_type_str = "CDMA Service Status";
            translated_value = qmi_indication_nas_system_info_output_cdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
indication_system_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"System Info\" (0x004E)\n",
                            line_prefix);

    {
        struct indication_system_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_system_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasSystemInfoOutput *
__qmi_indication_nas_system_info_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasSystemInfoOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_INDICATION_NAS_SYSTEM_INFO);

    self = g_slice_new0 (QmiIndicationNasSystemInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_TRACKING_AREA_CODE, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_nr5g_tracking_area_code_out;
            }
            {
                guint nr5g_tracking_area_code_i;
                guint16 nr5g_tracking_area_code_n_items = 3;


                self->arg_nr5g_tracking_area_code = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)nr5g_tracking_area_code_n_items);

                for (nr5g_tracking_area_code_i = 0; nr5g_tracking_area_code_i < nr5g_tracking_area_code_n_items; nr5g_tracking_area_code_i++) {
                    guint8 nr5g_tracking_area_code_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(nr5g_tracking_area_code_aux), NULL))
                        goto qmi_indication_nas_system_info_output_nr5g_tracking_area_code_out;
                    g_array_insert_val (self->arg_nr5g_tracking_area_code, nr5g_tracking_area_code_i, nr5g_tracking_area_code_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'NR5G Tracking Area Code' TLV", offset);
            }

            self->arg_nr5g_tracking_area_code_set = TRUE;

qmi_indication_nas_system_info_output_nr5g_tracking_area_code_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_DCNR_RESTRICTION_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_dcnr_restriction_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_dcnr_restriction_info_out;
                self->arg_dcnr_restriction_info = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'DCNR restriction Info' TLV", offset);
            }

            self->arg_dcnr_restriction_info_set = TRUE;

qmi_indication_nas_system_info_output_dcnr_restriction_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_EUTRA_WITH_NR5G_AVAILABILITY, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_eutra_with_nr5g_availability_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_eutra_with_nr5g_availability_out;
                self->arg_eutra_with_nr5g_availability = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'EUTRA with NR5G availability' TLV", offset);
            }

            self->arg_eutra_with_nr5g_availability_set = TRUE;

qmi_indication_nas_system_info_output_eutra_with_nr5g_availability_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_lac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_system_info_lac), NULL))
                goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_cid_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_system_info_cid), NULL))
                goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_registration_reject_info_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_nr5g_system_info_registration_reject_cause), NULL))
                goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_nr5g_system_info_mcc[0], NULL))
                goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
            self->arg_nr5g_system_info_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_nr5g_system_info_mnc[0], NULL))
                goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
            self->arg_nr5g_system_info_mnc[3] = '\0';
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_tac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_system_info_tac), NULL))
                goto qmi_indication_nas_system_info_output_nr5g_system_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'NR5G System Info' TLV", offset);
            }

            self->arg_nr5g_system_info_set = TRUE;

qmi_indication_nas_system_info_output_nr5g_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_NR5G_SERVICE_STATUS_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_nr5g_service_status_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_service_status_info_out;
                self->arg_nr5g_service_status_info_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_service_status_info_out;
                self->arg_nr5g_service_status_info_true_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_nr5g_service_status_info_out;
                self->arg_nr5g_service_status_info_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'NR5G Service Status Info' TLV", offset);
            }

            self->arg_nr5g_service_status_info_set = TRUE;

qmi_indication_nas_system_info_output_nr5g_service_status_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_sim_reject_info_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_sim_reject_info_out;
                self->arg_sim_reject_info = (QmiNasSimRejectState)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'SIM Reject Info' TLV", offset);
            }

            self->arg_sim_reject_info_set = TRUE;

qmi_indication_nas_system_info_output_sim_reject_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_lte_embms_coverage_info_support_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_embms_coverage_info_support_out;
                self->arg_lte_embms_coverage_info_support = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE eMBMS Coverage Info Support' TLV", offset);
            }

            self->arg_lte_embms_coverage_info_support_set = TRUE;

qmi_indication_nas_system_info_output_lte_embms_coverage_info_support_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCMA_SYSTEM_INFO_V2, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_lac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_td_scma_system_info_v2_lac), NULL))
                goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_cid_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_td_scma_system_info_v2_cid), NULL))
                goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_registration_reject_info_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_registration_reject_cause = (QmiNasRejectCause)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_td_scma_system_info_v2_mcc[0], NULL))
                goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
            self->arg_td_scma_system_info_v2_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_td_scma_system_info_v2_mnc[0], NULL))
                goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
            self->arg_td_scma_system_info_v2_mnc[3] = '\0';
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_hs_call_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_hs_call_status = (QmiNasWcdmaHsService)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_hs_service_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_hs_service = (QmiNasWcdmaHsService)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_cell_parameter_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_td_scma_system_info_v2_cell_parameter_id), NULL))
                goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_cell_broadcast_support_valid = (gboolean)tmp;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_cs_call_barring_status_valid = (gboolean)tmp;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_cs_call_barring_status = (QmiNasCallBarringStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_ps_call_barring_status_valid = (gboolean)tmp;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_ps_call_barring_status = (QmiNasCallBarringStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_cipher_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scma_system_info_v2_out;
                self->arg_td_scma_system_info_v2_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'TD SCMA System Info v2' TLV", offset);
            }

            self->arg_td_scma_system_info_v2_set = TRUE;

qmi_indication_nas_system_info_output_td_scma_system_info_v2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_td_scdma_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scdma_service_status_out;
                self->arg_td_scdma_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scdma_service_status_out;
                self->arg_td_scdma_service_status_true_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_td_scdma_service_status_out;
                self->arg_td_scdma_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'TD SCDMA Service Status' TLV", offset);
            }

            self->arg_td_scdma_service_status_set = TRUE;

qmi_indication_nas_system_info_output_td_scdma_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_plmn_not_changed_indication_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_plmn_not_changed_indication_out;
                self->arg_plmn_not_changed_indication = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'PLMN Not Changed Indication' TLV", offset);
            }

            self->arg_plmn_not_changed_indication_set = TRUE;

qmi_indication_nas_system_info_output_plmn_not_changed_indication_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_wcdma_cipher_domain_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_cipher_domain_out;
                self->arg_wcdma_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'WCDMA Cipher Domain' TLV", offset);
            }

            self->arg_wcdma_cipher_domain_set = TRUE;

qmi_indication_nas_system_info_output_wcdma_cipher_domain_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_gsm_cipher_domain_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_cipher_domain_out;
                self->arg_gsm_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM Cipher Domain' TLV", offset);
            }

            self->arg_gsm_cipher_domain_set = TRUE;

qmi_indication_nas_system_info_output_gsm_cipher_domain_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_lte_voice_support_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_voice_support_out;
                self->arg_lte_voice_support = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Voice Support' TLV", offset);
            }

            self->arg_lte_voice_support_set = TRUE;

qmi_indication_nas_system_info_output_lte_voice_support_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_wcdma_call_barring_status_out;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_call_barring_status_out;
                self->arg_wcdma_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_call_barring_status_out;
                self->arg_wcdma_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'WCDMA Call Barring Status' TLV", offset);
            }

            self->arg_wcdma_call_barring_status_set = TRUE;

qmi_indication_nas_system_info_output_wcdma_call_barring_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_gsm_call_barring_status_out;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_call_barring_status_out;
                self->arg_gsm_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_call_barring_status_out;
                self->arg_gsm_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM Call Barring Status' TLV", offset);
            }

            self->arg_gsm_call_barring_status_set = TRUE;

qmi_indication_nas_system_info_output_gsm_call_barring_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_additional_lte_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_lte_system_info_geo_system_index), NULL))
                goto qmi_indication_nas_system_info_output_additional_lte_system_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Additional LTE System Info' TLV", offset);
            }

            self->arg_additional_lte_system_info_set = TRUE;

qmi_indication_nas_system_info_output_additional_lte_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_additional_wcdma_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_wcdma_system_info_geo_system_index), NULL))
                goto qmi_indication_nas_system_info_output_additional_wcdma_system_info_out;
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_additional_wcdma_system_info_out;
                self->arg_additional_wcdma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Additional WCDMA System Info' TLV", offset);
            }

            self->arg_additional_wcdma_system_info_set = TRUE;

qmi_indication_nas_system_info_output_additional_wcdma_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_additional_gsm_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_gsm_system_info_geo_system_index), NULL))
                goto qmi_indication_nas_system_info_output_additional_gsm_system_info_out;
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_additional_gsm_system_info_out;
                self->arg_additional_gsm_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Additional GSM System Info' TLV", offset);
            }

            self->arg_additional_gsm_system_info_set = TRUE;

qmi_indication_nas_system_info_output_additional_gsm_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_additional_hdr_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_hdr_system_info_geo_system_index), NULL))
                goto qmi_indication_nas_system_info_output_additional_hdr_system_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Additional HDR System Info' TLV", offset);
            }

            self->arg_additional_hdr_system_info_set = TRUE;

qmi_indication_nas_system_info_output_additional_hdr_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_additional_cdma_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_cdma_system_info_geo_system_index), NULL))
                goto qmi_indication_nas_system_info_output_additional_cdma_system_info_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_cdma_system_info_registration_period), NULL))
                goto qmi_indication_nas_system_info_output_additional_cdma_system_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Additional CDMA System Info' TLV", offset);
            }

            self->arg_additional_cdma_system_info_set = TRUE;

qmi_indication_nas_system_info_output_additional_cdma_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO_V2, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_lac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_system_info_v2_lac), NULL))
                goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_cid_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_system_info_v2_cid), NULL))
                goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_registration_reject_info_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_registration_reject_cause = (QmiNasRejectCause)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_lte_system_info_v2_mcc[0], NULL))
                goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
            self->arg_lte_system_info_v2_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_lte_system_info_v2_mnc[0], NULL))
                goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
            self->arg_lte_system_info_v2_mnc[3] = '\0';
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_tac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_system_info_v2_tac), NULL))
                goto qmi_indication_nas_system_info_output_lte_system_info_v2_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE System Info v2' TLV", offset);
            }

            self->arg_lte_system_info_v2_set = TRUE;

qmi_indication_nas_system_info_output_lte_system_info_v2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO_V2, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_lac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_wcdma_system_info_v2_lac), NULL))
                goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_cid_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_wcdma_system_info_v2_cid), NULL))
                goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_registration_reject_info_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_registration_reject_cause = (QmiNasRejectCause)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_wcdma_system_info_v2_mcc[0], NULL))
                goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
            self->arg_wcdma_system_info_v2_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_wcdma_system_info_v2_mnc[0], NULL))
                goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
            self->arg_wcdma_system_info_v2_mnc[3] = '\0';
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_hs_call_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_hs_call_status = (QmiNasWcdmaHsService)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_hs_service_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_hs_service = (QmiNasWcdmaHsService)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_primary_scrambling_code_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_wcdma_system_info_v2_primary_scrambling_code), NULL))
                goto qmi_indication_nas_system_info_output_wcdma_system_info_v2_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'WCDMA System Info v2' TLV", offset);
            }

            self->arg_wcdma_system_info_v2_set = TRUE;

qmi_indication_nas_system_info_output_wcdma_system_info_v2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO_V2, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_lac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_gsm_system_info_v2_lac), NULL))
                goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_cid_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_gsm_system_info_v2_cid), NULL))
                goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_registration_reject_info_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_registration_reject_cause = (QmiNasRejectCause)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_gsm_system_info_v2_mcc[0], NULL))
                goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
            self->arg_gsm_system_info_v2_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_gsm_system_info_v2_mnc[0], NULL))
                goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
            self->arg_gsm_system_info_v2_mnc[3] = '\0';
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_egprs_support_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_egprs_support = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_dtm_support_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_dtm_support = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM System Info v2' TLV", offset);
            }

            self->arg_gsm_system_info_v2_set = TRUE;

qmi_indication_nas_system_info_output_gsm_system_info_v2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_hdr_system_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_prl_match_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_prl_match = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_personality_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_personality = (QmiNasHdrPersonality)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_protocol_revision_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_protocol_revision = (QmiNasHdrProtocolRevision)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_is_856_system_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 16, &self->arg_hdr_system_info_is_856_system_id[0], NULL))
                goto qmi_indication_nas_system_info_output_hdr_system_info_out;
            self->arg_hdr_system_info_is_856_system_id[16] = '\0';

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'HDR System Info' TLV", offset);
            }

            self->arg_hdr_system_info_set = TRUE;

qmi_indication_nas_system_info_output_hdr_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_cdma_system_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_prl_match_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_prl_match = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_p_rev_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_cdma_system_info_p_rev), NULL))
                goto qmi_indication_nas_system_info_output_cdma_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_base_station_p_rev_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_cdma_system_info_base_station_p_rev), NULL))
                goto qmi_indication_nas_system_info_output_cdma_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_concurrent_service_support_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_concurrent_service_support = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_cdma_system_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_sid), NULL))
                goto qmi_indication_nas_system_info_output_cdma_system_info_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_nid), NULL))
                goto qmi_indication_nas_system_info_output_cdma_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_base_station_info_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_base_station_id), NULL))
                goto qmi_indication_nas_system_info_output_cdma_system_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_base_station_latitude), NULL))
                goto qmi_indication_nas_system_info_output_cdma_system_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_base_station_longitude), NULL))
                goto qmi_indication_nas_system_info_output_cdma_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_packet_zone_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_packet_zone), NULL))
                goto qmi_indication_nas_system_info_output_cdma_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_cdma_system_info_mcc[0], NULL))
                goto qmi_indication_nas_system_info_output_cdma_system_info_out;
            self->arg_cdma_system_info_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_cdma_system_info_mnc[0], NULL))
                goto qmi_indication_nas_system_info_output_cdma_system_info_out;
            self->arg_cdma_system_info_mnc[3] = '\0';

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA System Info' TLV", offset);
            }

            self->arg_cdma_system_info_set = TRUE;

qmi_indication_nas_system_info_output_cdma_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_lte_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_service_status_out;
                self->arg_lte_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_service_status_out;
                self->arg_lte_service_status_true_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_lte_service_status_out;
                self->arg_lte_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Service Status' TLV", offset);
            }

            self->arg_lte_service_status_set = TRUE;

qmi_indication_nas_system_info_output_lte_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_wcdma_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_service_status_out;
                self->arg_wcdma_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_service_status_out;
                self->arg_wcdma_service_status_true_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_wcdma_service_status_out;
                self->arg_wcdma_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'WCDMA Service Status' TLV", offset);
            }

            self->arg_wcdma_service_status_set = TRUE;

qmi_indication_nas_system_info_output_wcdma_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_gsm_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_service_status_out;
                self->arg_gsm_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_service_status_out;
                self->arg_gsm_service_status_true_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_gsm_service_status_out;
                self->arg_gsm_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM Service Status' TLV", offset);
            }

            self->arg_gsm_service_status_set = TRUE;

qmi_indication_nas_system_info_output_gsm_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_hdr_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_service_status_out;
                self->arg_hdr_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_hdr_service_status_out;
                self->arg_hdr_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'HDR Service Status' TLV", offset);
            }

            self->arg_hdr_service_status_set = TRUE;

qmi_indication_nas_system_info_output_hdr_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_indication_nas_system_info_output_cdma_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_service_status_out;
                self->arg_cdma_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_system_info_output_cdma_service_status_out;
                self->arg_cdma_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA Service Status' TLV", offset);
            }

            self->arg_cdma_service_status_set = TRUE;

qmi_indication_nas_system_info_output_cdma_service_status_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication NAS Signal Info */


/* --- Output -- */

struct _QmiIndicationNasSignalInfoOutput {
    volatile gint ref_count;

    /* TDMA Signal Strength */
    gboolean arg_tdma_signal_strength_set;
    gint8 arg_tdma_signal_strength;

    /* LTE Signal Strength */
    gboolean arg_lte_signal_strength_set;
    gint8 arg_lte_signal_strength_rssi;
    gint8 arg_lte_signal_strength_rsrq;
    gint16 arg_lte_signal_strength_rsrp;
    gint16 arg_lte_signal_strength_snr;

    /* WCDMA Signal Strength */
    gboolean arg_wcdma_signal_strength_set;
    gint8 arg_wcdma_signal_strength_rssi;
    gint16 arg_wcdma_signal_strength_ecio;

    /* GSM Signal Strength */
    gboolean arg_gsm_signal_strength_set;
    gint8 arg_gsm_signal_strength;

    /* HDR Signal Strength */
    gboolean arg_hdr_signal_strength_set;
    gint8 arg_hdr_signal_strength_rssi;
    gint16 arg_hdr_signal_strength_ecio;
    guint8 arg_hdr_signal_strength_sinr;
    gint32 arg_hdr_signal_strength_io;

    /* CDMA Signal Strength */
    gboolean arg_cdma_signal_strength_set;
    gint8 arg_cdma_signal_strength_rssi;
    gint16 arg_cdma_signal_strength_ecio;
};

#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH 0x15
#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH 0x14
#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH 0x13
#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH 0x12
#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH 0x11
#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH 0x10

gboolean
qmi_indication_nas_signal_info_output_get_tdma_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *value_tdma_signal_strength,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_tdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_tdma_signal_strength)
        *value_tdma_signal_strength = self->arg_tdma_signal_strength;

    return TRUE;
}

gboolean
qmi_indication_nas_signal_info_output_get_lte_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *value_lte_signal_strength_rssi,
    gint8 *value_lte_signal_strength_rsrq,
    gint16 *value_lte_signal_strength_rsrp,
    gint16 *value_lte_signal_strength_snr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_lte_signal_strength_rssi)
        *value_lte_signal_strength_rssi = self->arg_lte_signal_strength_rssi;
    if (value_lte_signal_strength_rsrq)
        *value_lte_signal_strength_rsrq = self->arg_lte_signal_strength_rsrq;
    if (value_lte_signal_strength_rsrp)
        *value_lte_signal_strength_rsrp = self->arg_lte_signal_strength_rsrp;
    if (value_lte_signal_strength_snr)
        *value_lte_signal_strength_snr = self->arg_lte_signal_strength_snr;

    return TRUE;
}

gboolean
qmi_indication_nas_signal_info_output_get_wcdma_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *value_wcdma_signal_strength_rssi,
    gint16 *value_wcdma_signal_strength_ecio,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_wcdma_signal_strength_rssi)
        *value_wcdma_signal_strength_rssi = self->arg_wcdma_signal_strength_rssi;
    if (value_wcdma_signal_strength_ecio)
        *value_wcdma_signal_strength_ecio = self->arg_wcdma_signal_strength_ecio;

    return TRUE;
}

gboolean
qmi_indication_nas_signal_info_output_get_gsm_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *value_gsm_signal_strength,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_gsm_signal_strength)
        *value_gsm_signal_strength = self->arg_gsm_signal_strength;

    return TRUE;
}

gboolean
qmi_indication_nas_signal_info_output_get_hdr_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *value_hdr_signal_strength_rssi,
    gint16 *value_hdr_signal_strength_ecio,
    QmiNasEvdoSinrLevel *value_hdr_signal_strength_sinr,
    gint32 *value_hdr_signal_strength_io,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_hdr_signal_strength_rssi)
        *value_hdr_signal_strength_rssi = self->arg_hdr_signal_strength_rssi;
    if (value_hdr_signal_strength_ecio)
        *value_hdr_signal_strength_ecio = self->arg_hdr_signal_strength_ecio;
    if (value_hdr_signal_strength_sinr)
        *value_hdr_signal_strength_sinr = (QmiNasEvdoSinrLevel)(self->arg_hdr_signal_strength_sinr);
    if (value_hdr_signal_strength_io)
        *value_hdr_signal_strength_io = self->arg_hdr_signal_strength_io;

    return TRUE;
}

gboolean
qmi_indication_nas_signal_info_output_get_cdma_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *value_cdma_signal_strength_rssi,
    gint16 *value_cdma_signal_strength_ecio,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_cdma_signal_strength_rssi)
        *value_cdma_signal_strength_rssi = self->arg_cdma_signal_strength_rssi;
    if (value_cdma_signal_strength_ecio)
        *value_cdma_signal_strength_ecio = self->arg_cdma_signal_strength_ecio;

    return TRUE;
}

GType
qmi_indication_nas_signal_info_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasSignalInfoOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_signal_info_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_signal_info_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiIndicationNasSignalInfoOutput *
qmi_indication_nas_signal_info_output_ref (QmiIndicationNasSignalInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_indication_nas_signal_info_output_unref (QmiIndicationNasSignalInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiIndicationNasSignalInfoOutput, self);
    }
}

static gchar *
qmi_indication_nas_signal_info_output_tdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_signal_info_output_lte_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rssi = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rsrq = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rsrp = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " snr = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_signal_info_output_wcdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rssi = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_signal_info_output_gsm_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_signal_info_output_hdr_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rssi = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " sinr = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_evdo_sinr_level_get_string ((QmiNasEvdoSinrLevel)tmp));
#elif defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_evdo_sinr_level_build_string_from_mask ((QmiNasEvdoSinrLevel)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasEvdoSinrLevel
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " io = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_signal_info_output_cdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rssi = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct indication_signal_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_signal_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_signal_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    {
        switch (type) {
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH:
            tlv_type_str = "TDMA Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_tdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH:
            tlv_type_str = "LTE Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_lte_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH:
            tlv_type_str = "WCDMA Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_wcdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH:
            tlv_type_str = "GSM Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_gsm_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH:
            tlv_type_str = "HDR Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_hdr_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH:
            tlv_type_str = "CDMA Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_cdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
indication_signal_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Signal Info\" (0x0051)\n",
                            line_prefix);

    {
        struct indication_signal_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_signal_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasSignalInfoOutput *
__qmi_indication_nas_signal_info_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasSignalInfoOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_INDICATION_NAS_SIGNAL_INFO);

    self = g_slice_new0 (QmiIndicationNasSignalInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_indication_nas_signal_info_output_tdma_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_tdma_signal_strength), NULL))
                goto qmi_indication_nas_signal_info_output_tdma_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'TDMA Signal Strength' TLV", offset);
            }

            self->arg_tdma_signal_strength_set = TRUE;

qmi_indication_nas_signal_info_output_tdma_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_indication_nas_signal_info_output_lte_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_lte_signal_strength_rssi), NULL))
                goto qmi_indication_nas_signal_info_output_lte_signal_strength_out;
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_lte_signal_strength_rsrq), NULL))
                goto qmi_indication_nas_signal_info_output_lte_signal_strength_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_signal_strength_rsrp), NULL))
                goto qmi_indication_nas_signal_info_output_lte_signal_strength_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_signal_strength_snr), NULL))
                goto qmi_indication_nas_signal_info_output_lte_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Signal Strength' TLV", offset);
            }

            self->arg_lte_signal_strength_set = TRUE;

qmi_indication_nas_signal_info_output_lte_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_indication_nas_signal_info_output_wcdma_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_wcdma_signal_strength_rssi), NULL))
                goto qmi_indication_nas_signal_info_output_wcdma_signal_strength_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_wcdma_signal_strength_ecio), NULL))
                goto qmi_indication_nas_signal_info_output_wcdma_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'WCDMA Signal Strength' TLV", offset);
            }

            self->arg_wcdma_signal_strength_set = TRUE;

qmi_indication_nas_signal_info_output_wcdma_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_indication_nas_signal_info_output_gsm_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_gsm_signal_strength), NULL))
                goto qmi_indication_nas_signal_info_output_gsm_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM Signal Strength' TLV", offset);
            }

            self->arg_gsm_signal_strength_set = TRUE;

qmi_indication_nas_signal_info_output_gsm_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_indication_nas_signal_info_output_hdr_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_hdr_signal_strength_rssi), NULL))
                goto qmi_indication_nas_signal_info_output_hdr_signal_strength_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_hdr_signal_strength_ecio), NULL))
                goto qmi_indication_nas_signal_info_output_hdr_signal_strength_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_signal_info_output_hdr_signal_strength_out;
                self->arg_hdr_signal_strength_sinr = (QmiNasEvdoSinrLevel)tmp;
            }
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_hdr_signal_strength_io), NULL))
                goto qmi_indication_nas_signal_info_output_hdr_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'HDR Signal Strength' TLV", offset);
            }

            self->arg_hdr_signal_strength_set = TRUE;

qmi_indication_nas_signal_info_output_hdr_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_indication_nas_signal_info_output_cdma_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_cdma_signal_strength_rssi), NULL))
                goto qmi_indication_nas_signal_info_output_cdma_signal_strength_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_signal_strength_ecio), NULL))
                goto qmi_indication_nas_signal_info_output_cdma_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA Signal Strength' TLV", offset);
            }

            self->arg_cdma_signal_strength_set = TRUE;

qmi_indication_nas_signal_info_output_cdma_signal_strength_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication NAS Network Reject */


/* --- Output -- */

struct _QmiIndicationNasNetworkRejectOutput {
    volatile gint ref_count;

    /* Closed Subscriber Group */
    gboolean arg_closed_subscriber_group_set;
    guint32 arg_closed_subscriber_group;

    /* PLMN */
    gboolean arg_plmn_set;
    guint16 arg_plmn_mcc;
    guint16 arg_plmn_mnc;
    guint8 arg_plmn_includes_pcs_digit;

    /* Reject Cause */
    gboolean arg_reject_cause_set;
    guint8 arg_reject_cause;

    /* Service Domain */
    gboolean arg_service_domain_set;
    guint8 arg_service_domain;

    /* Radio Interface */
    gboolean arg_radio_interface_set;
    guint8 arg_radio_interface;
};

#define QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_CLOSED_SUBSCRIBER_GROUP 0x11
#define QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_PLMN 0x10
#define QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_REJECT_CAUSE 0x03
#define QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_SERVICE_DOMAIN 0x02
#define QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_RADIO_INTERFACE 0x01

gboolean
qmi_indication_nas_network_reject_output_get_closed_subscriber_group (
    QmiIndicationNasNetworkRejectOutput *self,
    guint32 *value_closed_subscriber_group,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_closed_subscriber_group_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Closed Subscriber Group' was not found in the message");
        return FALSE;
    }

    if (value_closed_subscriber_group)
        *value_closed_subscriber_group = self->arg_closed_subscriber_group;

    return TRUE;
}

gboolean
qmi_indication_nas_network_reject_output_get_plmn (
    QmiIndicationNasNetworkRejectOutput *self,
    guint16 *value_plmn_mcc,
    guint16 *value_plmn_mnc,
    gboolean *value_plmn_includes_pcs_digit,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_plmn_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PLMN' was not found in the message");
        return FALSE;
    }

    if (value_plmn_mcc)
        *value_plmn_mcc = self->arg_plmn_mcc;
    if (value_plmn_mnc)
        *value_plmn_mnc = self->arg_plmn_mnc;
    if (value_plmn_includes_pcs_digit)
        *value_plmn_includes_pcs_digit = (gboolean)(self->arg_plmn_includes_pcs_digit);

    return TRUE;
}

gboolean
qmi_indication_nas_network_reject_output_get_reject_cause (
    QmiIndicationNasNetworkRejectOutput *self,
    QmiNasRejectCause *value_reject_cause,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_reject_cause_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Reject Cause' was not found in the message");
        return FALSE;
    }

    if (value_reject_cause)
        *value_reject_cause = (QmiNasRejectCause)(self->arg_reject_cause);

    return TRUE;
}

gboolean
qmi_indication_nas_network_reject_output_get_service_domain (
    QmiIndicationNasNetworkRejectOutput *self,
    QmiNasNetworkServiceDomain *value_service_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_service_domain_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Service Domain' was not found in the message");
        return FALSE;
    }

    if (value_service_domain)
        *value_service_domain = (QmiNasNetworkServiceDomain)(self->arg_service_domain);

    return TRUE;
}

gboolean
qmi_indication_nas_network_reject_output_get_radio_interface (
    QmiIndicationNasNetworkRejectOutput *self,
    QmiNasRadioInterface *value_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_radio_interface_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Radio Interface' was not found in the message");
        return FALSE;
    }

    if (value_radio_interface)
        *value_radio_interface = (QmiNasRadioInterface)(self->arg_radio_interface);

    return TRUE;
}

GType
qmi_indication_nas_network_reject_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasNetworkRejectOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_network_reject_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_network_reject_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiIndicationNasNetworkRejectOutput *
qmi_indication_nas_network_reject_output_ref (QmiIndicationNasNetworkRejectOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_indication_nas_network_reject_output_unref (QmiIndicationNasNetworkRejectOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiIndicationNasNetworkRejectOutput, self);
    }
}

static gchar *
qmi_indication_nas_network_reject_output_closed_subscriber_group_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_CLOSED_SUBSCRIBER_GROUP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_network_reject_output_plmn_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_PLMN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " includes_pcs_digit = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_network_reject_output_reject_cause_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_REJECT_CAUSE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_REJECT_CAUSE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_reject_cause_get_string ((QmiNasRejectCause)tmp));
#elif defined  __QMI_NAS_REJECT_CAUSE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_reject_cause_build_string_from_mask ((QmiNasRejectCause)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRejectCause
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_network_reject_output_service_domain_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_SERVICE_DOMAIN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_indication_nas_network_reject_output_radio_interface_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_RADIO_INTERFACE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct indication_network_reject_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_network_reject_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_network_reject_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    {
        switch (type) {
        case QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_CLOSED_SUBSCRIBER_GROUP:
            tlv_type_str = "Closed Subscriber Group";
            translated_value = qmi_indication_nas_network_reject_output_closed_subscriber_group_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_PLMN:
            tlv_type_str = "PLMN";
            translated_value = qmi_indication_nas_network_reject_output_plmn_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_REJECT_CAUSE:
            tlv_type_str = "Reject Cause";
            translated_value = qmi_indication_nas_network_reject_output_reject_cause_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_SERVICE_DOMAIN:
            tlv_type_str = "Service Domain";
            translated_value = qmi_indication_nas_network_reject_output_service_domain_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_RADIO_INTERFACE:
            tlv_type_str = "Radio Interface";
            translated_value = qmi_indication_nas_network_reject_output_radio_interface_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
indication_network_reject_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Network Reject\" (0x0068)\n",
                            line_prefix);

    {
        struct indication_network_reject_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_network_reject_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasNetworkRejectOutput *
__qmi_indication_nas_network_reject_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasNetworkRejectOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_INDICATION_NAS_NETWORK_REJECT);

    self = g_slice_new0 (QmiIndicationNasNetworkRejectOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_CLOSED_SUBSCRIBER_GROUP, NULL, NULL)) == 0) {
                goto qmi_indication_nas_network_reject_output_closed_subscriber_group_out;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_closed_subscriber_group), NULL))
                goto qmi_indication_nas_network_reject_output_closed_subscriber_group_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Closed Subscriber Group' TLV", offset);
            }

            self->arg_closed_subscriber_group_set = TRUE;

qmi_indication_nas_network_reject_output_closed_subscriber_group_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_PLMN, NULL, NULL)) == 0) {
                goto qmi_indication_nas_network_reject_output_plmn_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_plmn_mcc), NULL))
                goto qmi_indication_nas_network_reject_output_plmn_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_plmn_mnc), NULL))
                goto qmi_indication_nas_network_reject_output_plmn_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_indication_nas_network_reject_output_plmn_out;
                self->arg_plmn_includes_pcs_digit = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'PLMN' TLV", offset);
            }

            self->arg_plmn_set = TRUE;

qmi_indication_nas_network_reject_output_plmn_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_REJECT_CAUSE, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Reject Cause TLV: ");
                qmi_indication_nas_network_reject_output_unref (self);
                return NULL;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_indication_nas_network_reject_output_reject_cause_out;
                self->arg_reject_cause = (QmiNasRejectCause)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Reject Cause' TLV", offset);
            }

            self->arg_reject_cause_set = TRUE;

qmi_indication_nas_network_reject_output_reject_cause_out:
            if (!self->arg_reject_cause_set) {
                qmi_indication_nas_network_reject_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_SERVICE_DOMAIN, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Service Domain TLV: ");
                qmi_indication_nas_network_reject_output_unref (self);
                return NULL;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_indication_nas_network_reject_output_service_domain_out;
                self->arg_service_domain = (QmiNasNetworkServiceDomain)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Service Domain' TLV", offset);
            }

            self->arg_service_domain_set = TRUE;

qmi_indication_nas_network_reject_output_service_domain_out:
            if (!self->arg_service_domain_set) {
                qmi_indication_nas_network_reject_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_INDICATION_NAS_NETWORK_REJECT_OUTPUT_TLV_RADIO_INTERFACE, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Radio Interface TLV: ");
                qmi_indication_nas_network_reject_output_unref (self);
                return NULL;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_indication_nas_network_reject_output_radio_interface_out;
                self->arg_radio_interface = (QmiNasRadioInterface)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Radio Interface' TLV", offset);
            }

            self->arg_radio_interface_set = TRUE;

qmi_indication_nas_network_reject_output_radio_interface_out:
            if (!self->arg_radio_interface_set) {
                qmi_indication_nas_network_reject_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Reset */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_reset_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_RESET);

    return g_steal_pointer (&self);
}

/* --- Output -- */

typedef struct _QmiMessageResult {
    guint16 error_status;
    guint16 error_code;
} QmiMessageResult;

struct _QmiMessageNasResetOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_RESET_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_reset_output_get_result (
    QmiMessageNasResetOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_reset_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasResetOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_reset_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_reset_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasResetOutput *
qmi_message_nas_reset_output_ref (QmiMessageNasResetOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_reset_output_unref (QmiMessageNasResetOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasResetOutput, self);
    }
}

static gboolean
qmi_message_result_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    static const guint expected_len = 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Result' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    return TRUE;
}

static gchar *
qmi_message_result_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    guint16 error_status;
    guint16 error_code;

    if ((init_offset = qmi_message_tlv_read_init (self, QMI_MESSAGE_NAS_RESET_OUTPUT_TLV_RESULT, NULL, NULL)) == 0)
        return NULL;
    if (!qmi_message_tlv_read_guint16 (self, init_offset, &offset, QMI_ENDIAN_LITTLE, &error_status, NULL))
        return NULL;
    if (!qmi_message_tlv_read_guint16 (self, init_offset, &offset, QMI_ENDIAN_LITTLE, &error_code, NULL))
        return NULL;
    g_warn_if_fail (qmi_message_tlv_read_remaining_size (self, init_offset, offset) == 0);

    if (error_status == QMI_STATUS_SUCCESS)
        return g_strdup ("SUCCESS");

    return g_strdup_printf ("FAILURE: %s", qmi_protocol_error_get_string ((QmiProtocolError) error_code));
}

struct message_reset_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_reset_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_reset_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_RESET_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_reset_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Reset\" (0x0000)\n",
                            line_prefix);

    {
        struct message_reset_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_reset_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasResetOutput *
__qmi_message_nas_reset_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasResetOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_RESET);

    self = g_slice_new0 (QmiMessageNasResetOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_RESET_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_reset_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_reset_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Abort */


/* --- Input -- */

typedef struct _QmiMessageNasAbortInput QmiMessageNasAbortInput;
static GType qmi_message_nas_abort_input_get_type (void) G_GNUC_CONST;
#define QMI_TYPE_MESSAGE_NAS_ABORT_INPUT (qmi_message_nas_abort_input_get_type ())

struct _QmiMessageNasAbortInput {
    volatile gint ref_count;

    /* Transaction ID */
    gboolean arg_transaction_id_set;
    guint16 arg_transaction_id;
};

#define QMI_MESSAGE_NAS_ABORT_INPUT_TLV_TRANSACTION_ID 0x01

static gboolean qmi_message_nas_abort_input_get_transaction_id (
    QmiMessageNasAbortInput *self,
    guint16 *value_transaction_id,
    GError **error);

static gboolean
qmi_message_nas_abort_input_get_transaction_id (
    QmiMessageNasAbortInput *self,
    guint16 *value_transaction_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_transaction_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Transaction ID' was not found in the message");
        return FALSE;
    }

    if (value_transaction_id)
        *value_transaction_id = self->arg_transaction_id;

    return TRUE;
}

static gboolean qmi_message_nas_abort_input_set_transaction_id (
    QmiMessageNasAbortInput *self,
    guint16 value_transaction_id,
    GError **error);

static gboolean
qmi_message_nas_abort_input_set_transaction_id (
    QmiMessageNasAbortInput *self,
    guint16 value_transaction_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_transaction_id = value_transaction_id;
    self->arg_transaction_id_set = TRUE;

    return TRUE;
}

static QmiMessageNasAbortInput *qmi_message_nas_abort_input_ref (QmiMessageNasAbortInput *self);

static void qmi_message_nas_abort_input_unref (QmiMessageNasAbortInput *self);
G_DEFINE_AUTOPTR_CLEANUP_FUNC (QmiMessageNasAbortInput, qmi_message_nas_abort_input_unref)
static QmiMessageNasAbortInput *qmi_message_nas_abort_input_new (void);

static GType
qmi_message_nas_abort_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasAbortInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_abort_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_abort_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

static QmiMessageNasAbortInput *
qmi_message_nas_abort_input_ref (QmiMessageNasAbortInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

static void
qmi_message_nas_abort_input_unref (QmiMessageNasAbortInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasAbortInput, self);
    }
}

static QmiMessageNasAbortInput *
qmi_message_nas_abort_input_new (void)
{
    QmiMessageNasAbortInput *self;

    self = g_slice_new0 (QmiMessageNasAbortInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_abort_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasAbortInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_ABORT);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Abort' has mandatory TLVs");
        return NULL;
    }

    /* Try to add the 'Transaction ID' TLV */
    if (input->arg_transaction_id_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_ABORT_INPUT_TLV_TRANSACTION_ID, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Transaction ID': ");
            return NULL;
        }

        /* Write the guint16 variable to the buffer */
        if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, input->arg_transaction_id, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'Transaction ID': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Transaction ID': ");
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Transaction ID' in message 'Abort'");
        return NULL;
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

typedef struct _QmiMessageNasAbortOutput QmiMessageNasAbortOutput;
static GType qmi_message_nas_abort_output_get_type (void) G_GNUC_CONST;
#define QMI_TYPE_MESSAGE_NAS_ABORT_OUTPUT (qmi_message_nas_abort_output_get_type ())

struct _QmiMessageNasAbortOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_ABORT_OUTPUT_TLV_RESULT 0x02

gboolean qmi_message_nas_abort_output_get_result (
    QmiMessageNasAbortOutput *self,
    GError **error);

gboolean
qmi_message_nas_abort_output_get_result (
    QmiMessageNasAbortOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

static QmiMessageNasAbortOutput *qmi_message_nas_abort_output_ref (QmiMessageNasAbortOutput *self);

static void qmi_message_nas_abort_output_unref (QmiMessageNasAbortOutput *self);
G_DEFINE_AUTOPTR_CLEANUP_FUNC (QmiMessageNasAbortOutput, qmi_message_nas_abort_output_unref)

static GType
qmi_message_nas_abort_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasAbortOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_abort_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_abort_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

static QmiMessageNasAbortOutput *
qmi_message_nas_abort_output_ref (QmiMessageNasAbortOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

static void
qmi_message_nas_abort_output_unref (QmiMessageNasAbortOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasAbortOutput, self);
    }
}

static gchar *
qmi_message_nas_abort_input_transaction_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_ABORT_INPUT_TLV_TRANSACTION_ID, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_abort_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_abort_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_abort_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_ABORT_INPUT_TLV_TRANSACTION_ID:
            tlv_type_str = "Transaction ID";
            translated_value = qmi_message_nas_abort_input_transaction_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_ABORT_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_abort_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Abort\" (0x0001)\n",
                            line_prefix);

    {
        struct message_abort_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_abort_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasAbortOutput *
__qmi_message_nas_abort_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasAbortOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_ABORT);

    self = g_slice_new0 (QmiMessageNasAbortOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_ABORT_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_abort_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_abort_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Set Event Report */


/* --- Input -- */

struct _QmiMessageNasSetEventReportInput {
    volatile gint ref_count;

    /* LTE RSRP Delta */
    gboolean arg_lte_rsrp_delta_set;
    guint8 arg_lte_rsrp_delta_report;
    guint8 arg_lte_rsrp_delta_rsrp_delta;

    /* LTE SNR Delta */
    gboolean arg_lte_snr_delta_set;
    guint8 arg_lte_snr_delta_report;
    guint8 arg_lte_snr_delta_snr_delta;

    /* SINR Threshold */
    gboolean arg_sinr_threshold_set;
    guint8 arg_sinr_threshold_report;
    GArray *arg_sinr_threshold_thresholds;

    /* ECIO Threshold */
    gboolean arg_ecio_threshold_set;
    guint8 arg_ecio_threshold_report;
    GArray *arg_ecio_threshold_thresholds;

    /* Error Rate Indicator */
    gboolean arg_error_rate_indicator_set;
    guint8 arg_error_rate_indicator;

    /* SINR Indicator */
    gboolean arg_sinr_indicator_set;
    guint8 arg_sinr_indicator_report;
    guint8 arg_sinr_indicator_sinr_delta;

    /* IO Indicator */
    gboolean arg_io_indicator_set;
    guint8 arg_io_indicator_report;
    guint8 arg_io_indicator_io_delta;

    /* ECIO Indicator */
    gboolean arg_ecio_indicator_set;
    guint8 arg_ecio_indicator_report;
    guint8 arg_ecio_indicator_ecio_delta;

    /* RSSI Indicator */
    gboolean arg_rssi_indicator_set;
    guint8 arg_rssi_indicator_report;
    guint8 arg_rssi_indicator_rssi_delta;

    /* Registration Reject Reason */
    gboolean arg_registration_reject_reason_set;
    guint8 arg_registration_reject_reason;

    /* RF Band Information */
    gboolean arg_rf_band_information_set;
    guint8 arg_rf_band_information;

    /* Signal Strength Indicator */
    gboolean arg_signal_strength_indicator_set;
    guint8 arg_signal_strength_indicator_report;
    GArray *arg_signal_strength_indicator_thresholds;
};

#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_RSRP_DELTA 0x1C
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_SNR_DELTA 0x1B
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_THRESHOLD 0x1A
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_THRESHOLD 0x19
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ERROR_RATE_INDICATOR 0x17
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_INDICATOR 0x16
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_IO_INDICATOR 0x15
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_INDICATOR 0x14
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RSSI_INDICATOR 0x13
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_REGISTRATION_REJECT_REASON 0x12
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RF_BAND_INFORMATION 0x11
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SIGNAL_STRENGTH_INDICATOR 0x10

gboolean
qmi_message_nas_set_event_report_input_get_lte_rsrp_delta (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_lte_rsrp_delta_report,
    guint8 *value_lte_rsrp_delta_rsrp_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_rsrp_delta_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE RSRP Delta' was not found in the message");
        return FALSE;
    }

    if (value_lte_rsrp_delta_report)
        *value_lte_rsrp_delta_report = (gboolean)(self->arg_lte_rsrp_delta_report);
    if (value_lte_rsrp_delta_rsrp_delta)
        *value_lte_rsrp_delta_rsrp_delta = self->arg_lte_rsrp_delta_rsrp_delta;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_lte_rsrp_delta (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_lte_rsrp_delta_report,
    guint8 value_lte_rsrp_delta_rsrp_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_lte_rsrp_delta_report = (guint8)(value_lte_rsrp_delta_report);
    self->arg_lte_rsrp_delta_rsrp_delta = value_lte_rsrp_delta_rsrp_delta;
    self->arg_lte_rsrp_delta_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_get_lte_snr_delta (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_lte_snr_delta_report,
    guint8 *value_lte_snr_delta_snr_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_snr_delta_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE SNR Delta' was not found in the message");
        return FALSE;
    }

    if (value_lte_snr_delta_report)
        *value_lte_snr_delta_report = (gboolean)(self->arg_lte_snr_delta_report);
    if (value_lte_snr_delta_snr_delta)
        *value_lte_snr_delta_snr_delta = self->arg_lte_snr_delta_snr_delta;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_lte_snr_delta (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_lte_snr_delta_report,
    guint8 value_lte_snr_delta_snr_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_lte_snr_delta_report = (guint8)(value_lte_snr_delta_report);
    self->arg_lte_snr_delta_snr_delta = value_lte_snr_delta_snr_delta;
    self->arg_lte_snr_delta_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_get_sinr_threshold (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_sinr_threshold_report,
    GArray **value_sinr_threshold_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sinr_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SINR Threshold' was not found in the message");
        return FALSE;
    }

    if (value_sinr_threshold_report)
        *value_sinr_threshold_report = (gboolean)(self->arg_sinr_threshold_report);
    if (value_sinr_threshold_thresholds)
        *value_sinr_threshold_thresholds = self->arg_sinr_threshold_thresholds;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_sinr_threshold (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_sinr_threshold_report,
    GArray *value_sinr_threshold_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_sinr_threshold_report = (guint8)(value_sinr_threshold_report);
    if (self->arg_sinr_threshold_thresholds)
        g_array_unref (self->arg_sinr_threshold_thresholds);
    self->arg_sinr_threshold_thresholds = g_array_ref (value_sinr_threshold_thresholds);
    self->arg_sinr_threshold_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_get_ecio_threshold (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_ecio_threshold_report,
    GArray **value_ecio_threshold_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ecio_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ECIO Threshold' was not found in the message");
        return FALSE;
    }

    if (value_ecio_threshold_report)
        *value_ecio_threshold_report = (gboolean)(self->arg_ecio_threshold_report);
    if (value_ecio_threshold_thresholds)
        *value_ecio_threshold_thresholds = self->arg_ecio_threshold_thresholds;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_ecio_threshold (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_ecio_threshold_report,
    GArray *value_ecio_threshold_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_ecio_threshold_report = (guint8)(value_ecio_threshold_report);
    if (self->arg_ecio_threshold_thresholds)
        g_array_unref (self->arg_ecio_threshold_thresholds);
    self->arg_ecio_threshold_thresholds = g_array_ref (value_ecio_threshold_thresholds);
    self->arg_ecio_threshold_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_get_error_rate_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_error_rate_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_error_rate_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Error Rate Indicator' was not found in the message");
        return FALSE;
    }

    if (value_error_rate_indicator)
        *value_error_rate_indicator = (gboolean)(self->arg_error_rate_indicator);

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_error_rate_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_error_rate_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_error_rate_indicator = (guint8)(value_error_rate_indicator);
    self->arg_error_rate_indicator_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_get_sinr_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_sinr_indicator_report,
    guint8 *value_sinr_indicator_sinr_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sinr_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SINR Indicator' was not found in the message");
        return FALSE;
    }

    if (value_sinr_indicator_report)
        *value_sinr_indicator_report = (gboolean)(self->arg_sinr_indicator_report);
    if (value_sinr_indicator_sinr_delta)
        *value_sinr_indicator_sinr_delta = self->arg_sinr_indicator_sinr_delta;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_sinr_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_sinr_indicator_report,
    guint8 value_sinr_indicator_sinr_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_sinr_indicator_report = (guint8)(value_sinr_indicator_report);
    self->arg_sinr_indicator_sinr_delta = value_sinr_indicator_sinr_delta;
    self->arg_sinr_indicator_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_get_io_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_io_indicator_report,
    guint8 *value_io_indicator_io_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_io_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'IO Indicator' was not found in the message");
        return FALSE;
    }

    if (value_io_indicator_report)
        *value_io_indicator_report = (gboolean)(self->arg_io_indicator_report);
    if (value_io_indicator_io_delta)
        *value_io_indicator_io_delta = self->arg_io_indicator_io_delta;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_io_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_io_indicator_report,
    guint8 value_io_indicator_io_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_io_indicator_report = (guint8)(value_io_indicator_report);
    self->arg_io_indicator_io_delta = value_io_indicator_io_delta;
    self->arg_io_indicator_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_get_ecio_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_ecio_indicator_report,
    guint8 *value_ecio_indicator_ecio_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ecio_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ECIO Indicator' was not found in the message");
        return FALSE;
    }

    if (value_ecio_indicator_report)
        *value_ecio_indicator_report = (gboolean)(self->arg_ecio_indicator_report);
    if (value_ecio_indicator_ecio_delta)
        *value_ecio_indicator_ecio_delta = self->arg_ecio_indicator_ecio_delta;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_ecio_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_ecio_indicator_report,
    guint8 value_ecio_indicator_ecio_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_ecio_indicator_report = (guint8)(value_ecio_indicator_report);
    self->arg_ecio_indicator_ecio_delta = value_ecio_indicator_ecio_delta;
    self->arg_ecio_indicator_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_get_rssi_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_rssi_indicator_report,
    guint8 *value_rssi_indicator_rssi_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rssi_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSSI Indicator' was not found in the message");
        return FALSE;
    }

    if (value_rssi_indicator_report)
        *value_rssi_indicator_report = (gboolean)(self->arg_rssi_indicator_report);
    if (value_rssi_indicator_rssi_delta)
        *value_rssi_indicator_rssi_delta = self->arg_rssi_indicator_rssi_delta;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_rssi_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_rssi_indicator_report,
    guint8 value_rssi_indicator_rssi_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_rssi_indicator_report = (guint8)(value_rssi_indicator_report);
    self->arg_rssi_indicator_rssi_delta = value_rssi_indicator_rssi_delta;
    self->arg_rssi_indicator_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_get_registration_reject_reason (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_registration_reject_reason,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_registration_reject_reason_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Registration Reject Reason' was not found in the message");
        return FALSE;
    }

    if (value_registration_reject_reason)
        *value_registration_reject_reason = (gboolean)(self->arg_registration_reject_reason);

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_registration_reject_reason (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_registration_reject_reason,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_registration_reject_reason = (guint8)(value_registration_reject_reason);
    self->arg_registration_reject_reason_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_get_rf_band_information (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_rf_band_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rf_band_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RF Band Information' was not found in the message");
        return FALSE;
    }

    if (value_rf_band_information)
        *value_rf_band_information = (gboolean)(self->arg_rf_band_information);

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_rf_band_information (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_rf_band_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_rf_band_information = (guint8)(value_rf_band_information);
    self->arg_rf_band_information_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_get_signal_strength_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *value_signal_strength_indicator_report,
    GArray **value_signal_strength_indicator_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_signal_strength_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Signal Strength Indicator' was not found in the message");
        return FALSE;
    }

    if (value_signal_strength_indicator_report)
        *value_signal_strength_indicator_report = (gboolean)(self->arg_signal_strength_indicator_report);
    if (value_signal_strength_indicator_thresholds)
        *value_signal_strength_indicator_thresholds = self->arg_signal_strength_indicator_thresholds;

    return TRUE;
}

gboolean
qmi_message_nas_set_event_report_input_set_signal_strength_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean value_signal_strength_indicator_report,
    GArray *value_signal_strength_indicator_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_signal_strength_indicator_report = (guint8)(value_signal_strength_indicator_report);
    if (self->arg_signal_strength_indicator_thresholds)
        g_array_unref (self->arg_signal_strength_indicator_thresholds);
    self->arg_signal_strength_indicator_thresholds = g_array_ref (value_signal_strength_indicator_thresholds);
    self->arg_signal_strength_indicator_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_set_event_report_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetEventReportInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_event_report_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_event_report_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasSetEventReportInput *
qmi_message_nas_set_event_report_input_ref (QmiMessageNasSetEventReportInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_set_event_report_input_unref (QmiMessageNasSetEventReportInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_sinr_threshold_thresholds)
            g_array_unref (self->arg_sinr_threshold_thresholds);
        if (self->arg_ecio_threshold_thresholds)
            g_array_unref (self->arg_ecio_threshold_thresholds);
        if (self->arg_signal_strength_indicator_thresholds)
            g_array_unref (self->arg_signal_strength_indicator_thresholds);
        g_slice_free (QmiMessageNasSetEventReportInput, self);
    }
}

QmiMessageNasSetEventReportInput *
qmi_message_nas_set_event_report_input_new (void)
{
    QmiMessageNasSetEventReportInput *self;

    self = g_slice_new0 (QmiMessageNasSetEventReportInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_set_event_report_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasSetEventReportInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_SET_EVENT_REPORT);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return g_steal_pointer (&self);

    /* Try to add the 'LTE RSRP Delta' TLV */
    if (input->arg_lte_rsrp_delta_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_RSRP_DELTA, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'LTE RSRP Delta': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_lte_rsrp_delta_report;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'LTE RSRP Delta': ");
                return NULL;
            }
        }
        /* Write the guint8 variable to the buffer */
        if (!qmi_message_tlv_write_guint8 (self, input->arg_lte_rsrp_delta_rsrp_delta, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'LTE RSRP Delta': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'LTE RSRP Delta': ");
            return NULL;
        }
    }

    /* Try to add the 'LTE SNR Delta' TLV */
    if (input->arg_lte_snr_delta_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_SNR_DELTA, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'LTE SNR Delta': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_lte_snr_delta_report;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'LTE SNR Delta': ");
                return NULL;
            }
        }
        /* Write the guint8 variable to the buffer */
        if (!qmi_message_tlv_write_guint8 (self, input->arg_lte_snr_delta_snr_delta, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'LTE SNR Delta': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'LTE SNR Delta': ");
            return NULL;
        }
    }

    /* Try to add the 'SINR Threshold' TLV */
    if (input->arg_sinr_threshold_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_THRESHOLD, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'SINR Threshold': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_sinr_threshold_report;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'SINR Threshold': ");
                return NULL;
            }
        }
        {
            guint thresholds_i;
            guint8 thresholds_n_items;

            /* Write the number of items in the array first */
            thresholds_n_items = (guint8) input->arg_sinr_threshold_thresholds->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, thresholds_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'SINR Threshold': ");
                return NULL;
            }

            for (thresholds_i = 0; thresholds_i < input->arg_sinr_threshold_thresholds->len; thresholds_i++) {
                /* Write the guint8 variable to the buffer */
                if (!qmi_message_tlv_write_guint8 (self, g_array_index (input->arg_sinr_threshold_thresholds, guint8,thresholds_i), error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'SINR Threshold': ");
                    return NULL;
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'SINR Threshold': ");
            return NULL;
        }
    }

    /* Try to add the 'ECIO Threshold' TLV */
    if (input->arg_ecio_threshold_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_THRESHOLD, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'ECIO Threshold': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_ecio_threshold_report;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'ECIO Threshold': ");
                return NULL;
            }
        }
        {
            guint thresholds_i;
            guint8 thresholds_n_items;

            /* Write the number of items in the array first */
            thresholds_n_items = (guint8) input->arg_ecio_threshold_thresholds->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, thresholds_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'ECIO Threshold': ");
                return NULL;
            }

            for (thresholds_i = 0; thresholds_i < input->arg_ecio_threshold_thresholds->len; thresholds_i++) {
                /* Write the gint16 variable to the buffer */
                if (!qmi_message_tlv_write_gint16 (self, QMI_ENDIAN_LITTLE, g_array_index (input->arg_ecio_threshold_thresholds, gint16,thresholds_i), error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'ECIO Threshold': ");
                    return NULL;
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'ECIO Threshold': ");
            return NULL;
        }
    }

    /* Try to add the 'Error Rate Indicator' TLV */
    if (input->arg_error_rate_indicator_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ERROR_RATE_INDICATOR, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Error Rate Indicator': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_error_rate_indicator;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Error Rate Indicator': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Error Rate Indicator': ");
            return NULL;
        }
    }

    /* Try to add the 'SINR Indicator' TLV */
    if (input->arg_sinr_indicator_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_INDICATOR, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'SINR Indicator': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_sinr_indicator_report;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'SINR Indicator': ");
                return NULL;
            }
        }
        /* Write the guint8 variable to the buffer */
        if (!qmi_message_tlv_write_guint8 (self, input->arg_sinr_indicator_sinr_delta, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'SINR Indicator': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'SINR Indicator': ");
            return NULL;
        }
    }

    /* Try to add the 'IO Indicator' TLV */
    if (input->arg_io_indicator_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_IO_INDICATOR, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'IO Indicator': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_io_indicator_report;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'IO Indicator': ");
                return NULL;
            }
        }
        /* Write the guint8 variable to the buffer */
        if (!qmi_message_tlv_write_guint8 (self, input->arg_io_indicator_io_delta, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'IO Indicator': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'IO Indicator': ");
            return NULL;
        }
    }

    /* Try to add the 'ECIO Indicator' TLV */
    if (input->arg_ecio_indicator_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_INDICATOR, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'ECIO Indicator': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_ecio_indicator_report;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'ECIO Indicator': ");
                return NULL;
            }
        }
        /* Write the guint8 variable to the buffer */
        if (!qmi_message_tlv_write_guint8 (self, input->arg_ecio_indicator_ecio_delta, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'ECIO Indicator': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'ECIO Indicator': ");
            return NULL;
        }
    }

    /* Try to add the 'RSSI Indicator' TLV */
    if (input->arg_rssi_indicator_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RSSI_INDICATOR, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'RSSI Indicator': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_rssi_indicator_report;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'RSSI Indicator': ");
                return NULL;
            }
        }
        /* Write the guint8 variable to the buffer */
        if (!qmi_message_tlv_write_guint8 (self, input->arg_rssi_indicator_rssi_delta, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'RSSI Indicator': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'RSSI Indicator': ");
            return NULL;
        }
    }

    /* Try to add the 'Registration Reject Reason' TLV */
    if (input->arg_registration_reject_reason_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_REGISTRATION_REJECT_REASON, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Registration Reject Reason': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_registration_reject_reason;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Registration Reject Reason': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Registration Reject Reason': ");
            return NULL;
        }
    }

    /* Try to add the 'RF Band Information' TLV */
    if (input->arg_rf_band_information_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RF_BAND_INFORMATION, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'RF Band Information': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_rf_band_information;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'RF Band Information': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'RF Band Information': ");
            return NULL;
        }
    }

    /* Try to add the 'Signal Strength Indicator' TLV */
    if (input->arg_signal_strength_indicator_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SIGNAL_STRENGTH_INDICATOR, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Signal Strength Indicator': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_signal_strength_indicator_report;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Signal Strength Indicator': ");
                return NULL;
            }
        }
        {
            guint thresholds_i;
            guint8 thresholds_n_items;

            /* Write the number of items in the array first */
            thresholds_n_items = (guint8) input->arg_signal_strength_indicator_thresholds->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, thresholds_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'Signal Strength Indicator': ");
                return NULL;
            }

            for (thresholds_i = 0; thresholds_i < input->arg_signal_strength_indicator_thresholds->len; thresholds_i++) {
                /* Write the gint8 variable to the buffer */
                if (!qmi_message_tlv_write_gint8 (self, g_array_index (input->arg_signal_strength_indicator_thresholds, gint8,thresholds_i), error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'Signal Strength Indicator': ");
                    return NULL;
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Signal Strength Indicator': ");
            return NULL;
        }
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasSetEventReportOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_set_event_report_output_get_result (
    QmiMessageNasSetEventReportOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_set_event_report_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetEventReportOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_event_report_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_event_report_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasSetEventReportOutput *
qmi_message_nas_set_event_report_output_ref (QmiMessageNasSetEventReportOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_set_event_report_output_unref (QmiMessageNasSetEventReportOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasSetEventReportOutput, self);
    }
}

static gchar *
qmi_message_nas_set_event_report_input_lte_rsrp_delta_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_RSRP_DELTA, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " report = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rsrp_delta = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_event_report_input_lte_snr_delta_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_SNR_DELTA, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " report = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " snr_delta = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_event_report_input_sinr_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_THRESHOLD, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " report = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " thresholds = '");
    {
        guint thresholds_i;
        guint8 thresholds_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(thresholds_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (thresholds_i = 0; thresholds_i < thresholds_n_items; thresholds_i++) {
            g_string_append_printf (printable, " [%u] = '", thresholds_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_event_report_input_ecio_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_THRESHOLD, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " report = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " thresholds = '");
    {
        guint thresholds_i;
        guint8 thresholds_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(thresholds_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (thresholds_i = 0; thresholds_i < thresholds_n_items; thresholds_i++) {
            g_string_append_printf (printable, " [%u] = '", thresholds_i);

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_event_report_input_error_rate_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ERROR_RATE_INDICATOR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_event_report_input_sinr_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_INDICATOR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " report = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " sinr_delta = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_event_report_input_io_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_IO_INDICATOR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " report = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " io_delta = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_event_report_input_ecio_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_INDICATOR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " report = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio_delta = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_event_report_input_rssi_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RSSI_INDICATOR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " report = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rssi_delta = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_event_report_input_registration_reject_reason_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_REGISTRATION_REJECT_REASON, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_event_report_input_rf_band_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RF_BAND_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_event_report_input_signal_strength_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SIGNAL_STRENGTH_INDICATOR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " report = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " thresholds = '");
    {
        guint thresholds_i;
        guint8 thresholds_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(thresholds_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (thresholds_i = 0; thresholds_i < thresholds_n_items; thresholds_i++) {
            g_string_append_printf (printable, " [%u] = '", thresholds_i);

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%d", (gint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_set_event_report_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_event_report_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_event_report_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_RSRP_DELTA:
            tlv_type_str = "LTE RSRP Delta";
            translated_value = qmi_message_nas_set_event_report_input_lte_rsrp_delta_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_SNR_DELTA:
            tlv_type_str = "LTE SNR Delta";
            translated_value = qmi_message_nas_set_event_report_input_lte_snr_delta_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_THRESHOLD:
            tlv_type_str = "SINR Threshold";
            translated_value = qmi_message_nas_set_event_report_input_sinr_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_THRESHOLD:
            tlv_type_str = "ECIO Threshold";
            translated_value = qmi_message_nas_set_event_report_input_ecio_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ERROR_RATE_INDICATOR:
            tlv_type_str = "Error Rate Indicator";
            translated_value = qmi_message_nas_set_event_report_input_error_rate_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_INDICATOR:
            tlv_type_str = "SINR Indicator";
            translated_value = qmi_message_nas_set_event_report_input_sinr_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_IO_INDICATOR:
            tlv_type_str = "IO Indicator";
            translated_value = qmi_message_nas_set_event_report_input_io_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_INDICATOR:
            tlv_type_str = "ECIO Indicator";
            translated_value = qmi_message_nas_set_event_report_input_ecio_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RSSI_INDICATOR:
            tlv_type_str = "RSSI Indicator";
            translated_value = qmi_message_nas_set_event_report_input_rssi_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_REGISTRATION_REJECT_REASON:
            tlv_type_str = "Registration Reject Reason";
            translated_value = qmi_message_nas_set_event_report_input_registration_reject_reason_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RF_BAND_INFORMATION:
            tlv_type_str = "RF Band Information";
            translated_value = qmi_message_nas_set_event_report_input_rf_band_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SIGNAL_STRENGTH_INDICATOR:
            tlv_type_str = "Signal Strength Indicator";
            translated_value = qmi_message_nas_set_event_report_input_signal_strength_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_set_event_report_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set Event Report\" (0x0002)\n",
                            line_prefix);

    {
        struct message_set_event_report_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_event_report_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasSetEventReportOutput *
__qmi_message_nas_set_event_report_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasSetEventReportOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_SET_EVENT_REPORT);

    self = g_slice_new0 (QmiMessageNasSetEventReportOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_EVENT_REPORT_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_set_event_report_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_set_event_report_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Register Indications */


/* --- Input -- */

struct _QmiMessageNasRegisterIndicationsInput {
    volatile gint ref_count;

    /* Network Reject Information */
    gboolean arg_network_reject_information_set;
    guint8 arg_network_reject_information_enable_network_reject_indications;
    guint8 arg_network_reject_information_supress_system_info_indications;

    /* RF Band Information */
    gboolean arg_rf_band_information_set;
    guint8 arg_rf_band_information;

    /* eMBMS Status */
    gboolean arg_embms_status_set;
    guint8 arg_embms_status;

    /* Current PLMN Name */
    gboolean arg_current_plmn_name_set;
    guint8 arg_current_plmn_name;

    /* Managed Roaming */
    gboolean arg_managed_roaming_set;
    guint8 arg_managed_roaming;

    /* HDR Session Closed */
    gboolean arg_hdr_session_closed_set;
    guint8 arg_hdr_session_closed;

    /* HDR New UATI Assigned */
    gboolean arg_hdr_new_uati_assigned_set;
    guint8 arg_hdr_new_uati_assigned;

    /* Error Rate */
    gboolean arg_error_rate_set;
    guint8 arg_error_rate;

    /* Signal Info */
    gboolean arg_signal_info_set;
    guint8 arg_signal_info;

    /* System Info */
    gboolean arg_system_info_set;
    guint8 arg_system_info;

    /* Network Time */
    gboolean arg_network_time_set;
    guint8 arg_network_time;

    /* Subscription Info */
    gboolean arg_subscription_info_set;
    guint8 arg_subscription_info;

    /* Dual Standby Preference */
    gboolean arg_dual_standby_preference_set;
    guint8 arg_dual_standby_preference;

    /* Serving System Events */
    gboolean arg_serving_system_events_set;
    guint8 arg_serving_system_events;

    /* DDTM Events */
    gboolean arg_ddtm_events_set;
    guint8 arg_ddtm_events;

    /* System Selection Preference */
    gboolean arg_system_selection_preference_set;
    guint8 arg_system_selection_preference;
};

#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_REJECT_INFORMATION 0x21
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_RF_BAND_INFORMATION 0x20
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_EMBMS_STATUS 0x1F
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_CURRENT_PLMN_NAME 0x1E
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_MANAGED_ROAMING 0x1D
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_SESSION_CLOSED 0x1C
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_NEW_UATI_ASSIGNED 0x1B
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_ERROR_RATE 0x1A
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SIGNAL_INFO 0x19
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_INFO 0x18
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_TIME 0x17
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SUBSCRIPTION_INFO 0x15
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DUAL_STANDBY_PREFERENCE 0x14
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SERVING_SYSTEM_EVENTS 0x13
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DDTM_EVENTS 0x12
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_SELECTION_PREFERENCE 0x10

gboolean
qmi_message_nas_register_indications_input_get_network_reject_information (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_network_reject_information_enable_network_reject_indications,
    gboolean *value_network_reject_information_supress_system_info_indications,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_reject_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Reject Information' was not found in the message");
        return FALSE;
    }

    if (value_network_reject_information_enable_network_reject_indications)
        *value_network_reject_information_enable_network_reject_indications = (gboolean)(self->arg_network_reject_information_enable_network_reject_indications);
    if (value_network_reject_information_supress_system_info_indications)
        *value_network_reject_information_supress_system_info_indications = (gboolean)(self->arg_network_reject_information_supress_system_info_indications);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_network_reject_information (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_network_reject_information_enable_network_reject_indications,
    gboolean value_network_reject_information_supress_system_info_indications,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_network_reject_information_enable_network_reject_indications = (guint8)(value_network_reject_information_enable_network_reject_indications);
    self->arg_network_reject_information_supress_system_info_indications = (guint8)(value_network_reject_information_supress_system_info_indications);
    self->arg_network_reject_information_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_rf_band_information (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_rf_band_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rf_band_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RF Band Information' was not found in the message");
        return FALSE;
    }

    if (value_rf_band_information)
        *value_rf_band_information = (gboolean)(self->arg_rf_band_information);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_rf_band_information (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_rf_band_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_rf_band_information = (guint8)(value_rf_band_information);
    self->arg_rf_band_information_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_embms_status (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_embms_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_embms_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'eMBMS Status' was not found in the message");
        return FALSE;
    }

    if (value_embms_status)
        *value_embms_status = (gboolean)(self->arg_embms_status);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_embms_status (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_embms_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_embms_status = (guint8)(value_embms_status);
    self->arg_embms_status_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_current_plmn_name (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_current_plmn_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_current_plmn_name_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Current PLMN Name' was not found in the message");
        return FALSE;
    }

    if (value_current_plmn_name)
        *value_current_plmn_name = (gboolean)(self->arg_current_plmn_name);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_current_plmn_name (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_current_plmn_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_current_plmn_name = (guint8)(value_current_plmn_name);
    self->arg_current_plmn_name_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_managed_roaming (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_managed_roaming,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_managed_roaming_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Managed Roaming' was not found in the message");
        return FALSE;
    }

    if (value_managed_roaming)
        *value_managed_roaming = (gboolean)(self->arg_managed_roaming);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_managed_roaming (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_managed_roaming,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_managed_roaming = (guint8)(value_managed_roaming);
    self->arg_managed_roaming_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_hdr_session_closed (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_hdr_session_closed,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_session_closed_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Session Closed' was not found in the message");
        return FALSE;
    }

    if (value_hdr_session_closed)
        *value_hdr_session_closed = (gboolean)(self->arg_hdr_session_closed);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_hdr_session_closed (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_hdr_session_closed,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_hdr_session_closed = (guint8)(value_hdr_session_closed);
    self->arg_hdr_session_closed_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_hdr_new_uati_assigned (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_hdr_new_uati_assigned,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_new_uati_assigned_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR New UATI Assigned' was not found in the message");
        return FALSE;
    }

    if (value_hdr_new_uati_assigned)
        *value_hdr_new_uati_assigned = (gboolean)(self->arg_hdr_new_uati_assigned);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_hdr_new_uati_assigned (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_hdr_new_uati_assigned,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_hdr_new_uati_assigned = (guint8)(value_hdr_new_uati_assigned);
    self->arg_hdr_new_uati_assigned_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_error_rate (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_error_rate,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_error_rate_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Error Rate' was not found in the message");
        return FALSE;
    }

    if (value_error_rate)
        *value_error_rate = (gboolean)(self->arg_error_rate);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_error_rate (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_error_rate,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_error_rate = (guint8)(value_error_rate);
    self->arg_error_rate_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_signal_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_signal_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_signal_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Signal Info' was not found in the message");
        return FALSE;
    }

    if (value_signal_info)
        *value_signal_info = (gboolean)(self->arg_signal_info);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_signal_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_signal_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_signal_info = (guint8)(value_signal_info);
    self->arg_signal_info_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_system_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_system_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'System Info' was not found in the message");
        return FALSE;
    }

    if (value_system_info)
        *value_system_info = (gboolean)(self->arg_system_info);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_system_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_system_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_system_info = (guint8)(value_system_info);
    self->arg_system_info_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_network_time (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_network_time,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_time_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Time' was not found in the message");
        return FALSE;
    }

    if (value_network_time)
        *value_network_time = (gboolean)(self->arg_network_time);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_network_time (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_network_time,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_network_time = (guint8)(value_network_time);
    self->arg_network_time_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_subscription_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_subscription_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_subscription_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Subscription Info' was not found in the message");
        return FALSE;
    }

    if (value_subscription_info)
        *value_subscription_info = (gboolean)(self->arg_subscription_info);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_subscription_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_subscription_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_subscription_info = (guint8)(value_subscription_info);
    self->arg_subscription_info_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_dual_standby_preference (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_dual_standby_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_dual_standby_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Dual Standby Preference' was not found in the message");
        return FALSE;
    }

    if (value_dual_standby_preference)
        *value_dual_standby_preference = (gboolean)(self->arg_dual_standby_preference);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_dual_standby_preference (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_dual_standby_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_dual_standby_preference = (guint8)(value_dual_standby_preference);
    self->arg_dual_standby_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_serving_system_events (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_serving_system_events,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_serving_system_events_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Serving System Events' was not found in the message");
        return FALSE;
    }

    if (value_serving_system_events)
        *value_serving_system_events = (gboolean)(self->arg_serving_system_events);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_serving_system_events (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_serving_system_events,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_serving_system_events = (guint8)(value_serving_system_events);
    self->arg_serving_system_events_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_ddtm_events (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_ddtm_events,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ddtm_events_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'DDTM Events' was not found in the message");
        return FALSE;
    }

    if (value_ddtm_events)
        *value_ddtm_events = (gboolean)(self->arg_ddtm_events);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_ddtm_events (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_ddtm_events,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_ddtm_events = (guint8)(value_ddtm_events);
    self->arg_ddtm_events_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_get_system_selection_preference (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *value_system_selection_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_system_selection_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'System Selection Preference' was not found in the message");
        return FALSE;
    }

    if (value_system_selection_preference)
        *value_system_selection_preference = (gboolean)(self->arg_system_selection_preference);

    return TRUE;
}

gboolean
qmi_message_nas_register_indications_input_set_system_selection_preference (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean value_system_selection_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_system_selection_preference = (guint8)(value_system_selection_preference);
    self->arg_system_selection_preference_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_register_indications_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasRegisterIndicationsInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_register_indications_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_register_indications_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasRegisterIndicationsInput *
qmi_message_nas_register_indications_input_ref (QmiMessageNasRegisterIndicationsInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_register_indications_input_unref (QmiMessageNasRegisterIndicationsInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasRegisterIndicationsInput, self);
    }
}

QmiMessageNasRegisterIndicationsInput *
qmi_message_nas_register_indications_input_new (void)
{
    QmiMessageNasRegisterIndicationsInput *self;

    self = g_slice_new0 (QmiMessageNasRegisterIndicationsInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_register_indications_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasRegisterIndicationsInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_REGISTER_INDICATIONS);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return g_steal_pointer (&self);

    /* Try to add the 'Network Reject Information' TLV */
    if (input->arg_network_reject_information_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_REJECT_INFORMATION, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Network Reject Information': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_network_reject_information_enable_network_reject_indications;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Network Reject Information': ");
                return NULL;
            }
        }
        {
            guint8 tmp;

            tmp = (guint8) input->arg_network_reject_information_supress_system_info_indications;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Network Reject Information': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Network Reject Information': ");
            return NULL;
        }
    }

    /* Try to add the 'RF Band Information' TLV */
    if (input->arg_rf_band_information_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_RF_BAND_INFORMATION, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'RF Band Information': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_rf_band_information;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'RF Band Information': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'RF Band Information': ");
            return NULL;
        }
    }

    /* Try to add the 'eMBMS Status' TLV */
    if (input->arg_embms_status_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_EMBMS_STATUS, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'eMBMS Status': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_embms_status;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'eMBMS Status': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'eMBMS Status': ");
            return NULL;
        }
    }

    /* Try to add the 'Current PLMN Name' TLV */
    if (input->arg_current_plmn_name_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_CURRENT_PLMN_NAME, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Current PLMN Name': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_current_plmn_name;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Current PLMN Name': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Current PLMN Name': ");
            return NULL;
        }
    }

    /* Try to add the 'Managed Roaming' TLV */
    if (input->arg_managed_roaming_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_MANAGED_ROAMING, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Managed Roaming': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_managed_roaming;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Managed Roaming': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Managed Roaming': ");
            return NULL;
        }
    }

    /* Try to add the 'HDR Session Closed' TLV */
    if (input->arg_hdr_session_closed_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_SESSION_CLOSED, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'HDR Session Closed': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_hdr_session_closed;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'HDR Session Closed': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'HDR Session Closed': ");
            return NULL;
        }
    }

    /* Try to add the 'HDR New UATI Assigned' TLV */
    if (input->arg_hdr_new_uati_assigned_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_NEW_UATI_ASSIGNED, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'HDR New UATI Assigned': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_hdr_new_uati_assigned;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'HDR New UATI Assigned': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'HDR New UATI Assigned': ");
            return NULL;
        }
    }

    /* Try to add the 'Error Rate' TLV */
    if (input->arg_error_rate_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_ERROR_RATE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Error Rate': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_error_rate;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Error Rate': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Error Rate': ");
            return NULL;
        }
    }

    /* Try to add the 'Signal Info' TLV */
    if (input->arg_signal_info_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SIGNAL_INFO, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Signal Info': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_signal_info;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Signal Info': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Signal Info': ");
            return NULL;
        }
    }

    /* Try to add the 'System Info' TLV */
    if (input->arg_system_info_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_INFO, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'System Info': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_system_info;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'System Info': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'System Info': ");
            return NULL;
        }
    }

    /* Try to add the 'Network Time' TLV */
    if (input->arg_network_time_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_TIME, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Network Time': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_network_time;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Network Time': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Network Time': ");
            return NULL;
        }
    }

    /* Try to add the 'Subscription Info' TLV */
    if (input->arg_subscription_info_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SUBSCRIPTION_INFO, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Subscription Info': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_subscription_info;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Subscription Info': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Subscription Info': ");
            return NULL;
        }
    }

    /* Try to add the 'Dual Standby Preference' TLV */
    if (input->arg_dual_standby_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DUAL_STANDBY_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Dual Standby Preference': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_dual_standby_preference;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Dual Standby Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Dual Standby Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'Serving System Events' TLV */
    if (input->arg_serving_system_events_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SERVING_SYSTEM_EVENTS, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Serving System Events': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_serving_system_events;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Serving System Events': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Serving System Events': ");
            return NULL;
        }
    }

    /* Try to add the 'DDTM Events' TLV */
    if (input->arg_ddtm_events_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DDTM_EVENTS, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'DDTM Events': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_ddtm_events;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'DDTM Events': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'DDTM Events': ");
            return NULL;
        }
    }

    /* Try to add the 'System Selection Preference' TLV */
    if (input->arg_system_selection_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_SELECTION_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'System Selection Preference': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_system_selection_preference;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'System Selection Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'System Selection Preference': ");
            return NULL;
        }
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasRegisterIndicationsOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_register_indications_output_get_result (
    QmiMessageNasRegisterIndicationsOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_register_indications_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasRegisterIndicationsOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_register_indications_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_register_indications_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasRegisterIndicationsOutput *
qmi_message_nas_register_indications_output_ref (QmiMessageNasRegisterIndicationsOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_register_indications_output_unref (QmiMessageNasRegisterIndicationsOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasRegisterIndicationsOutput, self);
    }
}

static gchar *
qmi_message_nas_register_indications_input_network_reject_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_REJECT_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " enable_network_reject_indications = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " supress_system_info_indications = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_rf_band_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_RF_BAND_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_embms_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_EMBMS_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_current_plmn_name_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_CURRENT_PLMN_NAME, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_managed_roaming_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_MANAGED_ROAMING, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_hdr_session_closed_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_SESSION_CLOSED, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_hdr_new_uati_assigned_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_NEW_UATI_ASSIGNED, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_error_rate_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_ERROR_RATE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_signal_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SIGNAL_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_network_time_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_TIME, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_subscription_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SUBSCRIPTION_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_dual_standby_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DUAL_STANDBY_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_serving_system_events_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SERVING_SYSTEM_EVENTS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_ddtm_events_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DDTM_EVENTS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_register_indications_input_system_selection_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_SELECTION_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_register_indications_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_register_indications_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_register_indications_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_REJECT_INFORMATION:
            tlv_type_str = "Network Reject Information";
            translated_value = qmi_message_nas_register_indications_input_network_reject_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_RF_BAND_INFORMATION:
            tlv_type_str = "RF Band Information";
            translated_value = qmi_message_nas_register_indications_input_rf_band_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_EMBMS_STATUS:
            tlv_type_str = "eMBMS Status";
            translated_value = qmi_message_nas_register_indications_input_embms_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_CURRENT_PLMN_NAME:
            tlv_type_str = "Current PLMN Name";
            translated_value = qmi_message_nas_register_indications_input_current_plmn_name_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_MANAGED_ROAMING:
            tlv_type_str = "Managed Roaming";
            translated_value = qmi_message_nas_register_indications_input_managed_roaming_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_SESSION_CLOSED:
            tlv_type_str = "HDR Session Closed";
            translated_value = qmi_message_nas_register_indications_input_hdr_session_closed_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_NEW_UATI_ASSIGNED:
            tlv_type_str = "HDR New UATI Assigned";
            translated_value = qmi_message_nas_register_indications_input_hdr_new_uati_assigned_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_ERROR_RATE:
            tlv_type_str = "Error Rate";
            translated_value = qmi_message_nas_register_indications_input_error_rate_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SIGNAL_INFO:
            tlv_type_str = "Signal Info";
            translated_value = qmi_message_nas_register_indications_input_signal_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_INFO:
            tlv_type_str = "System Info";
            translated_value = qmi_message_nas_register_indications_input_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_TIME:
            tlv_type_str = "Network Time";
            translated_value = qmi_message_nas_register_indications_input_network_time_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SUBSCRIPTION_INFO:
            tlv_type_str = "Subscription Info";
            translated_value = qmi_message_nas_register_indications_input_subscription_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DUAL_STANDBY_PREFERENCE:
            tlv_type_str = "Dual Standby Preference";
            translated_value = qmi_message_nas_register_indications_input_dual_standby_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SERVING_SYSTEM_EVENTS:
            tlv_type_str = "Serving System Events";
            translated_value = qmi_message_nas_register_indications_input_serving_system_events_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DDTM_EVENTS:
            tlv_type_str = "DDTM Events";
            translated_value = qmi_message_nas_register_indications_input_ddtm_events_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_SELECTION_PREFERENCE:
            tlv_type_str = "System Selection Preference";
            translated_value = qmi_message_nas_register_indications_input_system_selection_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_register_indications_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Register Indications\" (0x0003)\n",
                            line_prefix);

    {
        struct message_register_indications_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_register_indications_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasRegisterIndicationsOutput *
__qmi_message_nas_register_indications_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasRegisterIndicationsOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_REGISTER_INDICATIONS);

    self = g_slice_new0 (QmiMessageNasRegisterIndicationsOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_REGISTER_INDICATIONS_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_register_indications_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_register_indications_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Supported Messages */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_supported_messages_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_SUPPORTED_MESSAGES);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetSupportedMessagesOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* List */
    gboolean arg_list_set;
    GArray *arg_list;
};

#define QMI_MESSAGE_NAS_GET_SUPPORTED_MESSAGES_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_SUPPORTED_MESSAGES_OUTPUT_TLV_LIST 0x10

gboolean
qmi_message_nas_get_supported_messages_output_get_result (
    QmiMessageNasGetSupportedMessagesOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_get_supported_messages_output_get_list (
    QmiMessageNasGetSupportedMessagesOutput *self,
    GArray **value_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'List' was not found in the message");
        return FALSE;
    }

    if (value_list)
        *value_list = self->arg_list;

    return TRUE;
}

GType
qmi_message_nas_get_supported_messages_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetSupportedMessagesOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_supported_messages_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_supported_messages_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetSupportedMessagesOutput *
qmi_message_nas_get_supported_messages_output_ref (QmiMessageNasGetSupportedMessagesOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_supported_messages_output_unref (QmiMessageNasGetSupportedMessagesOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_list)
            g_array_unref (self->arg_list);
        g_slice_free (QmiMessageNasGetSupportedMessagesOutput, self);
    }
}

static gchar *
qmi_message_nas_get_supported_messages_output_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SUPPORTED_MESSAGES_OUTPUT_TLV_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint list_i;
        guint16 list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (list_i = 0; list_i < list_n_items; list_i++) {
            g_string_append_printf (printable, " [%u] = '", list_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_supported_messages_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_supported_messages_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_supported_messages_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SUPPORTED_MESSAGES_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SUPPORTED_MESSAGES_OUTPUT_TLV_LIST:
            tlv_type_str = "List";
            translated_value = qmi_message_nas_get_supported_messages_output_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_supported_messages_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Supported Messages\" (0x001E)\n",
                            line_prefix);

    {
        struct message_get_supported_messages_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_supported_messages_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetSupportedMessagesOutput *
__qmi_message_nas_get_supported_messages_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetSupportedMessagesOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_SUPPORTED_MESSAGES);

    self = g_slice_new0 (QmiMessageNasGetSupportedMessagesOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SUPPORTED_MESSAGES_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_supported_messages_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_supported_messages_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SUPPORTED_MESSAGES_OUTPUT_TLV_LIST, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_supported_messages_output_list_out;
            }
            {
                guint list_i;
                guint16 list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(list_n_items), NULL))
                    goto qmi_message_nas_get_supported_messages_output_list_out;

                self->arg_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)list_n_items);

                for (list_i = 0; list_i < list_n_items; list_i++) {
                    guint8 list_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(list_aux), NULL))
                        goto qmi_message_nas_get_supported_messages_output_list_out;
                    g_array_insert_val (self->arg_list, list_i, list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'List' TLV", offset);
            }

            self->arg_list_set = TRUE;

qmi_message_nas_get_supported_messages_output_list_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Signal Strength */


/* --- Input -- */

struct _QmiMessageNasGetSignalStrengthInput {
    volatile gint ref_count;

    /* Request Mask */
    gboolean arg_request_mask_set;
    guint16 arg_request_mask;
};

#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_INPUT_TLV_REQUEST_MASK 0x10

gboolean
qmi_message_nas_get_signal_strength_input_get_request_mask (
    QmiMessageNasGetSignalStrengthInput *self,
    QmiNasSignalStrengthRequest *value_request_mask,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_request_mask_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Request Mask' was not found in the message");
        return FALSE;
    }

    if (value_request_mask)
        *value_request_mask = (QmiNasSignalStrengthRequest)(self->arg_request_mask);

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_strength_input_set_request_mask (
    QmiMessageNasGetSignalStrengthInput *self,
    QmiNasSignalStrengthRequest value_request_mask,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_request_mask = (guint16)(value_request_mask);
    self->arg_request_mask_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_get_signal_strength_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetSignalStrengthInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_signal_strength_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_signal_strength_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetSignalStrengthInput *
qmi_message_nas_get_signal_strength_input_ref (QmiMessageNasGetSignalStrengthInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_signal_strength_input_unref (QmiMessageNasGetSignalStrengthInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetSignalStrengthInput, self);
    }
}

QmiMessageNasGetSignalStrengthInput *
qmi_message_nas_get_signal_strength_input_new (void)
{
    QmiMessageNasGetSignalStrengthInput *self;

    self = g_slice_new0 (QmiMessageNasGetSignalStrengthInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_get_signal_strength_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasGetSignalStrengthInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return g_steal_pointer (&self);

    /* Try to add the 'Request Mask' TLV */
    if (input->arg_request_mask_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_INPUT_TLV_REQUEST_MASK, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Request Mask': ");
            return NULL;
        }

        {
            guint16 tmp;

            tmp = (guint16) input->arg_request_mask;
            /* Write the guint16 variable to the buffer */
            if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Request Mask': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Request Mask': ");
            return NULL;
        }
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetSignalStrengthOutput {
    volatile gint ref_count;

    /* LTE RSRP */
    gboolean arg_lte_rsrp_set;
    gint16 arg_lte_rsrp;

    /* LTE SNR */
    gboolean arg_lte_snr_set;
    gint16 arg_lte_snr;

    /* RSRQ */
    gboolean arg_rsrq_set;
    gint8 arg_rsrq_rsrq;
    gint8 arg_rsrq_radio_interface;

    /* Error Rate List */
    gboolean arg_error_rate_list_set;
    GArray *arg_error_rate_list;

    /* SINR */
    gboolean arg_sinr_set;
    guint8 arg_sinr;

    /* IO */
    gboolean arg_io_set;
    gint32 arg_io;

    /* ECIO List */
    gboolean arg_ecio_list_set;
    GArray *arg_ecio_list;

    /* RSSI List */
    gboolean arg_rssi_list_set;
    GArray *arg_rssi_list;

    /* Strength List */
    gboolean arg_strength_list_set;
    GArray *arg_strength_list;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Signal Strength */
    gboolean arg_signal_strength_set;
    gint8 arg_signal_strength_strength;
    gint8 arg_signal_strength_radio_interface;
};

#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_RSRP 0x18
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_SNR 0x17
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSRQ 0x16
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ERROR_RATE_LIST 0x15
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SINR 0x14
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_IO 0x13
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ECIO_LIST 0x12
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSSI_LIST 0x11
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_STRENGTH_LIST 0x10
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SIGNAL_STRENGTH 0x01

gboolean
qmi_message_nas_get_signal_strength_output_get_lte_rsrp (
    QmiMessageNasGetSignalStrengthOutput *self,
    gint16 *value_lte_rsrp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_rsrp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE RSRP' was not found in the message");
        return FALSE;
    }

    if (value_lte_rsrp)
        *value_lte_rsrp = self->arg_lte_rsrp;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_strength_output_get_lte_snr (
    QmiMessageNasGetSignalStrengthOutput *self,
    gint16 *value_lte_snr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_snr_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE SNR' was not found in the message");
        return FALSE;
    }

    if (value_lte_snr)
        *value_lte_snr = self->arg_lte_snr;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_strength_output_get_rsrq (
    QmiMessageNasGetSignalStrengthOutput *self,
    gint8 *value_rsrq_rsrq,
    QmiNasRadioInterface *value_rsrq_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rsrq_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSRQ' was not found in the message");
        return FALSE;
    }

    if (value_rsrq_rsrq)
        *value_rsrq_rsrq = self->arg_rsrq_rsrq;
    if (value_rsrq_radio_interface)
        *value_rsrq_radio_interface = (QmiNasRadioInterface)(self->arg_rsrq_radio_interface);

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_strength_output_get_error_rate_list (
    QmiMessageNasGetSignalStrengthOutput *self,
    GArray **value_error_rate_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_error_rate_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Error Rate List' was not found in the message");
        return FALSE;
    }

    if (value_error_rate_list)
        *value_error_rate_list = self->arg_error_rate_list;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_strength_output_get_sinr (
    QmiMessageNasGetSignalStrengthOutput *self,
    QmiNasEvdoSinrLevel *value_sinr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sinr_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SINR' was not found in the message");
        return FALSE;
    }

    if (value_sinr)
        *value_sinr = (QmiNasEvdoSinrLevel)(self->arg_sinr);

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_strength_output_get_io (
    QmiMessageNasGetSignalStrengthOutput *self,
    gint32 *value_io,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_io_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'IO' was not found in the message");
        return FALSE;
    }

    if (value_io)
        *value_io = self->arg_io;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_strength_output_get_ecio_list (
    QmiMessageNasGetSignalStrengthOutput *self,
    GArray **value_ecio_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ecio_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ECIO List' was not found in the message");
        return FALSE;
    }

    if (value_ecio_list)
        *value_ecio_list = self->arg_ecio_list;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_strength_output_get_rssi_list (
    QmiMessageNasGetSignalStrengthOutput *self,
    GArray **value_rssi_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rssi_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSSI List' was not found in the message");
        return FALSE;
    }

    if (value_rssi_list)
        *value_rssi_list = self->arg_rssi_list;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_strength_output_get_strength_list (
    QmiMessageNasGetSignalStrengthOutput *self,
    GArray **value_strength_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_strength_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Strength List' was not found in the message");
        return FALSE;
    }

    if (value_strength_list)
        *value_strength_list = self->arg_strength_list;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_strength_output_get_result (
    QmiMessageNasGetSignalStrengthOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_get_signal_strength_output_get_signal_strength (
    QmiMessageNasGetSignalStrengthOutput *self,
    gint8 *value_signal_strength_strength,
    QmiNasRadioInterface *value_signal_strength_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_signal_strength_strength)
        *value_signal_strength_strength = self->arg_signal_strength_strength;
    if (value_signal_strength_radio_interface)
        *value_signal_strength_radio_interface = (QmiNasRadioInterface)(self->arg_signal_strength_radio_interface);

    return TRUE;
}

GType
qmi_message_nas_get_signal_strength_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetSignalStrengthOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_signal_strength_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_signal_strength_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetSignalStrengthOutput *
qmi_message_nas_get_signal_strength_output_ref (QmiMessageNasGetSignalStrengthOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_signal_strength_output_unref (QmiMessageNasGetSignalStrengthOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_error_rate_list)
            g_array_unref (self->arg_error_rate_list);
        if (self->arg_ecio_list)
            g_array_unref (self->arg_ecio_list);
        if (self->arg_rssi_list)
            g_array_unref (self->arg_rssi_list);
        if (self->arg_strength_list)
            g_array_unref (self->arg_strength_list);
        g_slice_free (QmiMessageNasGetSignalStrengthOutput, self);
    }
}

static gchar *
qmi_message_nas_get_signal_strength_input_request_mask_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_INPUT_TLV_REQUEST_MASK, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SIGNAL_STRENGTH_REQUEST_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_signal_strength_request_get_string ((QmiNasSignalStrengthRequest)tmp));
#elif defined  __QMI_NAS_SIGNAL_STRENGTH_REQUEST_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_signal_strength_request_build_string_from_mask ((QmiNasSignalStrengthRequest)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasSignalStrengthRequest
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_strength_output_lte_rsrp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_RSRP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_strength_output_lte_snr_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_SNR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_strength_output_rsrq_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSRQ, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rsrq = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " radio_interface = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_strength_output_error_rate_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ERROR_RATE_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint error_rate_list_i;
        guint16 error_rate_list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(error_rate_list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (error_rate_list_i = 0; error_rate_list_i < error_rate_list_n_items; error_rate_list_i++) {
            g_string_append_printf (printable, " [%u] = '", error_rate_list_i);
            g_string_append (printable, "[");
            g_string_append (printable, " rate = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " radio_interface = '");

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_strength_output_sinr_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SINR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_evdo_sinr_level_get_string ((QmiNasEvdoSinrLevel)tmp));
#elif defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_evdo_sinr_level_build_string_from_mask ((QmiNasEvdoSinrLevel)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasEvdoSinrLevel
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_strength_output_io_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_IO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_strength_output_ecio_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ECIO_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint ecio_list_i;
        guint16 ecio_list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(ecio_list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (ecio_list_i = 0; ecio_list_i < ecio_list_n_items; ecio_list_i++) {
            g_string_append_printf (printable, " [%u] = '", ecio_list_i);
            g_string_append (printable, "[");
            g_string_append (printable, " ecio = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " radio_interface = '");

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_strength_output_rssi_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSSI_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint rssi_list_i;
        guint16 rssi_list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(rssi_list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (rssi_list_i = 0; rssi_list_i < rssi_list_n_items; rssi_list_i++) {
            g_string_append_printf (printable, " [%u] = '", rssi_list_i);
            g_string_append (printable, "[");
            g_string_append (printable, " rssi = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " radio_interface = '");

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_strength_output_strength_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_STRENGTH_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint strength_list_i;
        guint16 strength_list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(strength_list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (strength_list_i = 0; strength_list_i < strength_list_n_items; strength_list_i++) {
            g_string_append_printf (printable, " [%u] = '", strength_list_i);
            g_string_append (printable, "[");
            g_string_append (printable, " strength = '");

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%d", (gint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " radio_interface = '");

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_strength_output_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " strength = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " radio_interface = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_signal_strength_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_signal_strength_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_signal_strength_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_INPUT_TLV_REQUEST_MASK:
            tlv_type_str = "Request Mask";
            translated_value = qmi_message_nas_get_signal_strength_input_request_mask_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_RSRP:
            tlv_type_str = "LTE RSRP";
            translated_value = qmi_message_nas_get_signal_strength_output_lte_rsrp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_SNR:
            tlv_type_str = "LTE SNR";
            translated_value = qmi_message_nas_get_signal_strength_output_lte_snr_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSRQ:
            tlv_type_str = "RSRQ";
            translated_value = qmi_message_nas_get_signal_strength_output_rsrq_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ERROR_RATE_LIST:
            tlv_type_str = "Error Rate List";
            translated_value = qmi_message_nas_get_signal_strength_output_error_rate_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SINR:
            tlv_type_str = "SINR";
            translated_value = qmi_message_nas_get_signal_strength_output_sinr_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_IO:
            tlv_type_str = "IO";
            translated_value = qmi_message_nas_get_signal_strength_output_io_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ECIO_LIST:
            tlv_type_str = "ECIO List";
            translated_value = qmi_message_nas_get_signal_strength_output_ecio_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSSI_LIST:
            tlv_type_str = "RSSI List";
            translated_value = qmi_message_nas_get_signal_strength_output_rssi_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_STRENGTH_LIST:
            tlv_type_str = "Strength List";
            translated_value = qmi_message_nas_get_signal_strength_output_strength_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SIGNAL_STRENGTH:
            tlv_type_str = "Signal Strength";
            translated_value = qmi_message_nas_get_signal_strength_output_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_signal_strength_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Signal Strength\" (0x0020)\n",
                            line_prefix);

    {
        struct message_get_signal_strength_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_signal_strength_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetSignalStrengthOutput *
__qmi_message_nas_get_signal_strength_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetSignalStrengthOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH);

    self = g_slice_new0 (QmiMessageNasGetSignalStrengthOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_RSRP, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_strength_output_lte_rsrp_out;
            }
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_rsrp), NULL))
                goto qmi_message_nas_get_signal_strength_output_lte_rsrp_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE RSRP' TLV", offset);
            }

            self->arg_lte_rsrp_set = TRUE;

qmi_message_nas_get_signal_strength_output_lte_rsrp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_SNR, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_strength_output_lte_snr_out;
            }
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_snr), NULL))
                goto qmi_message_nas_get_signal_strength_output_lte_snr_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE SNR' TLV", offset);
            }

            self->arg_lte_snr_set = TRUE;

qmi_message_nas_get_signal_strength_output_lte_snr_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSRQ, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_strength_output_rsrq_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_rsrq_rsrq), NULL))
                goto qmi_message_nas_get_signal_strength_output_rsrq_out;
            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_signal_strength_output_rsrq_out;
                self->arg_rsrq_radio_interface = (QmiNasRadioInterface)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'RSRQ' TLV", offset);
            }

            self->arg_rsrq_set = TRUE;

qmi_message_nas_get_signal_strength_output_rsrq_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ERROR_RATE_LIST, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_strength_output_error_rate_list_out;
            }
            {
                guint error_rate_list_i;
                guint16 error_rate_list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(error_rate_list_n_items), NULL))
                    goto qmi_message_nas_get_signal_strength_output_error_rate_list_out;

                self->arg_error_rate_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetSignalStrengthOutputErrorRateListElement),
                    (guint)error_rate_list_n_items);

                for (error_rate_list_i = 0; error_rate_list_i < error_rate_list_n_items; error_rate_list_i++) {
                    QmiMessageNasGetSignalStrengthOutputErrorRateListElement error_rate_list_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(error_rate_list_aux.rate), NULL))
                        goto qmi_message_nas_get_signal_strength_output_error_rate_list_out;
                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_signal_strength_output_error_rate_list_out;
                        error_rate_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                    }
                    g_array_insert_val (self->arg_error_rate_list, error_rate_list_i, error_rate_list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Error Rate List' TLV", offset);
            }

            self->arg_error_rate_list_set = TRUE;

qmi_message_nas_get_signal_strength_output_error_rate_list_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SINR, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_strength_output_sinr_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_signal_strength_output_sinr_out;
                self->arg_sinr = (QmiNasEvdoSinrLevel)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'SINR' TLV", offset);
            }

            self->arg_sinr_set = TRUE;

qmi_message_nas_get_signal_strength_output_sinr_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_IO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_strength_output_io_out;
            }
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_io), NULL))
                goto qmi_message_nas_get_signal_strength_output_io_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'IO' TLV", offset);
            }

            self->arg_io_set = TRUE;

qmi_message_nas_get_signal_strength_output_io_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ECIO_LIST, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_strength_output_ecio_list_out;
            }
            {
                guint ecio_list_i;
                guint16 ecio_list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(ecio_list_n_items), NULL))
                    goto qmi_message_nas_get_signal_strength_output_ecio_list_out;

                self->arg_ecio_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetSignalStrengthOutputEcioListElement),
                    (guint)ecio_list_n_items);

                for (ecio_list_i = 0; ecio_list_i < ecio_list_n_items; ecio_list_i++) {
                    QmiMessageNasGetSignalStrengthOutputEcioListElement ecio_list_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(ecio_list_aux.ecio), NULL))
                        goto qmi_message_nas_get_signal_strength_output_ecio_list_out;
                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_signal_strength_output_ecio_list_out;
                        ecio_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                    }
                    g_array_insert_val (self->arg_ecio_list, ecio_list_i, ecio_list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'ECIO List' TLV", offset);
            }

            self->arg_ecio_list_set = TRUE;

qmi_message_nas_get_signal_strength_output_ecio_list_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSSI_LIST, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_strength_output_rssi_list_out;
            }
            {
                guint rssi_list_i;
                guint16 rssi_list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(rssi_list_n_items), NULL))
                    goto qmi_message_nas_get_signal_strength_output_rssi_list_out;

                self->arg_rssi_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetSignalStrengthOutputRssiListElement),
                    (guint)rssi_list_n_items);

                for (rssi_list_i = 0; rssi_list_i < rssi_list_n_items; rssi_list_i++) {
                    QmiMessageNasGetSignalStrengthOutputRssiListElement rssi_list_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(rssi_list_aux.rssi), NULL))
                        goto qmi_message_nas_get_signal_strength_output_rssi_list_out;
                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_signal_strength_output_rssi_list_out;
                        rssi_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                    }
                    g_array_insert_val (self->arg_rssi_list, rssi_list_i, rssi_list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'RSSI List' TLV", offset);
            }

            self->arg_rssi_list_set = TRUE;

qmi_message_nas_get_signal_strength_output_rssi_list_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_STRENGTH_LIST, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_strength_output_strength_list_out;
            }
            {
                guint strength_list_i;
                guint16 strength_list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(strength_list_n_items), NULL))
                    goto qmi_message_nas_get_signal_strength_output_strength_list_out;

                self->arg_strength_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetSignalStrengthOutputStrengthListElement),
                    (guint)strength_list_n_items);

                for (strength_list_i = 0; strength_list_i < strength_list_n_items; strength_list_i++) {
                    QmiMessageNasGetSignalStrengthOutputStrengthListElement strength_list_aux;

                    if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(strength_list_aux.strength), NULL))
                        goto qmi_message_nas_get_signal_strength_output_strength_list_out;
                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_signal_strength_output_strength_list_out;
                        strength_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                    }
                    g_array_insert_val (self->arg_strength_list, strength_list_i, strength_list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Strength List' TLV", offset);
            }

            self->arg_strength_list_set = TRUE;

qmi_message_nas_get_signal_strength_output_strength_list_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_signal_strength_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_signal_strength_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SIGNAL_STRENGTH, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Signal Strength TLV: ");
                qmi_message_nas_get_signal_strength_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_signal_strength_strength), error))
                goto qmi_message_nas_get_signal_strength_output_signal_strength_out;
            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_message_nas_get_signal_strength_output_signal_strength_out;
                self->arg_signal_strength_radio_interface = (QmiNasRadioInterface)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Signal Strength' TLV", offset);
            }

            self->arg_signal_strength_set = TRUE;

qmi_message_nas_get_signal_strength_output_signal_strength_out:
            if (!self->arg_signal_strength_set) {
                qmi_message_nas_get_signal_strength_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Network Scan */


/* --- Input -- */

struct _QmiMessageNasNetworkScanInput {
    volatile gint ref_count;

    /* Network Type */
    gboolean arg_network_type_set;
    guint8 arg_network_type;
};

#define QMI_MESSAGE_NAS_NETWORK_SCAN_INPUT_TLV_NETWORK_TYPE 0x10

gboolean
qmi_message_nas_network_scan_input_get_network_type (
    QmiMessageNasNetworkScanInput *self,
    QmiNasNetworkScanType *value_network_type,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_type_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Type' was not found in the message");
        return FALSE;
    }

    if (value_network_type)
        *value_network_type = (QmiNasNetworkScanType)(self->arg_network_type);

    return TRUE;
}

gboolean
qmi_message_nas_network_scan_input_set_network_type (
    QmiMessageNasNetworkScanInput *self,
    QmiNasNetworkScanType value_network_type,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_network_type = (guint8)(value_network_type);
    self->arg_network_type_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_network_scan_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasNetworkScanInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_network_scan_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_network_scan_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasNetworkScanInput *
qmi_message_nas_network_scan_input_ref (QmiMessageNasNetworkScanInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_network_scan_input_unref (QmiMessageNasNetworkScanInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasNetworkScanInput, self);
    }
}

QmiMessageNasNetworkScanInput *
qmi_message_nas_network_scan_input_new (void)
{
    QmiMessageNasNetworkScanInput *self;

    self = g_slice_new0 (QmiMessageNasNetworkScanInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_network_scan_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasNetworkScanInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_NETWORK_SCAN);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return g_steal_pointer (&self);

    /* Try to add the 'Network Type' TLV */
    if (input->arg_network_type_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_NETWORK_SCAN_INPUT_TLV_NETWORK_TYPE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Network Type': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_network_type;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Network Type': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Network Type': ");
            return NULL;
        }
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

static void
network_information_qmimessagenasnetworkscanoutputnetworkinformationelement_clear (QmiMessageNasNetworkScanOutputNetworkInformationElement *p)
{
    g_free ((*p).description);
}

struct _QmiMessageNasNetworkScanOutput {
    volatile gint ref_count;

    /* Network Scan Result */
    gboolean arg_network_scan_result_set;
    guint32 arg_network_scan_result;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    GArray *arg_mnc_pcs_digit_include_status;

    /* Radio Access Technology */
    gboolean arg_radio_access_technology_set;
    GArray *arg_radio_access_technology;

    /* Network Information */
    gboolean arg_network_information_set;
    GArray *arg_network_information;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_SCAN_RESULT 0x13
#define QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x12
#define QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RADIO_ACCESS_TECHNOLOGY 0x11
#define QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_INFORMATION 0x10
#define QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_network_scan_output_get_network_scan_result (
    QmiMessageNasNetworkScanOutput *self,
    QmiNasNetworkScanResult *value_network_scan_result,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_scan_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Scan Result' was not found in the message");
        return FALSE;
    }

    if (value_network_scan_result)
        *value_network_scan_result = (QmiNasNetworkScanResult)(self->arg_network_scan_result);

    return TRUE;
}

gboolean
qmi_message_nas_network_scan_output_get_mnc_pcs_digit_include_status (
    QmiMessageNasNetworkScanOutput *self,
    GArray **value_mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (value_mnc_pcs_digit_include_status)
        *value_mnc_pcs_digit_include_status = self->arg_mnc_pcs_digit_include_status;

    return TRUE;
}

gboolean
qmi_message_nas_network_scan_output_get_radio_access_technology (
    QmiMessageNasNetworkScanOutput *self,
    GArray **value_radio_access_technology,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_radio_access_technology_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Radio Access Technology' was not found in the message");
        return FALSE;
    }

    if (value_radio_access_technology)
        *value_radio_access_technology = self->arg_radio_access_technology;

    return TRUE;
}

gboolean
qmi_message_nas_network_scan_output_get_network_information (
    QmiMessageNasNetworkScanOutput *self,
    GArray **value_network_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Information' was not found in the message");
        return FALSE;
    }

    if (value_network_information)
        *value_network_information = self->arg_network_information;

    return TRUE;
}

gboolean
qmi_message_nas_network_scan_output_get_result (
    QmiMessageNasNetworkScanOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_network_scan_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasNetworkScanOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_network_scan_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_network_scan_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasNetworkScanOutput *
qmi_message_nas_network_scan_output_ref (QmiMessageNasNetworkScanOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_network_scan_output_unref (QmiMessageNasNetworkScanOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_mnc_pcs_digit_include_status)
            g_array_unref (self->arg_mnc_pcs_digit_include_status);
        if (self->arg_radio_access_technology)
            g_array_unref (self->arg_radio_access_technology);
        if (self->arg_network_information)
            g_array_unref (self->arg_network_information);
        g_slice_free (QmiMessageNasNetworkScanOutput, self);
    }
}

static gchar *
qmi_message_nas_network_scan_input_network_type_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_NETWORK_SCAN_INPUT_TLV_NETWORK_TYPE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SCAN_TYPE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_scan_type_get_string ((QmiNasNetworkScanType)tmp));
#elif defined  __QMI_NAS_NETWORK_SCAN_TYPE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_scan_type_build_string_from_mask ((QmiNasNetworkScanType)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkScanType
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_network_scan_output_network_scan_result_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_SCAN_RESULT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SCAN_RESULT_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_scan_result_get_string ((QmiNasNetworkScanResult)tmp));
#elif defined  __QMI_NAS_NETWORK_SCAN_RESULT_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_scan_result_build_string_from_mask ((QmiNasNetworkScanResult)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkScanResult
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint mnc_pcs_digit_include_status_i;
        guint16 mnc_pcs_digit_include_status_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(mnc_pcs_digit_include_status_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (mnc_pcs_digit_include_status_i = 0; mnc_pcs_digit_include_status_i < mnc_pcs_digit_include_status_n_items; mnc_pcs_digit_include_status_i++) {
            g_string_append_printf (printable, " [%u] = '", mnc_pcs_digit_include_status_i);
            g_string_append (printable, "[");
            g_string_append (printable, " mcc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " mnc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " includes_pcs_digit = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_network_scan_output_radio_access_technology_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RADIO_ACCESS_TECHNOLOGY, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint radio_access_technology_i;
        guint16 radio_access_technology_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(radio_access_technology_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (radio_access_technology_i = 0; radio_access_technology_i < radio_access_technology_n_items; radio_access_technology_i++) {
            g_string_append_printf (printable, " [%u] = '", radio_access_technology_i);
            g_string_append (printable, "[");
            g_string_append (printable, " mcc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " mnc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " radio_interface = '");

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_network_scan_output_network_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint network_information_i;
        guint16 network_information_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(network_information_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (network_information_i = 0; network_information_i < network_information_n_items; network_information_i++) {
            g_string_append_printf (printable, " [%u] = '", network_information_i);
            g_string_append (printable, "[");
            g_string_append (printable, " mcc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " mnc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " network_status = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_NETWORK_STATUS_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_network_status_get_string ((QmiNasNetworkStatus)tmp));
#elif defined  __QMI_NAS_NETWORK_STATUS_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_network_status_build_string_from_mask ((QmiNasNetworkStatus)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasNetworkStatus
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " description = '");

            {
                g_autofree gchar *tmp = NULL;

                if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &tmp, &error))
                    goto out;
                g_string_append (printable, tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_network_scan_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_network_scan_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_network_scan_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_NETWORK_SCAN_INPUT_TLV_NETWORK_TYPE:
            tlv_type_str = "Network Type";
            translated_value = qmi_message_nas_network_scan_input_network_type_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_SCAN_RESULT:
            tlv_type_str = "Network Scan Result";
            translated_value = qmi_message_nas_network_scan_output_network_scan_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RADIO_ACCESS_TECHNOLOGY:
            tlv_type_str = "Radio Access Technology";
            translated_value = qmi_message_nas_network_scan_output_radio_access_technology_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_INFORMATION:
            tlv_type_str = "Network Information";
            translated_value = qmi_message_nas_network_scan_output_network_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_network_scan_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Network Scan\" (0x0021)\n",
                            line_prefix);

    {
        struct message_network_scan_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_network_scan_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasNetworkScanOutput *
__qmi_message_nas_network_scan_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasNetworkScanOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_NETWORK_SCAN);

    self = g_slice_new0 (QmiMessageNasNetworkScanOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_SCAN_RESULT, NULL, NULL)) == 0) {
                goto qmi_message_nas_network_scan_output_network_scan_result_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_network_scan_output_network_scan_result_out;
                self->arg_network_scan_result = (QmiNasNetworkScanResult)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Network Scan Result' TLV", offset);
            }

            self->arg_network_scan_result_set = TRUE;

qmi_message_nas_network_scan_output_network_scan_result_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_out;
            }
            {
                guint mnc_pcs_digit_include_status_i;
                guint16 mnc_pcs_digit_include_status_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(mnc_pcs_digit_include_status_n_items), NULL))
                    goto qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_out;

                self->arg_mnc_pcs_digit_include_status = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement),
                    (guint)mnc_pcs_digit_include_status_n_items);

                for (mnc_pcs_digit_include_status_i = 0; mnc_pcs_digit_include_status_i < mnc_pcs_digit_include_status_n_items; mnc_pcs_digit_include_status_i++) {
                    QmiMessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement mnc_pcs_digit_include_status_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(mnc_pcs_digit_include_status_aux.mcc), NULL))
                        goto qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(mnc_pcs_digit_include_status_aux.mnc), NULL))
                        goto qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_out;
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_out;
                        mnc_pcs_digit_include_status_aux.includes_pcs_digit = (gboolean)tmp;
                    }
                    g_array_insert_val (self->arg_mnc_pcs_digit_include_status, mnc_pcs_digit_include_status_i, mnc_pcs_digit_include_status_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'MNC PCS Digit Include Status' TLV", offset);
            }

            self->arg_mnc_pcs_digit_include_status_set = TRUE;

qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RADIO_ACCESS_TECHNOLOGY, NULL, NULL)) == 0) {
                goto qmi_message_nas_network_scan_output_radio_access_technology_out;
            }
            {
                guint radio_access_technology_i;
                guint16 radio_access_technology_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(radio_access_technology_n_items), NULL))
                    goto qmi_message_nas_network_scan_output_radio_access_technology_out;

                self->arg_radio_access_technology = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasNetworkScanOutputRadioAccessTechnologyElement),
                    (guint)radio_access_technology_n_items);

                for (radio_access_technology_i = 0; radio_access_technology_i < radio_access_technology_n_items; radio_access_technology_i++) {
                    QmiMessageNasNetworkScanOutputRadioAccessTechnologyElement radio_access_technology_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(radio_access_technology_aux.mcc), NULL))
                        goto qmi_message_nas_network_scan_output_radio_access_technology_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(radio_access_technology_aux.mnc), NULL))
                        goto qmi_message_nas_network_scan_output_radio_access_technology_out;
                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_network_scan_output_radio_access_technology_out;
                        radio_access_technology_aux.radio_interface = (QmiNasRadioInterface)tmp;
                    }
                    g_array_insert_val (self->arg_radio_access_technology, radio_access_technology_i, radio_access_technology_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Radio Access Technology' TLV", offset);
            }

            self->arg_radio_access_technology_set = TRUE;

qmi_message_nas_network_scan_output_radio_access_technology_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_INFORMATION, NULL, NULL)) == 0) {
                goto qmi_message_nas_network_scan_output_network_information_out;
            }
            {
                guint network_information_i;
                guint16 network_information_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(network_information_n_items), NULL))
                    goto qmi_message_nas_network_scan_output_network_information_out;

                self->arg_network_information = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasNetworkScanOutputNetworkInformationElement),
                    (guint)network_information_n_items);

                g_array_set_clear_func (self->arg_network_information,
                                        (GDestroyNotify)network_information_qmimessagenasnetworkscanoutputnetworkinformationelement_clear);

                for (network_information_i = 0; network_information_i < network_information_n_items; network_information_i++) {
                    QmiMessageNasNetworkScanOutputNetworkInformationElement network_information_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(network_information_aux.mcc), NULL))
                        goto qmi_message_nas_network_scan_output_network_information_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(network_information_aux.mnc), NULL))
                        goto qmi_message_nas_network_scan_output_network_information_out;
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_network_scan_output_network_information_out;
                        network_information_aux.network_status = (QmiNasNetworkStatus)tmp;
                    }
                    if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &(network_information_aux.description), NULL))
                        goto qmi_message_nas_network_scan_output_network_information_out;
                    g_array_insert_val (self->arg_network_information, network_information_i, network_information_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Network Information' TLV", offset);
            }

            self->arg_network_information_set = TRUE;

qmi_message_nas_network_scan_output_network_information_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_network_scan_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_network_scan_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Initiate Network Register */


/* --- Input -- */

struct _QmiMessageNasInitiateNetworkRegisterInput {
    volatile gint ref_count;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    guint8 arg_mnc_pcs_digit_include_status;

    /* Change Duration */
    gboolean arg_change_duration_set;
    guint8 arg_change_duration;

    /* Manual Registration Info 3GPP */
    gboolean arg_manual_registration_info_3gpp_set;
    guint16 arg_manual_registration_info_3gpp_mcc;
    guint16 arg_manual_registration_info_3gpp_mnc;
    gint8 arg_manual_registration_info_3gpp_radio_interface;

    /* Action */
    gboolean arg_action_set;
    guint8 arg_action;
};

#define QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x12
#define QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_CHANGE_DURATION 0x11
#define QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MANUAL_REGISTRATION_INFO_3GPP 0x10
#define QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_ACTION 0x01

gboolean
qmi_message_nas_initiate_network_register_input_get_mnc_pcs_digit_include_status (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    gboolean *value_mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (value_mnc_pcs_digit_include_status)
        *value_mnc_pcs_digit_include_status = (gboolean)(self->arg_mnc_pcs_digit_include_status);

    return TRUE;
}

gboolean
qmi_message_nas_initiate_network_register_input_set_mnc_pcs_digit_include_status (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    gboolean value_mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_mnc_pcs_digit_include_status = (guint8)(value_mnc_pcs_digit_include_status);
    self->arg_mnc_pcs_digit_include_status_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_initiate_network_register_input_get_change_duration (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    QmiNasChangeDuration *value_change_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_change_duration_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Change Duration' was not found in the message");
        return FALSE;
    }

    if (value_change_duration)
        *value_change_duration = (QmiNasChangeDuration)(self->arg_change_duration);

    return TRUE;
}

gboolean
qmi_message_nas_initiate_network_register_input_set_change_duration (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    QmiNasChangeDuration value_change_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_change_duration = (guint8)(value_change_duration);
    self->arg_change_duration_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_initiate_network_register_input_get_manual_registration_info_3gpp (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    guint16 *value_manual_registration_info_3gpp_mcc,
    guint16 *value_manual_registration_info_3gpp_mnc,
    QmiNasRadioInterface *value_manual_registration_info_3gpp_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_manual_registration_info_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Manual Registration Info 3GPP' was not found in the message");
        return FALSE;
    }

    if (value_manual_registration_info_3gpp_mcc)
        *value_manual_registration_info_3gpp_mcc = self->arg_manual_registration_info_3gpp_mcc;
    if (value_manual_registration_info_3gpp_mnc)
        *value_manual_registration_info_3gpp_mnc = self->arg_manual_registration_info_3gpp_mnc;
    if (value_manual_registration_info_3gpp_radio_interface)
        *value_manual_registration_info_3gpp_radio_interface = (QmiNasRadioInterface)(self->arg_manual_registration_info_3gpp_radio_interface);

    return TRUE;
}

gboolean
qmi_message_nas_initiate_network_register_input_set_manual_registration_info_3gpp (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    guint16 value_manual_registration_info_3gpp_mcc,
    guint16 value_manual_registration_info_3gpp_mnc,
    QmiNasRadioInterface value_manual_registration_info_3gpp_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_manual_registration_info_3gpp_mcc = value_manual_registration_info_3gpp_mcc;
    self->arg_manual_registration_info_3gpp_mnc = value_manual_registration_info_3gpp_mnc;
    self->arg_manual_registration_info_3gpp_radio_interface = (gint8)(value_manual_registration_info_3gpp_radio_interface);
    self->arg_manual_registration_info_3gpp_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_initiate_network_register_input_get_action (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    QmiNasNetworkRegisterType *value_action,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_action_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Action' was not found in the message");
        return FALSE;
    }

    if (value_action)
        *value_action = (QmiNasNetworkRegisterType)(self->arg_action);

    return TRUE;
}

gboolean
qmi_message_nas_initiate_network_register_input_set_action (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    QmiNasNetworkRegisterType value_action,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_action = (guint8)(value_action);
    self->arg_action_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_initiate_network_register_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasInitiateNetworkRegisterInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_initiate_network_register_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_initiate_network_register_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasInitiateNetworkRegisterInput *
qmi_message_nas_initiate_network_register_input_ref (QmiMessageNasInitiateNetworkRegisterInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_initiate_network_register_input_unref (QmiMessageNasInitiateNetworkRegisterInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasInitiateNetworkRegisterInput, self);
    }
}

QmiMessageNasInitiateNetworkRegisterInput *
qmi_message_nas_initiate_network_register_input_new (void)
{
    QmiMessageNasInitiateNetworkRegisterInput *self;

    self = g_slice_new0 (QmiMessageNasInitiateNetworkRegisterInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_initiate_network_register_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasInitiateNetworkRegisterInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Initiate Network Register' has mandatory TLVs");
        return NULL;
    }

    /* Try to add the 'MNC PCS Digit Include Status' TLV */
    if (input->arg_mnc_pcs_digit_include_status_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'MNC PCS Digit Include Status': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_mnc_pcs_digit_include_status;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'MNC PCS Digit Include Status': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'MNC PCS Digit Include Status': ");
            return NULL;
        }
    }

    /* Try to add the 'Change Duration' TLV */
    if (input->arg_change_duration_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_CHANGE_DURATION, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Change Duration': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_change_duration;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Change Duration': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Change Duration': ");
            return NULL;
        }
    }

    /* Try to add the 'Manual Registration Info 3GPP' TLV */
    if (input->arg_manual_registration_info_3gpp_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MANUAL_REGISTRATION_INFO_3GPP, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Manual Registration Info 3GPP': ");
            return NULL;
        }

        /* Write the guint16 variable to the buffer */
        if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, input->arg_manual_registration_info_3gpp_mcc, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'Manual Registration Info 3GPP': ");
            return NULL;
        }
        /* Write the guint16 variable to the buffer */
        if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, input->arg_manual_registration_info_3gpp_mnc, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'Manual Registration Info 3GPP': ");
            return NULL;
        }
        {
            gint8 tmp;

            tmp = (gint8) input->arg_manual_registration_info_3gpp_radio_interface;
            /* Write the gint8 variable to the buffer */
            if (!qmi_message_tlv_write_gint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Manual Registration Info 3GPP': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Manual Registration Info 3GPP': ");
            return NULL;
        }
    }

    /* Try to add the 'Action' TLV */
    if (input->arg_action_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_ACTION, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Action': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_action;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Action': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Action': ");
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Action' in message 'Initiate Network Register'");
        return NULL;
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasInitiateNetworkRegisterOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_initiate_network_register_output_get_result (
    QmiMessageNasInitiateNetworkRegisterOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_initiate_network_register_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasInitiateNetworkRegisterOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_initiate_network_register_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_initiate_network_register_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasInitiateNetworkRegisterOutput *
qmi_message_nas_initiate_network_register_output_ref (QmiMessageNasInitiateNetworkRegisterOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_initiate_network_register_output_unref (QmiMessageNasInitiateNetworkRegisterOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasInitiateNetworkRegisterOutput, self);
    }
}

static gchar *
qmi_message_nas_initiate_network_register_input_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_initiate_network_register_input_change_duration_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_CHANGE_DURATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CHANGE_DURATION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_change_duration_get_string ((QmiNasChangeDuration)tmp));
#elif defined  __QMI_NAS_CHANGE_DURATION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_change_duration_build_string_from_mask ((QmiNasChangeDuration)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasChangeDuration
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_initiate_network_register_input_manual_registration_info_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MANUAL_REGISTRATION_INFO_3GPP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " radio_interface = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_initiate_network_register_input_action_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_ACTION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_REGISTER_TYPE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_register_type_get_string ((QmiNasNetworkRegisterType)tmp));
#elif defined  __QMI_NAS_NETWORK_REGISTER_TYPE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_register_type_build_string_from_mask ((QmiNasNetworkRegisterType)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkRegisterType
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_initiate_network_register_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_initiate_network_register_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_initiate_network_register_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_message_nas_initiate_network_register_input_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_CHANGE_DURATION:
            tlv_type_str = "Change Duration";
            translated_value = qmi_message_nas_initiate_network_register_input_change_duration_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MANUAL_REGISTRATION_INFO_3GPP:
            tlv_type_str = "Manual Registration Info 3GPP";
            translated_value = qmi_message_nas_initiate_network_register_input_manual_registration_info_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_ACTION:
            tlv_type_str = "Action";
            translated_value = qmi_message_nas_initiate_network_register_input_action_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_initiate_network_register_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Initiate Network Register\" (0x0022)\n",
                            line_prefix);

    {
        struct message_initiate_network_register_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_initiate_network_register_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasInitiateNetworkRegisterOutput *
__qmi_message_nas_initiate_network_register_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasInitiateNetworkRegisterOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER);

    self = g_slice_new0 (QmiMessageNasInitiateNetworkRegisterOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_initiate_network_register_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_initiate_network_register_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Attach Detach */


/* --- Input -- */

struct _QmiMessageNasAttachDetachInput {
    volatile gint ref_count;

    /* Action */
    gboolean arg_action_set;
    guint8 arg_action;
};

#define QMI_MESSAGE_NAS_ATTACH_DETACH_INPUT_TLV_ACTION 0x10

gboolean
qmi_message_nas_attach_detach_input_get_action (
    QmiMessageNasAttachDetachInput *self,
    QmiNasPsAttachAction *value_action,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_action_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Action' was not found in the message");
        return FALSE;
    }

    if (value_action)
        *value_action = (QmiNasPsAttachAction)(self->arg_action);

    return TRUE;
}

gboolean
qmi_message_nas_attach_detach_input_set_action (
    QmiMessageNasAttachDetachInput *self,
    QmiNasPsAttachAction value_action,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_action = (guint8)(value_action);
    self->arg_action_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_attach_detach_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasAttachDetachInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_attach_detach_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_attach_detach_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasAttachDetachInput *
qmi_message_nas_attach_detach_input_ref (QmiMessageNasAttachDetachInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_attach_detach_input_unref (QmiMessageNasAttachDetachInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasAttachDetachInput, self);
    }
}

QmiMessageNasAttachDetachInput *
qmi_message_nas_attach_detach_input_new (void)
{
    QmiMessageNasAttachDetachInput *self;

    self = g_slice_new0 (QmiMessageNasAttachDetachInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_attach_detach_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasAttachDetachInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_ATTACH_DETACH);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Attach Detach' has mandatory TLVs");
        return NULL;
    }

    /* Try to add the 'Action' TLV */
    if (input->arg_action_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_ATTACH_DETACH_INPUT_TLV_ACTION, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Action': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_action;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Action': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Action': ");
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Action' in message 'Attach Detach'");
        return NULL;
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasAttachDetachOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_ATTACH_DETACH_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_attach_detach_output_get_result (
    QmiMessageNasAttachDetachOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_attach_detach_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasAttachDetachOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_attach_detach_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_attach_detach_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasAttachDetachOutput *
qmi_message_nas_attach_detach_output_ref (QmiMessageNasAttachDetachOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_attach_detach_output_unref (QmiMessageNasAttachDetachOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasAttachDetachOutput, self);
    }
}

static gchar *
qmi_message_nas_attach_detach_input_action_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_ATTACH_DETACH_INPUT_TLV_ACTION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PS_ATTACH_ACTION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_ps_attach_action_get_string ((QmiNasPsAttachAction)tmp));
#elif defined  __QMI_NAS_PS_ATTACH_ACTION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_ps_attach_action_build_string_from_mask ((QmiNasPsAttachAction)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPsAttachAction
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_attach_detach_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_attach_detach_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_attach_detach_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_ATTACH_DETACH_INPUT_TLV_ACTION:
            tlv_type_str = "Action";
            translated_value = qmi_message_nas_attach_detach_input_action_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_ATTACH_DETACH_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_attach_detach_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Attach Detach\" (0x0023)\n",
                            line_prefix);

    {
        struct message_attach_detach_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_attach_detach_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasAttachDetachOutput *
__qmi_message_nas_attach_detach_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasAttachDetachOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_ATTACH_DETACH);

    self = g_slice_new0 (QmiMessageNasAttachDetachOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_ATTACH_DETACH_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_attach_detach_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_attach_detach_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Serving System */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_serving_system_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_SERVING_SYSTEM);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetServingSystemOutput {
    volatile gint ref_count;

    /* Network Name Source */
    gboolean arg_network_name_source_set;
    guint32 arg_network_name_source;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    guint16 arg_mnc_pcs_digit_include_status_mcc;
    guint16 arg_mnc_pcs_digit_include_status_mnc;
    guint8 arg_mnc_pcs_digit_include_status_includes_pcs_digit;

    /* UMTS Primary Scrambling Code */
    gboolean arg_umts_primary_scrambling_code_set;
    guint16 arg_umts_primary_scrambling_code;

    /* Call Barring Status */
    gboolean arg_call_barring_status_set;
    gint32 arg_call_barring_status_cs_status;
    gint32 arg_call_barring_status_ps_status;

    /* LTE TAC */
    gboolean arg_lte_tac_set;
    guint16 arg_lte_tac;

    /* HDR Personality */
    gboolean arg_hdr_personality_set;
    guint8 arg_hdr_personality;

    /* CDMA System Info */
    gboolean arg_cdma_system_info_set;
    guint16 arg_cdma_system_info_mcc;
    guint8 arg_cdma_system_info_imsi_11_12;

    /* Detailed Service Status */
    gboolean arg_detailed_service_status_set;
    guint8 arg_detailed_service_status_status;
    guint8 arg_detailed_service_status_capability;
    guint8 arg_detailed_service_status_hdr_status;
    guint8 arg_detailed_service_status_hdr_hybrid;
    guint8 arg_detailed_service_status_forbidden;

    /* DTM Support */
    gboolean arg_dtm_support_set;
    guint8 arg_dtm_support;

    /* PRL Indicator 3GPP2 */
    gboolean arg_prl_indicator_3gpp2_set;
    guint8 arg_prl_indicator_3gpp2;

    /* Concurrent Service Info 3GPP2 */
    gboolean arg_concurrent_service_info_3gpp2_set;
    guint8 arg_concurrent_service_info_3gpp2;

    /* CID 3GPP */
    gboolean arg_cid_3gpp_set;
    guint32 arg_cid_3gpp;

    /* LAC 3GPP */
    gboolean arg_lac_3gpp_set;
    guint16 arg_lac_3gpp;

    /* Daylight Saving Time Adjustment 3GPP */
    gboolean arg_daylight_saving_time_adjustment_3gpp_set;
    guint8 arg_daylight_saving_time_adjustment_3gpp;

    /* Time Zone 3GPP */
    gboolean arg_time_zone_3gpp_set;
    gint8 arg_time_zone_3gpp;

    /* CDMA P Rev */
    gboolean arg_cdma_p_rev_set;
    guint8 arg_cdma_p_rev;

    /* Time Zone 3GPP2 */
    gboolean arg_time_zone_3gpp2_set;
    guint8 arg_time_zone_3gpp2_leap_seconds;
    gint8 arg_time_zone_3gpp2_local_time_offset;
    guint8 arg_time_zone_3gpp2_daylight_saving_time;

    /* Default Roaming Indicator */
    gboolean arg_default_roaming_indicator_set;
    guint8 arg_default_roaming_indicator;

    /* Roaming Indicator List */
    gboolean arg_roaming_indicator_list_set;
    GArray *arg_roaming_indicator_list;

    /* CDMA Base Station Info */
    gboolean arg_cdma_base_station_info_set;
    guint16 arg_cdma_base_station_info_base_station_id;
    gint32 arg_cdma_base_station_info_base_station_latitude;
    gint32 arg_cdma_base_station_info_base_station_longitude;

    /* CDMA System ID */
    gboolean arg_cdma_system_id_set;
    guint16 arg_cdma_system_id_sid;
    guint16 arg_cdma_system_id_nid;

    /* Current PLMN */
    gboolean arg_current_plmn_set;
    guint16 arg_current_plmn_mcc;
    guint16 arg_current_plmn_mnc;
    gchar *arg_current_plmn_description;

    /* Data Service Capability */
    gboolean arg_data_service_capability_set;
    GArray *arg_data_service_capability;

    /* Roaming Indicator */
    gboolean arg_roaming_indicator_set;
    guint8 arg_roaming_indicator;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Serving System */
    gboolean arg_serving_system_set;
    guint8 arg_serving_system_registration_state;
    guint8 arg_serving_system_cs_attach_state;
    guint8 arg_serving_system_ps_attach_state;
    guint8 arg_serving_system_selected_network;
    GArray *arg_serving_system_radio_interfaces;
};

#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_NETWORK_NAME_SOURCE 0x29
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x27
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE 0x26
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS 0x25
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC 0x24
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY 0x23
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO 0x22
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS 0x21
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT 0x20
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2 0x1F
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2 0x1E
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP 0x1D
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP 0x1C
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP 0x1B
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP 0x1A
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV 0x18
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2 0x17
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR 0x16
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST 0x15
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO 0x14
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID 0x13
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN 0x12
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY 0x11
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR 0x10
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM 0x01

gboolean
qmi_message_nas_get_serving_system_output_get_network_name_source (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasNetworkNameSource *value_network_name_source,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_name_source_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Name Source' was not found in the message");
        return FALSE;
    }

    if (value_network_name_source)
        *value_network_name_source = (QmiNasNetworkNameSource)(self->arg_network_name_source);

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_mnc_pcs_digit_include_status (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *value_mnc_pcs_digit_include_status_mcc,
    guint16 *value_mnc_pcs_digit_include_status_mnc,
    gboolean *value_mnc_pcs_digit_include_status_includes_pcs_digit,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (value_mnc_pcs_digit_include_status_mcc)
        *value_mnc_pcs_digit_include_status_mcc = self->arg_mnc_pcs_digit_include_status_mcc;
    if (value_mnc_pcs_digit_include_status_mnc)
        *value_mnc_pcs_digit_include_status_mnc = self->arg_mnc_pcs_digit_include_status_mnc;
    if (value_mnc_pcs_digit_include_status_includes_pcs_digit)
        *value_mnc_pcs_digit_include_status_includes_pcs_digit = (gboolean)(self->arg_mnc_pcs_digit_include_status_includes_pcs_digit);

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_umts_primary_scrambling_code (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *value_umts_primary_scrambling_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_umts_primary_scrambling_code_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'UMTS Primary Scrambling Code' was not found in the message");
        return FALSE;
    }

    if (value_umts_primary_scrambling_code)
        *value_umts_primary_scrambling_code = self->arg_umts_primary_scrambling_code;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_call_barring_status (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasCallBarringStatus *value_call_barring_status_cs_status,
    QmiNasCallBarringStatus *value_call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (value_call_barring_status_cs_status)
        *value_call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_call_barring_status_cs_status);
    if (value_call_barring_status_ps_status)
        *value_call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_call_barring_status_ps_status);

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_lte_tac (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *value_lte_tac,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_tac_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE TAC' was not found in the message");
        return FALSE;
    }

    if (value_lte_tac)
        *value_lte_tac = self->arg_lte_tac;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_hdr_personality (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasHdrPersonality *value_hdr_personality,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_personality_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Personality' was not found in the message");
        return FALSE;
    }

    if (value_hdr_personality)
        *value_hdr_personality = (QmiNasHdrPersonality)(self->arg_hdr_personality);

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_cdma_system_info (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *value_cdma_system_info_mcc,
    guint8 *value_cdma_system_info_imsi_11_12,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (value_cdma_system_info_mcc)
        *value_cdma_system_info_mcc = self->arg_cdma_system_info_mcc;
    if (value_cdma_system_info_imsi_11_12)
        *value_cdma_system_info_imsi_11_12 = self->arg_cdma_system_info_imsi_11_12;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_detailed_service_status (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasServiceStatus *value_detailed_service_status_status,
    QmiNasNetworkServiceDomain *value_detailed_service_status_capability,
    QmiNasServiceStatus *value_detailed_service_status_hdr_status,
    gboolean *value_detailed_service_status_hdr_hybrid,
    gboolean *value_detailed_service_status_forbidden,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_detailed_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Detailed Service Status' was not found in the message");
        return FALSE;
    }

    if (value_detailed_service_status_status)
        *value_detailed_service_status_status = (QmiNasServiceStatus)(self->arg_detailed_service_status_status);
    if (value_detailed_service_status_capability)
        *value_detailed_service_status_capability = (QmiNasNetworkServiceDomain)(self->arg_detailed_service_status_capability);
    if (value_detailed_service_status_hdr_status)
        *value_detailed_service_status_hdr_status = (QmiNasServiceStatus)(self->arg_detailed_service_status_hdr_status);
    if (value_detailed_service_status_hdr_hybrid)
        *value_detailed_service_status_hdr_hybrid = (gboolean)(self->arg_detailed_service_status_hdr_hybrid);
    if (value_detailed_service_status_forbidden)
        *value_detailed_service_status_forbidden = (gboolean)(self->arg_detailed_service_status_forbidden);

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_dtm_support (
    QmiMessageNasGetServingSystemOutput *self,
    gboolean *value_dtm_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_dtm_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'DTM Support' was not found in the message");
        return FALSE;
    }

    if (value_dtm_support)
        *value_dtm_support = (gboolean)(self->arg_dtm_support);

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_prl_indicator_3gpp2 (
    QmiMessageNasGetServingSystemOutput *self,
    gboolean *value_prl_indicator_3gpp2,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_prl_indicator_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PRL Indicator 3GPP2' was not found in the message");
        return FALSE;
    }

    if (value_prl_indicator_3gpp2)
        *value_prl_indicator_3gpp2 = (gboolean)(self->arg_prl_indicator_3gpp2);

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_concurrent_service_info_3gpp2 (
    QmiMessageNasGetServingSystemOutput *self,
    gboolean *value_concurrent_service_info_3gpp2,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_concurrent_service_info_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Concurrent Service Info 3GPP2' was not found in the message");
        return FALSE;
    }

    if (value_concurrent_service_info_3gpp2)
        *value_concurrent_service_info_3gpp2 = (gboolean)(self->arg_concurrent_service_info_3gpp2);

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_cid_3gpp (
    QmiMessageNasGetServingSystemOutput *self,
    guint32 *value_cid_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cid_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CID 3GPP' was not found in the message");
        return FALSE;
    }

    if (value_cid_3gpp)
        *value_cid_3gpp = self->arg_cid_3gpp;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_lac_3gpp (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *value_lac_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lac_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LAC 3GPP' was not found in the message");
        return FALSE;
    }

    if (value_lac_3gpp)
        *value_lac_3gpp = self->arg_lac_3gpp;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_daylight_saving_time_adjustment_3gpp (
    QmiMessageNasGetServingSystemOutput *self,
    guint8 *value_daylight_saving_time_adjustment_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_daylight_saving_time_adjustment_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Daylight Saving Time Adjustment 3GPP' was not found in the message");
        return FALSE;
    }

    if (value_daylight_saving_time_adjustment_3gpp)
        *value_daylight_saving_time_adjustment_3gpp = self->arg_daylight_saving_time_adjustment_3gpp;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_time_zone_3gpp (
    QmiMessageNasGetServingSystemOutput *self,
    gint8 *value_time_zone_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_time_zone_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Time Zone 3GPP' was not found in the message");
        return FALSE;
    }

    if (value_time_zone_3gpp)
        *value_time_zone_3gpp = self->arg_time_zone_3gpp;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_cdma_p_rev (
    QmiMessageNasGetServingSystemOutput *self,
    guint8 *value_cdma_p_rev,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_p_rev_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA P Rev' was not found in the message");
        return FALSE;
    }

    if (value_cdma_p_rev)
        *value_cdma_p_rev = self->arg_cdma_p_rev;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_time_zone_3gpp2 (
    QmiMessageNasGetServingSystemOutput *self,
    guint8 *value_time_zone_3gpp2_leap_seconds,
    gint8 *value_time_zone_3gpp2_local_time_offset,
    gboolean *value_time_zone_3gpp2_daylight_saving_time,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_time_zone_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Time Zone 3GPP2' was not found in the message");
        return FALSE;
    }

    if (value_time_zone_3gpp2_leap_seconds)
        *value_time_zone_3gpp2_leap_seconds = self->arg_time_zone_3gpp2_leap_seconds;
    if (value_time_zone_3gpp2_local_time_offset)
        *value_time_zone_3gpp2_local_time_offset = self->arg_time_zone_3gpp2_local_time_offset;
    if (value_time_zone_3gpp2_daylight_saving_time)
        *value_time_zone_3gpp2_daylight_saving_time = (gboolean)(self->arg_time_zone_3gpp2_daylight_saving_time);

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_default_roaming_indicator (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasRoamingIndicatorStatus *value_default_roaming_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_default_roaming_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Default Roaming Indicator' was not found in the message");
        return FALSE;
    }

    if (value_default_roaming_indicator)
        *value_default_roaming_indicator = (QmiNasRoamingIndicatorStatus)(self->arg_default_roaming_indicator);

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_roaming_indicator_list (
    QmiMessageNasGetServingSystemOutput *self,
    GArray **value_roaming_indicator_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_indicator_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Indicator List' was not found in the message");
        return FALSE;
    }

    if (value_roaming_indicator_list)
        *value_roaming_indicator_list = self->arg_roaming_indicator_list;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_cdma_base_station_info (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *value_cdma_base_station_info_base_station_id,
    gint32 *value_cdma_base_station_info_base_station_latitude,
    gint32 *value_cdma_base_station_info_base_station_longitude,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_base_station_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Base Station Info' was not found in the message");
        return FALSE;
    }

    if (value_cdma_base_station_info_base_station_id)
        *value_cdma_base_station_info_base_station_id = self->arg_cdma_base_station_info_base_station_id;
    if (value_cdma_base_station_info_base_station_latitude)
        *value_cdma_base_station_info_base_station_latitude = self->arg_cdma_base_station_info_base_station_latitude;
    if (value_cdma_base_station_info_base_station_longitude)
        *value_cdma_base_station_info_base_station_longitude = self->arg_cdma_base_station_info_base_station_longitude;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_cdma_system_id (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *value_cdma_system_id_sid,
    guint16 *value_cdma_system_id_nid,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System ID' was not found in the message");
        return FALSE;
    }

    if (value_cdma_system_id_sid)
        *value_cdma_system_id_sid = self->arg_cdma_system_id_sid;
    if (value_cdma_system_id_nid)
        *value_cdma_system_id_nid = self->arg_cdma_system_id_nid;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_current_plmn (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *value_current_plmn_mcc,
    guint16 *value_current_plmn_mnc,
    const gchar **value_current_plmn_description,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_current_plmn_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Current PLMN' was not found in the message");
        return FALSE;
    }

    if (value_current_plmn_mcc)
        *value_current_plmn_mcc = self->arg_current_plmn_mcc;
    if (value_current_plmn_mnc)
        *value_current_plmn_mnc = self->arg_current_plmn_mnc;
    if (value_current_plmn_description)
        *value_current_plmn_description = self->arg_current_plmn_description;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_data_service_capability (
    QmiMessageNasGetServingSystemOutput *self,
    GArray **value_data_service_capability,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_data_service_capability_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Data Service Capability' was not found in the message");
        return FALSE;
    }

    if (value_data_service_capability)
        *value_data_service_capability = self->arg_data_service_capability;

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_roaming_indicator (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasRoamingIndicatorStatus *value_roaming_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Indicator' was not found in the message");
        return FALSE;
    }

    if (value_roaming_indicator)
        *value_roaming_indicator = (QmiNasRoamingIndicatorStatus)(self->arg_roaming_indicator);

    return TRUE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_result (
    QmiMessageNasGetServingSystemOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_get_serving_system_output_get_serving_system (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasRegistrationState *value_serving_system_registration_state,
    QmiNasAttachState *value_serving_system_cs_attach_state,
    QmiNasAttachState *value_serving_system_ps_attach_state,
    QmiNasNetworkType *value_serving_system_selected_network,
    GArray **value_serving_system_radio_interfaces,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_serving_system_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Serving System' was not found in the message");
        return FALSE;
    }

    if (value_serving_system_registration_state)
        *value_serving_system_registration_state = (QmiNasRegistrationState)(self->arg_serving_system_registration_state);
    if (value_serving_system_cs_attach_state)
        *value_serving_system_cs_attach_state = (QmiNasAttachState)(self->arg_serving_system_cs_attach_state);
    if (value_serving_system_ps_attach_state)
        *value_serving_system_ps_attach_state = (QmiNasAttachState)(self->arg_serving_system_ps_attach_state);
    if (value_serving_system_selected_network)
        *value_serving_system_selected_network = (QmiNasNetworkType)(self->arg_serving_system_selected_network);
    if (value_serving_system_radio_interfaces)
        *value_serving_system_radio_interfaces = self->arg_serving_system_radio_interfaces;

    return TRUE;
}

GType
qmi_message_nas_get_serving_system_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetServingSystemOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_serving_system_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_serving_system_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetServingSystemOutput *
qmi_message_nas_get_serving_system_output_ref (QmiMessageNasGetServingSystemOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_serving_system_output_unref (QmiMessageNasGetServingSystemOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_roaming_indicator_list)
            g_array_unref (self->arg_roaming_indicator_list);
        g_free (self->arg_current_plmn_description);
        if (self->arg_data_service_capability)
            g_array_unref (self->arg_data_service_capability);
        if (self->arg_serving_system_radio_interfaces)
            g_array_unref (self->arg_serving_system_radio_interfaces);
        g_slice_free (QmiMessageNasGetServingSystemOutput, self);
    }
}

static gchar *
qmi_message_nas_get_serving_system_output_network_name_source_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_NETWORK_NAME_SOURCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_NAME_SOURCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_name_source_get_string ((QmiNasNetworkNameSource)tmp));
#elif defined  __QMI_NAS_NETWORK_NAME_SOURCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_name_source_build_string_from_mask ((QmiNasNetworkNameSource)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkNameSource
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " includes_pcs_digit = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_umts_primary_scrambling_code_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " cs_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_lte_tac_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_hdr_personality_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_HDR_PERSONALITY_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_hdr_personality_get_string ((QmiNasHdrPersonality)tmp));
#elif defined  __QMI_NAS_HDR_PERSONALITY_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_hdr_personality_build_string_from_mask ((QmiNasHdrPersonality)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasHdrPersonality
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " imsi_11_12 = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_detailed_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hdr_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hdr_hybrid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_dtm_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_prl_indicator_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_concurrent_service_info_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_cid_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_lac_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_daylight_saving_time_adjustment_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_time_zone_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_cdma_p_rev_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_time_zone_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " leap_seconds = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " local_time_offset = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " daylight_saving_time = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_default_roaming_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_roaming_indicator_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint roaming_indicator_list_i;
        guint8 roaming_indicator_list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(roaming_indicator_list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (roaming_indicator_list_i = 0; roaming_indicator_list_i < roaming_indicator_list_n_items; roaming_indicator_list_i++) {
            g_string_append_printf (printable, " [%u] = '", roaming_indicator_list_i);
            g_string_append (printable, "[");
            g_string_append (printable, " radio_interface = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " roaming_indicator = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_cdma_base_station_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " base_station_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_latitude = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_longitude = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_cdma_system_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " sid = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " nid = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_current_plmn_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " description = '");

    {
        g_autofree gchar *tmp = NULL;

        if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &tmp, &error))
            goto out;
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_data_service_capability_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint data_service_capability_i;
        guint8 data_service_capability_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(data_service_capability_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (data_service_capability_i = 0; data_service_capability_i < data_service_capability_n_items; data_service_capability_i++) {
            g_string_append_printf (printable, " [%u] = '", data_service_capability_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_DATA_CAPABILITY_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_data_capability_get_string ((QmiNasDataCapability)tmp));
#elif defined  __QMI_NAS_DATA_CAPABILITY_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_data_capability_build_string_from_mask ((QmiNasDataCapability)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasDataCapability
#endif
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_roaming_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_serving_system_output_serving_system_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " registration_state = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_REGISTRATION_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_registration_state_get_string ((QmiNasRegistrationState)tmp));
#elif defined  __QMI_NAS_REGISTRATION_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_registration_state_build_string_from_mask ((QmiNasRegistrationState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRegistrationState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cs_attach_state = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ATTACH_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_attach_state_get_string ((QmiNasAttachState)tmp));
#elif defined  __QMI_NAS_ATTACH_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_attach_state_build_string_from_mask ((QmiNasAttachState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasAttachState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_attach_state = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ATTACH_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_attach_state_get_string ((QmiNasAttachState)tmp));
#elif defined  __QMI_NAS_ATTACH_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_attach_state_build_string_from_mask ((QmiNasAttachState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasAttachState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " selected_network = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_TYPE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_type_get_string ((QmiNasNetworkType)tmp));
#elif defined  __QMI_NAS_NETWORK_TYPE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_type_build_string_from_mask ((QmiNasNetworkType)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkType
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " radio_interfaces = '");
    {
        guint radio_interfaces_i;
        guint8 radio_interfaces_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(radio_interfaces_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (radio_interfaces_i = 0; radio_interfaces_i < radio_interfaces_n_items; radio_interfaces_i++) {
            g_string_append_printf (printable, " [%u] = '", radio_interfaces_i);

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_serving_system_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_serving_system_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_serving_system_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_NETWORK_NAME_SOURCE:
            tlv_type_str = "Network Name Source";
            translated_value = qmi_message_nas_get_serving_system_output_network_name_source_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE:
            tlv_type_str = "UMTS Primary Scrambling Code";
            translated_value = qmi_message_nas_get_serving_system_output_umts_primary_scrambling_code_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS:
            tlv_type_str = "Call Barring Status";
            translated_value = qmi_message_nas_get_serving_system_output_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC:
            tlv_type_str = "LTE TAC";
            translated_value = qmi_message_nas_get_serving_system_output_lte_tac_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY:
            tlv_type_str = "HDR Personality";
            translated_value = qmi_message_nas_get_serving_system_output_hdr_personality_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO:
            tlv_type_str = "CDMA System Info";
            translated_value = qmi_message_nas_get_serving_system_output_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS:
            tlv_type_str = "Detailed Service Status";
            translated_value = qmi_message_nas_get_serving_system_output_detailed_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT:
            tlv_type_str = "DTM Support";
            translated_value = qmi_message_nas_get_serving_system_output_dtm_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2:
            tlv_type_str = "PRL Indicator 3GPP2";
            translated_value = qmi_message_nas_get_serving_system_output_prl_indicator_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2:
            tlv_type_str = "Concurrent Service Info 3GPP2";
            translated_value = qmi_message_nas_get_serving_system_output_concurrent_service_info_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP:
            tlv_type_str = "CID 3GPP";
            translated_value = qmi_message_nas_get_serving_system_output_cid_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP:
            tlv_type_str = "LAC 3GPP";
            translated_value = qmi_message_nas_get_serving_system_output_lac_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP:
            tlv_type_str = "Daylight Saving Time Adjustment 3GPP";
            translated_value = qmi_message_nas_get_serving_system_output_daylight_saving_time_adjustment_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP:
            tlv_type_str = "Time Zone 3GPP";
            translated_value = qmi_message_nas_get_serving_system_output_time_zone_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV:
            tlv_type_str = "CDMA P Rev";
            translated_value = qmi_message_nas_get_serving_system_output_cdma_p_rev_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2:
            tlv_type_str = "Time Zone 3GPP2";
            translated_value = qmi_message_nas_get_serving_system_output_time_zone_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR:
            tlv_type_str = "Default Roaming Indicator";
            translated_value = qmi_message_nas_get_serving_system_output_default_roaming_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST:
            tlv_type_str = "Roaming Indicator List";
            translated_value = qmi_message_nas_get_serving_system_output_roaming_indicator_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO:
            tlv_type_str = "CDMA Base Station Info";
            translated_value = qmi_message_nas_get_serving_system_output_cdma_base_station_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID:
            tlv_type_str = "CDMA System ID";
            translated_value = qmi_message_nas_get_serving_system_output_cdma_system_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN:
            tlv_type_str = "Current PLMN";
            translated_value = qmi_message_nas_get_serving_system_output_current_plmn_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY:
            tlv_type_str = "Data Service Capability";
            translated_value = qmi_message_nas_get_serving_system_output_data_service_capability_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR:
            tlv_type_str = "Roaming Indicator";
            translated_value = qmi_message_nas_get_serving_system_output_roaming_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM:
            tlv_type_str = "Serving System";
            translated_value = qmi_message_nas_get_serving_system_output_serving_system_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_serving_system_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Serving System\" (0x0024)\n",
                            line_prefix);

    {
        struct message_get_serving_system_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_serving_system_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetServingSystemOutput *
__qmi_message_nas_get_serving_system_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetServingSystemOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM);

    self = g_slice_new0 (QmiMessageNasGetServingSystemOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_NETWORK_NAME_SOURCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_network_name_source_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_network_name_source_out;
                self->arg_network_name_source = (QmiNasNetworkNameSource)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Network Name Source' TLV", offset);
            }

            self->arg_network_name_source_set = TRUE;

qmi_message_nas_get_serving_system_output_network_name_source_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_mnc_pcs_digit_include_status_mcc), NULL))
                goto qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_mnc_pcs_digit_include_status_mnc), NULL))
                goto qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_out;
                self->arg_mnc_pcs_digit_include_status_includes_pcs_digit = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'MNC PCS Digit Include Status' TLV", offset);
            }

            self->arg_mnc_pcs_digit_include_status_set = TRUE;

qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_umts_primary_scrambling_code_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_umts_primary_scrambling_code), NULL))
                goto qmi_message_nas_get_serving_system_output_umts_primary_scrambling_code_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'UMTS Primary Scrambling Code' TLV", offset);
            }

            self->arg_umts_primary_scrambling_code_set = TRUE;

qmi_message_nas_get_serving_system_output_umts_primary_scrambling_code_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_call_barring_status_out;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_call_barring_status_out;
                self->arg_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_call_barring_status_out;
                self->arg_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Call Barring Status' TLV", offset);
            }

            self->arg_call_barring_status_set = TRUE;

qmi_message_nas_get_serving_system_output_call_barring_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_lte_tac_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_tac), NULL))
                goto qmi_message_nas_get_serving_system_output_lte_tac_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE TAC' TLV", offset);
            }

            self->arg_lte_tac_set = TRUE;

qmi_message_nas_get_serving_system_output_lte_tac_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_hdr_personality_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_hdr_personality_out;
                self->arg_hdr_personality = (QmiNasHdrPersonality)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'HDR Personality' TLV", offset);
            }

            self->arg_hdr_personality_set = TRUE;

qmi_message_nas_get_serving_system_output_hdr_personality_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_cdma_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_mcc), NULL))
                goto qmi_message_nas_get_serving_system_output_cdma_system_info_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_cdma_system_info_imsi_11_12), NULL))
                goto qmi_message_nas_get_serving_system_output_cdma_system_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA System Info' TLV", offset);
            }

            self->arg_cdma_system_info_set = TRUE;

qmi_message_nas_get_serving_system_output_cdma_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_detailed_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_detailed_service_status_out;
                self->arg_detailed_service_status_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_detailed_service_status_out;
                self->arg_detailed_service_status_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_detailed_service_status_out;
                self->arg_detailed_service_status_hdr_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_detailed_service_status_out;
                self->arg_detailed_service_status_hdr_hybrid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_detailed_service_status_out;
                self->arg_detailed_service_status_forbidden = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Detailed Service Status' TLV", offset);
            }

            self->arg_detailed_service_status_set = TRUE;

qmi_message_nas_get_serving_system_output_detailed_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_dtm_support_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_dtm_support_out;
                self->arg_dtm_support = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'DTM Support' TLV", offset);
            }

            self->arg_dtm_support_set = TRUE;

qmi_message_nas_get_serving_system_output_dtm_support_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_prl_indicator_3gpp2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_prl_indicator_3gpp2_out;
                self->arg_prl_indicator_3gpp2 = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'PRL Indicator 3GPP2' TLV", offset);
            }

            self->arg_prl_indicator_3gpp2_set = TRUE;

qmi_message_nas_get_serving_system_output_prl_indicator_3gpp2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_concurrent_service_info_3gpp2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_concurrent_service_info_3gpp2_out;
                self->arg_concurrent_service_info_3gpp2 = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Concurrent Service Info 3GPP2' TLV", offset);
            }

            self->arg_concurrent_service_info_3gpp2_set = TRUE;

qmi_message_nas_get_serving_system_output_concurrent_service_info_3gpp2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_cid_3gpp_out;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cid_3gpp), NULL))
                goto qmi_message_nas_get_serving_system_output_cid_3gpp_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CID 3GPP' TLV", offset);
            }

            self->arg_cid_3gpp_set = TRUE;

qmi_message_nas_get_serving_system_output_cid_3gpp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_lac_3gpp_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lac_3gpp), NULL))
                goto qmi_message_nas_get_serving_system_output_lac_3gpp_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LAC 3GPP' TLV", offset);
            }

            self->arg_lac_3gpp_set = TRUE;

qmi_message_nas_get_serving_system_output_lac_3gpp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_daylight_saving_time_adjustment_3gpp_out;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_daylight_saving_time_adjustment_3gpp), NULL))
                goto qmi_message_nas_get_serving_system_output_daylight_saving_time_adjustment_3gpp_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Daylight Saving Time Adjustment 3GPP' TLV", offset);
            }

            self->arg_daylight_saving_time_adjustment_3gpp_set = TRUE;

qmi_message_nas_get_serving_system_output_daylight_saving_time_adjustment_3gpp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_time_zone_3gpp_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_time_zone_3gpp), NULL))
                goto qmi_message_nas_get_serving_system_output_time_zone_3gpp_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Time Zone 3GPP' TLV", offset);
            }

            self->arg_time_zone_3gpp_set = TRUE;

qmi_message_nas_get_serving_system_output_time_zone_3gpp_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_cdma_p_rev_out;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_cdma_p_rev), NULL))
                goto qmi_message_nas_get_serving_system_output_cdma_p_rev_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA P Rev' TLV", offset);
            }

            self->arg_cdma_p_rev_set = TRUE;

qmi_message_nas_get_serving_system_output_cdma_p_rev_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_time_zone_3gpp2_out;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_time_zone_3gpp2_leap_seconds), NULL))
                goto qmi_message_nas_get_serving_system_output_time_zone_3gpp2_out;
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_time_zone_3gpp2_local_time_offset), NULL))
                goto qmi_message_nas_get_serving_system_output_time_zone_3gpp2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_time_zone_3gpp2_out;
                self->arg_time_zone_3gpp2_daylight_saving_time = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Time Zone 3GPP2' TLV", offset);
            }

            self->arg_time_zone_3gpp2_set = TRUE;

qmi_message_nas_get_serving_system_output_time_zone_3gpp2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_default_roaming_indicator_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_default_roaming_indicator_out;
                self->arg_default_roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Default Roaming Indicator' TLV", offset);
            }

            self->arg_default_roaming_indicator_set = TRUE;

qmi_message_nas_get_serving_system_output_default_roaming_indicator_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_roaming_indicator_list_out;
            }
            {
                guint roaming_indicator_list_i;
                guint8 roaming_indicator_list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(roaming_indicator_list_n_items), NULL))
                    goto qmi_message_nas_get_serving_system_output_roaming_indicator_list_out;

                self->arg_roaming_indicator_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetServingSystemOutputRoamingIndicatorListElement),
                    (guint)roaming_indicator_list_n_items);

                for (roaming_indicator_list_i = 0; roaming_indicator_list_i < roaming_indicator_list_n_items; roaming_indicator_list_i++) {
                    QmiMessageNasGetServingSystemOutputRoamingIndicatorListElement roaming_indicator_list_aux;

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_serving_system_output_roaming_indicator_list_out;
                        roaming_indicator_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                    }
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_serving_system_output_roaming_indicator_list_out;
                        roaming_indicator_list_aux.roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
                    }
                    g_array_insert_val (self->arg_roaming_indicator_list, roaming_indicator_list_i, roaming_indicator_list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Roaming Indicator List' TLV", offset);
            }

            self->arg_roaming_indicator_list_set = TRUE;

qmi_message_nas_get_serving_system_output_roaming_indicator_list_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_cdma_base_station_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_base_station_info_base_station_id), NULL))
                goto qmi_message_nas_get_serving_system_output_cdma_base_station_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_base_station_info_base_station_latitude), NULL))
                goto qmi_message_nas_get_serving_system_output_cdma_base_station_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_base_station_info_base_station_longitude), NULL))
                goto qmi_message_nas_get_serving_system_output_cdma_base_station_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA Base Station Info' TLV", offset);
            }

            self->arg_cdma_base_station_info_set = TRUE;

qmi_message_nas_get_serving_system_output_cdma_base_station_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_cdma_system_id_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_id_sid), NULL))
                goto qmi_message_nas_get_serving_system_output_cdma_system_id_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_id_nid), NULL))
                goto qmi_message_nas_get_serving_system_output_cdma_system_id_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA System ID' TLV", offset);
            }

            self->arg_cdma_system_id_set = TRUE;

qmi_message_nas_get_serving_system_output_cdma_system_id_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_current_plmn_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_current_plmn_mcc), NULL))
                goto qmi_message_nas_get_serving_system_output_current_plmn_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_current_plmn_mnc), NULL))
                goto qmi_message_nas_get_serving_system_output_current_plmn_out;
            if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &(self->arg_current_plmn_description), NULL))
                goto qmi_message_nas_get_serving_system_output_current_plmn_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Current PLMN' TLV", offset);
            }

            self->arg_current_plmn_set = TRUE;

qmi_message_nas_get_serving_system_output_current_plmn_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_data_service_capability_out;
            }
            {
                guint data_service_capability_i;
                guint8 data_service_capability_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(data_service_capability_n_items), NULL))
                    goto qmi_message_nas_get_serving_system_output_data_service_capability_out;

                self->arg_data_service_capability = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiNasDataCapability),
                    (guint)data_service_capability_n_items);

                for (data_service_capability_i = 0; data_service_capability_i < data_service_capability_n_items; data_service_capability_i++) {
                    QmiNasDataCapability data_service_capability_aux;

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_serving_system_output_data_service_capability_out;
                        data_service_capability_aux = (QmiNasDataCapability)tmp;
                    }
                    g_array_insert_val (self->arg_data_service_capability, data_service_capability_i, data_service_capability_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Data Service Capability' TLV", offset);
            }

            self->arg_data_service_capability_set = TRUE;

qmi_message_nas_get_serving_system_output_data_service_capability_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_serving_system_output_roaming_indicator_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_serving_system_output_roaming_indicator_out;
                self->arg_roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Roaming Indicator' TLV", offset);
            }

            self->arg_roaming_indicator_set = TRUE;

qmi_message_nas_get_serving_system_output_roaming_indicator_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_serving_system_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_serving_system_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Serving System TLV: ");
                qmi_message_nas_get_serving_system_output_unref (self);
                return NULL;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_message_nas_get_serving_system_output_serving_system_out;
                self->arg_serving_system_registration_state = (QmiNasRegistrationState)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_message_nas_get_serving_system_output_serving_system_out;
                self->arg_serving_system_cs_attach_state = (QmiNasAttachState)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_message_nas_get_serving_system_output_serving_system_out;
                self->arg_serving_system_ps_attach_state = (QmiNasAttachState)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_message_nas_get_serving_system_output_serving_system_out;
                self->arg_serving_system_selected_network = (QmiNasNetworkType)tmp;
            }
            {
                guint radio_interfaces_i;
                guint8 radio_interfaces_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(radio_interfaces_n_items), error))
                    goto qmi_message_nas_get_serving_system_output_serving_system_out;

                self->arg_serving_system_radio_interfaces = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiNasRadioInterface),
                    (guint)radio_interfaces_n_items);

                for (radio_interfaces_i = 0; radio_interfaces_i < radio_interfaces_n_items; radio_interfaces_i++) {
                    QmiNasRadioInterface radio_interfaces_aux;

                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, error))
                            goto qmi_message_nas_get_serving_system_output_serving_system_out;
                        radio_interfaces_aux = (QmiNasRadioInterface)tmp;
                    }
                    g_array_insert_val (self->arg_serving_system_radio_interfaces, radio_interfaces_i, radio_interfaces_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Serving System' TLV", offset);
            }

            self->arg_serving_system_set = TRUE;

qmi_message_nas_get_serving_system_output_serving_system_out:
            if (!self->arg_serving_system_set) {
                qmi_message_nas_get_serving_system_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Home Network */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_home_network_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_HOME_NETWORK);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetHomeNetworkOutput {
    volatile gint ref_count;

    /* Network Name Source */
    gboolean arg_network_name_source_set;
    guint32 arg_network_name_source;

    /* Home Network 3GPP MNC */
    gboolean arg_home_network_3gpp_mnc_set;
    guint8 arg_home_network_3gpp_mnc_is_3gpp;
    guint8 arg_home_network_3gpp_mnc_includes_pcs_digit;

    /* Home Network 3GPP2 Ext */
    gboolean arg_home_network_3gpp2_ext_set;
    guint16 arg_home_network_3gpp2_ext_mcc;
    guint16 arg_home_network_3gpp2_ext_mnc;
    guint8 arg_home_network_3gpp2_ext_display_description;
    guint8 arg_home_network_3gpp2_ext_description_encoding;
    GArray *arg_home_network_3gpp2_ext_description;

    /* Home System ID */
    gboolean arg_home_system_id_set;
    guint16 arg_home_system_id_sid;
    guint16 arg_home_system_id_nid;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Home Network */
    gboolean arg_home_network_set;
    guint16 arg_home_network_mcc;
    guint16 arg_home_network_mnc;
    gchar *arg_home_network_description;
};

#define QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_NETWORK_NAME_SOURCE 0x13
#define QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP_MNC 0x12
#define QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP2_EXT 0x11
#define QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_SYSTEM_ID 0x10
#define QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK 0x01

gboolean
qmi_message_nas_get_home_network_output_get_network_name_source (
    QmiMessageNasGetHomeNetworkOutput *self,
    QmiNasNetworkNameSource *value_network_name_source,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_name_source_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Name Source' was not found in the message");
        return FALSE;
    }

    if (value_network_name_source)
        *value_network_name_source = (QmiNasNetworkNameSource)(self->arg_network_name_source);

    return TRUE;
}

gboolean
qmi_message_nas_get_home_network_output_get_home_network_3gpp_mnc (
    QmiMessageNasGetHomeNetworkOutput *self,
    gboolean *value_home_network_3gpp_mnc_is_3gpp,
    gboolean *value_home_network_3gpp_mnc_includes_pcs_digit,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_home_network_3gpp_mnc_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Home Network 3GPP MNC' was not found in the message");
        return FALSE;
    }

    if (value_home_network_3gpp_mnc_is_3gpp)
        *value_home_network_3gpp_mnc_is_3gpp = (gboolean)(self->arg_home_network_3gpp_mnc_is_3gpp);
    if (value_home_network_3gpp_mnc_includes_pcs_digit)
        *value_home_network_3gpp_mnc_includes_pcs_digit = (gboolean)(self->arg_home_network_3gpp_mnc_includes_pcs_digit);

    return TRUE;
}

gboolean
qmi_message_nas_get_home_network_output_get_home_network_3gpp2_ext (
    QmiMessageNasGetHomeNetworkOutput *self,
    guint16 *value_home_network_3gpp2_ext_mcc,
    guint16 *value_home_network_3gpp2_ext_mnc,
    QmiNasNetworkDescriptionDisplay *value_home_network_3gpp2_ext_display_description,
    QmiNasNetworkDescriptionEncoding *value_home_network_3gpp2_ext_description_encoding,
    GArray **value_home_network_3gpp2_ext_description,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_home_network_3gpp2_ext_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Home Network 3GPP2 Ext' was not found in the message");
        return FALSE;
    }

    if (value_home_network_3gpp2_ext_mcc)
        *value_home_network_3gpp2_ext_mcc = self->arg_home_network_3gpp2_ext_mcc;
    if (value_home_network_3gpp2_ext_mnc)
        *value_home_network_3gpp2_ext_mnc = self->arg_home_network_3gpp2_ext_mnc;
    if (value_home_network_3gpp2_ext_display_description)
        *value_home_network_3gpp2_ext_display_description = (QmiNasNetworkDescriptionDisplay)(self->arg_home_network_3gpp2_ext_display_description);
    if (value_home_network_3gpp2_ext_description_encoding)
        *value_home_network_3gpp2_ext_description_encoding = (QmiNasNetworkDescriptionEncoding)(self->arg_home_network_3gpp2_ext_description_encoding);
    if (value_home_network_3gpp2_ext_description)
        *value_home_network_3gpp2_ext_description = self->arg_home_network_3gpp2_ext_description;

    return TRUE;
}

gboolean
qmi_message_nas_get_home_network_output_get_home_system_id (
    QmiMessageNasGetHomeNetworkOutput *self,
    guint16 *value_home_system_id_sid,
    guint16 *value_home_system_id_nid,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_home_system_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Home System ID' was not found in the message");
        return FALSE;
    }

    if (value_home_system_id_sid)
        *value_home_system_id_sid = self->arg_home_system_id_sid;
    if (value_home_system_id_nid)
        *value_home_system_id_nid = self->arg_home_system_id_nid;

    return TRUE;
}

gboolean
qmi_message_nas_get_home_network_output_get_result (
    QmiMessageNasGetHomeNetworkOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_get_home_network_output_get_home_network (
    QmiMessageNasGetHomeNetworkOutput *self,
    guint16 *value_home_network_mcc,
    guint16 *value_home_network_mnc,
    const gchar **value_home_network_description,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_home_network_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Home Network' was not found in the message");
        return FALSE;
    }

    if (value_home_network_mcc)
        *value_home_network_mcc = self->arg_home_network_mcc;
    if (value_home_network_mnc)
        *value_home_network_mnc = self->arg_home_network_mnc;
    if (value_home_network_description)
        *value_home_network_description = self->arg_home_network_description;

    return TRUE;
}

GType
qmi_message_nas_get_home_network_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetHomeNetworkOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_home_network_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_home_network_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetHomeNetworkOutput *
qmi_message_nas_get_home_network_output_ref (QmiMessageNasGetHomeNetworkOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_home_network_output_unref (QmiMessageNasGetHomeNetworkOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_home_network_3gpp2_ext_description)
            g_array_unref (self->arg_home_network_3gpp2_ext_description);
        g_free (self->arg_home_network_description);
        g_slice_free (QmiMessageNasGetHomeNetworkOutput, self);
    }
}

static gchar *
qmi_message_nas_get_home_network_output_network_name_source_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_NETWORK_NAME_SOURCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_NAME_SOURCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_name_source_get_string ((QmiNasNetworkNameSource)tmp));
#elif defined  __QMI_NAS_NETWORK_NAME_SOURCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_name_source_build_string_from_mask ((QmiNasNetworkNameSource)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkNameSource
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_home_network_output_home_network_3gpp_mnc_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP_MNC, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " is_3gpp = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " includes_pcs_digit = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_home_network_output_home_network_3gpp2_ext_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP2_EXT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " display_description = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_description_display_get_string ((QmiNasNetworkDescriptionDisplay)tmp));
#elif defined  __QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_description_display_build_string_from_mask ((QmiNasNetworkDescriptionDisplay)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkDescriptionDisplay
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " description_encoding = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_description_encoding_get_string ((QmiNasNetworkDescriptionEncoding)tmp));
#elif defined  __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_description_encoding_build_string_from_mask ((QmiNasNetworkDescriptionEncoding)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkDescriptionEncoding
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " description = '");
    {
        guint description_i;
        guint8 description_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(description_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (description_i = 0; description_i < description_n_items; description_i++) {
            g_string_append_printf (printable, " [%u] = '", description_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_home_network_output_home_system_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_SYSTEM_ID, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " sid = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " nid = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_home_network_output_home_network_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " description = '");

    {
        g_autofree gchar *tmp = NULL;

        if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &tmp, &error))
            goto out;
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_home_network_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_home_network_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_home_network_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_NETWORK_NAME_SOURCE:
            tlv_type_str = "Network Name Source";
            translated_value = qmi_message_nas_get_home_network_output_network_name_source_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP_MNC:
            tlv_type_str = "Home Network 3GPP MNC";
            translated_value = qmi_message_nas_get_home_network_output_home_network_3gpp_mnc_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP2_EXT:
            tlv_type_str = "Home Network 3GPP2 Ext";
            translated_value = qmi_message_nas_get_home_network_output_home_network_3gpp2_ext_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_SYSTEM_ID:
            tlv_type_str = "Home System ID";
            translated_value = qmi_message_nas_get_home_network_output_home_system_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK:
            tlv_type_str = "Home Network";
            translated_value = qmi_message_nas_get_home_network_output_home_network_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_home_network_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Home Network\" (0x0025)\n",
                            line_prefix);

    {
        struct message_get_home_network_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_home_network_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetHomeNetworkOutput *
__qmi_message_nas_get_home_network_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetHomeNetworkOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_HOME_NETWORK);

    self = g_slice_new0 (QmiMessageNasGetHomeNetworkOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_NETWORK_NAME_SOURCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_home_network_output_network_name_source_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_home_network_output_network_name_source_out;
                self->arg_network_name_source = (QmiNasNetworkNameSource)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Network Name Source' TLV", offset);
            }

            self->arg_network_name_source_set = TRUE;

qmi_message_nas_get_home_network_output_network_name_source_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP_MNC, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_home_network_output_home_network_3gpp_mnc_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_home_network_output_home_network_3gpp_mnc_out;
                self->arg_home_network_3gpp_mnc_is_3gpp = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_home_network_output_home_network_3gpp_mnc_out;
                self->arg_home_network_3gpp_mnc_includes_pcs_digit = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Home Network 3GPP MNC' TLV", offset);
            }

            self->arg_home_network_3gpp_mnc_set = TRUE;

qmi_message_nas_get_home_network_output_home_network_3gpp_mnc_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP2_EXT, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_home_network_output_home_network_3gpp2_ext_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_home_network_3gpp2_ext_mcc), NULL))
                goto qmi_message_nas_get_home_network_output_home_network_3gpp2_ext_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_home_network_3gpp2_ext_mnc), NULL))
                goto qmi_message_nas_get_home_network_output_home_network_3gpp2_ext_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_home_network_output_home_network_3gpp2_ext_out;
                self->arg_home_network_3gpp2_ext_display_description = (QmiNasNetworkDescriptionDisplay)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_home_network_output_home_network_3gpp2_ext_out;
                self->arg_home_network_3gpp2_ext_description_encoding = (QmiNasNetworkDescriptionEncoding)tmp;
            }
            {
                guint description_i;
                guint8 description_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(description_n_items), NULL))
                    goto qmi_message_nas_get_home_network_output_home_network_3gpp2_ext_out;

                self->arg_home_network_3gpp2_ext_description = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)description_n_items);

                for (description_i = 0; description_i < description_n_items; description_i++) {
                    guint8 description_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(description_aux), NULL))
                        goto qmi_message_nas_get_home_network_output_home_network_3gpp2_ext_out;
                    g_array_insert_val (self->arg_home_network_3gpp2_ext_description, description_i, description_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Home Network 3GPP2 Ext' TLV", offset);
            }

            self->arg_home_network_3gpp2_ext_set = TRUE;

qmi_message_nas_get_home_network_output_home_network_3gpp2_ext_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_SYSTEM_ID, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_home_network_output_home_system_id_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_home_system_id_sid), NULL))
                goto qmi_message_nas_get_home_network_output_home_system_id_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_home_system_id_nid), NULL))
                goto qmi_message_nas_get_home_network_output_home_system_id_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Home System ID' TLV", offset);
            }

            self->arg_home_system_id_set = TRUE;

qmi_message_nas_get_home_network_output_home_system_id_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_home_network_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_home_network_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Home Network TLV: ");
                qmi_message_nas_get_home_network_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_home_network_mcc), error))
                goto qmi_message_nas_get_home_network_output_home_network_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_home_network_mnc), error))
                goto qmi_message_nas_get_home_network_output_home_network_out;
            if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &(self->arg_home_network_description), error))
                goto qmi_message_nas_get_home_network_output_home_network_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Home Network' TLV", offset);
            }

            self->arg_home_network_set = TRUE;

qmi_message_nas_get_home_network_output_home_network_out:
            if (!self->arg_home_network_set) {
                qmi_message_nas_get_home_network_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Preferred Networks */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_preferred_networks_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetPreferredNetworksOutput {
    volatile gint ref_count;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    GArray *arg_mnc_pcs_digit_include_status;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Preferred Networks */
    gboolean arg_preferred_networks_set;
    GArray *arg_preferred_networks;
};

#define QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x12
#define QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS_OUTPUT_TLV_PREFERRED_NETWORKS 0x10

gboolean
qmi_message_nas_get_preferred_networks_output_get_mnc_pcs_digit_include_status (
    QmiMessageNasGetPreferredNetworksOutput *self,
    GArray **value_mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (value_mnc_pcs_digit_include_status)
        *value_mnc_pcs_digit_include_status = self->arg_mnc_pcs_digit_include_status;

    return TRUE;
}

gboolean
qmi_message_nas_get_preferred_networks_output_get_result (
    QmiMessageNasGetPreferredNetworksOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_get_preferred_networks_output_get_preferred_networks (
    QmiMessageNasGetPreferredNetworksOutput *self,
    GArray **value_preferred_networks,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_preferred_networks_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Preferred Networks' was not found in the message");
        return FALSE;
    }

    if (value_preferred_networks)
        *value_preferred_networks = self->arg_preferred_networks;

    return TRUE;
}

GType
qmi_message_nas_get_preferred_networks_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetPreferredNetworksOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_preferred_networks_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_preferred_networks_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetPreferredNetworksOutput *
qmi_message_nas_get_preferred_networks_output_ref (QmiMessageNasGetPreferredNetworksOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_preferred_networks_output_unref (QmiMessageNasGetPreferredNetworksOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_mnc_pcs_digit_include_status)
            g_array_unref (self->arg_mnc_pcs_digit_include_status);
        if (self->arg_preferred_networks)
            g_array_unref (self->arg_preferred_networks);
        g_slice_free (QmiMessageNasGetPreferredNetworksOutput, self);
    }
}

static gchar *
qmi_message_nas_get_preferred_networks_output_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint mnc_pcs_digit_include_status_i;
        guint8 mnc_pcs_digit_include_status_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(mnc_pcs_digit_include_status_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (mnc_pcs_digit_include_status_i = 0; mnc_pcs_digit_include_status_i < mnc_pcs_digit_include_status_n_items; mnc_pcs_digit_include_status_i++) {
            g_string_append_printf (printable, " [%u] = '", mnc_pcs_digit_include_status_i);
            g_string_append (printable, "[");
            g_string_append (printable, " mcc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " mnc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " includes_pcs_digit = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_preferred_networks_output_preferred_networks_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS_OUTPUT_TLV_PREFERRED_NETWORKS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint preferred_networks_i;
        guint16 preferred_networks_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(preferred_networks_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (preferred_networks_i = 0; preferred_networks_i < preferred_networks_n_items; preferred_networks_i++) {
            g_string_append_printf (printable, " [%u] = '", preferred_networks_i);
            g_string_append (printable, "[");
            g_string_append (printable, " mcc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " mnc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " radio_access_technology = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_plmn_access_technology_identifier_get_string ((QmiNasPlmnAccessTechnologyIdentifier)tmp));
#elif defined  __QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_plmn_access_technology_identifier_build_string_from_mask ((QmiNasPlmnAccessTechnologyIdentifier)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasPlmnAccessTechnologyIdentifier
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_preferred_networks_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_preferred_networks_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_preferred_networks_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_message_nas_get_preferred_networks_output_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS_OUTPUT_TLV_PREFERRED_NETWORKS:
            tlv_type_str = "Preferred Networks";
            translated_value = qmi_message_nas_get_preferred_networks_output_preferred_networks_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_preferred_networks_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Preferred Networks\" (0x0026)\n",
                            line_prefix);

    {
        struct message_get_preferred_networks_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_preferred_networks_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetPreferredNetworksOutput *
__qmi_message_nas_get_preferred_networks_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetPreferredNetworksOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS);

    self = g_slice_new0 (QmiMessageNasGetPreferredNetworksOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_preferred_networks_output_mnc_pcs_digit_include_status_out;
            }
            {
                guint mnc_pcs_digit_include_status_i;
                guint8 mnc_pcs_digit_include_status_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(mnc_pcs_digit_include_status_n_items), NULL))
                    goto qmi_message_nas_get_preferred_networks_output_mnc_pcs_digit_include_status_out;

                self->arg_mnc_pcs_digit_include_status = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetPreferredNetworksOutputMncPcsDigitIncludeStatusElement),
                    (guint)mnc_pcs_digit_include_status_n_items);

                for (mnc_pcs_digit_include_status_i = 0; mnc_pcs_digit_include_status_i < mnc_pcs_digit_include_status_n_items; mnc_pcs_digit_include_status_i++) {
                    QmiMessageNasGetPreferredNetworksOutputMncPcsDigitIncludeStatusElement mnc_pcs_digit_include_status_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(mnc_pcs_digit_include_status_aux.mcc), NULL))
                        goto qmi_message_nas_get_preferred_networks_output_mnc_pcs_digit_include_status_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(mnc_pcs_digit_include_status_aux.mnc), NULL))
                        goto qmi_message_nas_get_preferred_networks_output_mnc_pcs_digit_include_status_out;
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_preferred_networks_output_mnc_pcs_digit_include_status_out;
                        mnc_pcs_digit_include_status_aux.includes_pcs_digit = (gboolean)tmp;
                    }
                    g_array_insert_val (self->arg_mnc_pcs_digit_include_status, mnc_pcs_digit_include_status_i, mnc_pcs_digit_include_status_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'MNC PCS Digit Include Status' TLV", offset);
            }

            self->arg_mnc_pcs_digit_include_status_set = TRUE;

qmi_message_nas_get_preferred_networks_output_mnc_pcs_digit_include_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_preferred_networks_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_preferred_networks_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS_OUTPUT_TLV_PREFERRED_NETWORKS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_preferred_networks_output_preferred_networks_out;
            }
            {
                guint preferred_networks_i;
                guint16 preferred_networks_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(preferred_networks_n_items), NULL))
                    goto qmi_message_nas_get_preferred_networks_output_preferred_networks_out;

                self->arg_preferred_networks = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetPreferredNetworksOutputPreferredNetworksElement),
                    (guint)preferred_networks_n_items);

                for (preferred_networks_i = 0; preferred_networks_i < preferred_networks_n_items; preferred_networks_i++) {
                    QmiMessageNasGetPreferredNetworksOutputPreferredNetworksElement preferred_networks_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(preferred_networks_aux.mcc), NULL))
                        goto qmi_message_nas_get_preferred_networks_output_preferred_networks_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(preferred_networks_aux.mnc), NULL))
                        goto qmi_message_nas_get_preferred_networks_output_preferred_networks_out;
                    {
                        guint16 tmp;

                        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                            goto qmi_message_nas_get_preferred_networks_output_preferred_networks_out;
                        preferred_networks_aux.radio_access_technology = (QmiNasPlmnAccessTechnologyIdentifier)tmp;
                    }
                    g_array_insert_val (self->arg_preferred_networks, preferred_networks_i, preferred_networks_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Preferred Networks' TLV", offset);
            }

            self->arg_preferred_networks_set = TRUE;

qmi_message_nas_get_preferred_networks_output_preferred_networks_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Set Preferred Networks */


/* --- Input -- */

struct _QmiMessageNasSetPreferredNetworksInput {
    volatile gint ref_count;

    /* Clear Previous Preferred Networks */
    gboolean arg_clear_previous_preferred_networks_set;
    guint8 arg_clear_previous_preferred_networks;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    GArray *arg_mnc_pcs_digit_include_status;

    /* Preferred Networks */
    gboolean arg_preferred_networks_set;
    GArray *arg_preferred_networks;
};

#define QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_CLEAR_PREVIOUS_PREFERRED_NETWORKS 0x12
#define QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x11
#define QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_PREFERRED_NETWORKS 0x10

gboolean
qmi_message_nas_set_preferred_networks_input_get_clear_previous_preferred_networks (
    QmiMessageNasSetPreferredNetworksInput *self,
    gboolean *value_clear_previous_preferred_networks,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_clear_previous_preferred_networks_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Clear Previous Preferred Networks' was not found in the message");
        return FALSE;
    }

    if (value_clear_previous_preferred_networks)
        *value_clear_previous_preferred_networks = (gboolean)(self->arg_clear_previous_preferred_networks);

    return TRUE;
}

gboolean
qmi_message_nas_set_preferred_networks_input_set_clear_previous_preferred_networks (
    QmiMessageNasSetPreferredNetworksInput *self,
    gboolean value_clear_previous_preferred_networks,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_clear_previous_preferred_networks = (guint8)(value_clear_previous_preferred_networks);
    self->arg_clear_previous_preferred_networks_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_preferred_networks_input_get_mnc_pcs_digit_include_status (
    QmiMessageNasSetPreferredNetworksInput *self,
    GArray **value_mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (value_mnc_pcs_digit_include_status)
        *value_mnc_pcs_digit_include_status = self->arg_mnc_pcs_digit_include_status;

    return TRUE;
}

gboolean
qmi_message_nas_set_preferred_networks_input_set_mnc_pcs_digit_include_status (
    QmiMessageNasSetPreferredNetworksInput *self,
    GArray *value_mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_mnc_pcs_digit_include_status)
        g_array_unref (self->arg_mnc_pcs_digit_include_status);
    self->arg_mnc_pcs_digit_include_status = g_array_ref (value_mnc_pcs_digit_include_status);
    self->arg_mnc_pcs_digit_include_status_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_preferred_networks_input_get_preferred_networks (
    QmiMessageNasSetPreferredNetworksInput *self,
    GArray **value_preferred_networks,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_preferred_networks_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Preferred Networks' was not found in the message");
        return FALSE;
    }

    if (value_preferred_networks)
        *value_preferred_networks = self->arg_preferred_networks;

    return TRUE;
}

gboolean
qmi_message_nas_set_preferred_networks_input_set_preferred_networks (
    QmiMessageNasSetPreferredNetworksInput *self,
    GArray *value_preferred_networks,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_preferred_networks)
        g_array_unref (self->arg_preferred_networks);
    self->arg_preferred_networks = g_array_ref (value_preferred_networks);
    self->arg_preferred_networks_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_set_preferred_networks_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetPreferredNetworksInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_preferred_networks_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_preferred_networks_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasSetPreferredNetworksInput *
qmi_message_nas_set_preferred_networks_input_ref (QmiMessageNasSetPreferredNetworksInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_set_preferred_networks_input_unref (QmiMessageNasSetPreferredNetworksInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_mnc_pcs_digit_include_status)
            g_array_unref (self->arg_mnc_pcs_digit_include_status);
        if (self->arg_preferred_networks)
            g_array_unref (self->arg_preferred_networks);
        g_slice_free (QmiMessageNasSetPreferredNetworksInput, self);
    }
}

QmiMessageNasSetPreferredNetworksInput *
qmi_message_nas_set_preferred_networks_input_new (void)
{
    QmiMessageNasSetPreferredNetworksInput *self;

    self = g_slice_new0 (QmiMessageNasSetPreferredNetworksInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_set_preferred_networks_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasSetPreferredNetworksInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return g_steal_pointer (&self);

    /* Try to add the 'Clear Previous Preferred Networks' TLV */
    if (input->arg_clear_previous_preferred_networks_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_CLEAR_PREVIOUS_PREFERRED_NETWORKS, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Clear Previous Preferred Networks': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_clear_previous_preferred_networks;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Clear Previous Preferred Networks': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Clear Previous Preferred Networks': ");
            return NULL;
        }
    }

    /* Try to add the 'MNC PCS Digit Include Status' TLV */
    if (input->arg_mnc_pcs_digit_include_status_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'MNC PCS Digit Include Status': ");
            return NULL;
        }

        {
            guint mnc_pcs_digit_include_status_i;
            guint8 mnc_pcs_digit_include_status_n_items;

            /* Write the number of items in the array first */
            mnc_pcs_digit_include_status_n_items = (guint8) input->arg_mnc_pcs_digit_include_status->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, mnc_pcs_digit_include_status_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'MNC PCS Digit Include Status': ");
                return NULL;
            }

            for (mnc_pcs_digit_include_status_i = 0; mnc_pcs_digit_include_status_i < input->arg_mnc_pcs_digit_include_status->len; mnc_pcs_digit_include_status_i++) {
                /* Write the guint16 variable to the buffer */
                if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, g_array_index (input->arg_mnc_pcs_digit_include_status, QmiMessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement,mnc_pcs_digit_include_status_i).mcc, error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'MNC PCS Digit Include Status': ");
                    return NULL;
                }
                /* Write the guint16 variable to the buffer */
                if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, g_array_index (input->arg_mnc_pcs_digit_include_status, QmiMessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement,mnc_pcs_digit_include_status_i).mnc, error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'MNC PCS Digit Include Status': ");
                    return NULL;
                }
                {
                    guint8 tmp;

                    tmp = (guint8) g_array_index (input->arg_mnc_pcs_digit_include_status, QmiMessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement,mnc_pcs_digit_include_status_i).includes_pcs_digit;
                    /* Write the guint8 variable to the buffer */
                    if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                        g_prefix_error (error, "Cannot write enum in TLV 'MNC PCS Digit Include Status': ");
                        return NULL;
                    }
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'MNC PCS Digit Include Status': ");
            return NULL;
        }
    }

    /* Try to add the 'Preferred Networks' TLV */
    if (input->arg_preferred_networks_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_PREFERRED_NETWORKS, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Preferred Networks': ");
            return NULL;
        }

        {
            guint preferred_networks_i;
            guint16 preferred_networks_n_items;

            /* Write the number of items in the array first */
            preferred_networks_n_items = (guint16) input->arg_preferred_networks->len;
            /* Write the guint16 variable to the buffer */
            if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, preferred_networks_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'Preferred Networks': ");
                return NULL;
            }

            for (preferred_networks_i = 0; preferred_networks_i < input->arg_preferred_networks->len; preferred_networks_i++) {
                /* Write the guint16 variable to the buffer */
                if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, g_array_index (input->arg_preferred_networks, QmiMessageNasSetPreferredNetworksInputPreferredNetworksElement,preferred_networks_i).mcc, error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'Preferred Networks': ");
                    return NULL;
                }
                /* Write the guint16 variable to the buffer */
                if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, g_array_index (input->arg_preferred_networks, QmiMessageNasSetPreferredNetworksInputPreferredNetworksElement,preferred_networks_i).mnc, error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'Preferred Networks': ");
                    return NULL;
                }
                {
                    guint16 tmp;

                    tmp = (guint16) g_array_index (input->arg_preferred_networks, QmiMessageNasSetPreferredNetworksInputPreferredNetworksElement,preferred_networks_i).radio_access_technology;
                    /* Write the guint16 variable to the buffer */
                    if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                        g_prefix_error (error, "Cannot write enum in TLV 'Preferred Networks': ");
                        return NULL;
                    }
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Preferred Networks': ");
            return NULL;
        }
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasSetPreferredNetworksOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_set_preferred_networks_output_get_result (
    QmiMessageNasSetPreferredNetworksOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_set_preferred_networks_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetPreferredNetworksOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_preferred_networks_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_preferred_networks_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasSetPreferredNetworksOutput *
qmi_message_nas_set_preferred_networks_output_ref (QmiMessageNasSetPreferredNetworksOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_set_preferred_networks_output_unref (QmiMessageNasSetPreferredNetworksOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasSetPreferredNetworksOutput, self);
    }
}

static gchar *
qmi_message_nas_set_preferred_networks_input_clear_previous_preferred_networks_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_CLEAR_PREVIOUS_PREFERRED_NETWORKS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_preferred_networks_input_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint mnc_pcs_digit_include_status_i;
        guint8 mnc_pcs_digit_include_status_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(mnc_pcs_digit_include_status_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (mnc_pcs_digit_include_status_i = 0; mnc_pcs_digit_include_status_i < mnc_pcs_digit_include_status_n_items; mnc_pcs_digit_include_status_i++) {
            g_string_append_printf (printable, " [%u] = '", mnc_pcs_digit_include_status_i);
            g_string_append (printable, "[");
            g_string_append (printable, " mcc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " mnc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " includes_pcs_digit = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_preferred_networks_input_preferred_networks_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_PREFERRED_NETWORKS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint preferred_networks_i;
        guint16 preferred_networks_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(preferred_networks_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (preferred_networks_i = 0; preferred_networks_i < preferred_networks_n_items; preferred_networks_i++) {
            g_string_append_printf (printable, " [%u] = '", preferred_networks_i);
            g_string_append (printable, "[");
            g_string_append (printable, " mcc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " mnc = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " radio_access_technology = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_plmn_access_technology_identifier_get_string ((QmiNasPlmnAccessTechnologyIdentifier)tmp));
#elif defined  __QMI_NAS_PLMN_ACCESS_TECHNOLOGY_IDENTIFIER_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_plmn_access_technology_identifier_build_string_from_mask ((QmiNasPlmnAccessTechnologyIdentifier)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasPlmnAccessTechnologyIdentifier
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_set_preferred_networks_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_preferred_networks_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_preferred_networks_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_CLEAR_PREVIOUS_PREFERRED_NETWORKS:
            tlv_type_str = "Clear Previous Preferred Networks";
            translated_value = qmi_message_nas_set_preferred_networks_input_clear_previous_preferred_networks_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_message_nas_set_preferred_networks_input_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_INPUT_TLV_PREFERRED_NETWORKS:
            tlv_type_str = "Preferred Networks";
            translated_value = qmi_message_nas_set_preferred_networks_input_preferred_networks_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_set_preferred_networks_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set Preferred Networks\" (0x0027)\n",
                            line_prefix);

    {
        struct message_set_preferred_networks_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_preferred_networks_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasSetPreferredNetworksOutput *
__qmi_message_nas_set_preferred_networks_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasSetPreferredNetworksOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS);

    self = g_slice_new0 (QmiMessageNasSetPreferredNetworksOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_set_preferred_networks_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_set_preferred_networks_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Set Technology Preference */


/* --- Input -- */

struct _QmiMessageNasSetTechnologyPreferenceInput {
    volatile gint ref_count;

    /* Current */
    gboolean arg_current_set;
    guint16 arg_current_technology_preference;
    guint8 arg_current_technology_preference_duration;
};

#define QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_INPUT_TLV_CURRENT 0x01

gboolean
qmi_message_nas_set_technology_preference_input_get_current (
    QmiMessageNasSetTechnologyPreferenceInput *self,
    QmiNasRadioTechnologyPreference *value_current_technology_preference,
    QmiNasPreferenceDuration *value_current_technology_preference_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_current_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Current' was not found in the message");
        return FALSE;
    }

    if (value_current_technology_preference)
        *value_current_technology_preference = (QmiNasRadioTechnologyPreference)(self->arg_current_technology_preference);
    if (value_current_technology_preference_duration)
        *value_current_technology_preference_duration = (QmiNasPreferenceDuration)(self->arg_current_technology_preference_duration);

    return TRUE;
}

gboolean
qmi_message_nas_set_technology_preference_input_set_current (
    QmiMessageNasSetTechnologyPreferenceInput *self,
    QmiNasRadioTechnologyPreference value_current_technology_preference,
    QmiNasPreferenceDuration value_current_technology_preference_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_current_technology_preference = (guint16)(value_current_technology_preference);
    self->arg_current_technology_preference_duration = (guint8)(value_current_technology_preference_duration);
    self->arg_current_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_set_technology_preference_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetTechnologyPreferenceInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_technology_preference_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_technology_preference_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasSetTechnologyPreferenceInput *
qmi_message_nas_set_technology_preference_input_ref (QmiMessageNasSetTechnologyPreferenceInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_set_technology_preference_input_unref (QmiMessageNasSetTechnologyPreferenceInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasSetTechnologyPreferenceInput, self);
    }
}

QmiMessageNasSetTechnologyPreferenceInput *
qmi_message_nas_set_technology_preference_input_new (void)
{
    QmiMessageNasSetTechnologyPreferenceInput *self;

    self = g_slice_new0 (QmiMessageNasSetTechnologyPreferenceInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_set_technology_preference_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasSetTechnologyPreferenceInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Set Technology Preference' has mandatory TLVs");
        return NULL;
    }

    /* Try to add the 'Current' TLV */
    if (input->arg_current_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_INPUT_TLV_CURRENT, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Current': ");
            return NULL;
        }

        {
            guint16 tmp;

            tmp = (guint16) input->arg_current_technology_preference;
            /* Write the guint16 variable to the buffer */
            if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Current': ");
                return NULL;
            }
        }
        {
            guint8 tmp;

            tmp = (guint8) input->arg_current_technology_preference_duration;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Current': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Current': ");
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Current' in message 'Set Technology Preference'");
        return NULL;
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasSetTechnologyPreferenceOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_set_technology_preference_output_get_result (
    QmiMessageNasSetTechnologyPreferenceOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_set_technology_preference_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetTechnologyPreferenceOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_technology_preference_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_technology_preference_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasSetTechnologyPreferenceOutput *
qmi_message_nas_set_technology_preference_output_ref (QmiMessageNasSetTechnologyPreferenceOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_set_technology_preference_output_unref (QmiMessageNasSetTechnologyPreferenceOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasSetTechnologyPreferenceOutput, self);
    }
}

static gchar *
qmi_message_nas_set_technology_preference_input_current_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_INPUT_TLV_CURRENT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " technology_preference = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_technology_preference_get_string ((QmiNasRadioTechnologyPreference)tmp));
#elif defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_technology_preference_build_string_from_mask ((QmiNasRadioTechnologyPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioTechnologyPreference
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " technology_preference_duration = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PREFERENCE_DURATION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_preference_duration_get_string ((QmiNasPreferenceDuration)tmp));
#elif defined  __QMI_NAS_PREFERENCE_DURATION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_preference_duration_build_string_from_mask ((QmiNasPreferenceDuration)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPreferenceDuration
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_set_technology_preference_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_technology_preference_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_technology_preference_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_INPUT_TLV_CURRENT:
            tlv_type_str = "Current";
            translated_value = qmi_message_nas_set_technology_preference_input_current_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_set_technology_preference_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set Technology Preference\" (0x002A)\n",
                            line_prefix);

    {
        struct message_set_technology_preference_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_technology_preference_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasSetTechnologyPreferenceOutput *
__qmi_message_nas_set_technology_preference_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasSetTechnologyPreferenceOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE);

    self = g_slice_new0 (QmiMessageNasSetTechnologyPreferenceOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_set_technology_preference_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_set_technology_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Technology Preference */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_technology_preference_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetTechnologyPreferenceOutput {
    volatile gint ref_count;

    /* Persistent */
    gboolean arg_persistent_set;
    guint16 arg_persistent;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Active */
    gboolean arg_active_set;
    guint16 arg_active_technology_preference;
    guint8 arg_active_technology_preference_duration;
};

#define QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_PERSISTENT 0x10
#define QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_ACTIVE 0x01

gboolean
qmi_message_nas_get_technology_preference_output_get_persistent (
    QmiMessageNasGetTechnologyPreferenceOutput *self,
    QmiNasRadioTechnologyPreference *value_persistent,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_persistent_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Persistent' was not found in the message");
        return FALSE;
    }

    if (value_persistent)
        *value_persistent = (QmiNasRadioTechnologyPreference)(self->arg_persistent);

    return TRUE;
}

gboolean
qmi_message_nas_get_technology_preference_output_get_result (
    QmiMessageNasGetTechnologyPreferenceOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_get_technology_preference_output_get_active (
    QmiMessageNasGetTechnologyPreferenceOutput *self,
    QmiNasRadioTechnologyPreference *value_active_technology_preference,
    QmiNasPreferenceDuration *value_active_technology_preference_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_active_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Active' was not found in the message");
        return FALSE;
    }

    if (value_active_technology_preference)
        *value_active_technology_preference = (QmiNasRadioTechnologyPreference)(self->arg_active_technology_preference);
    if (value_active_technology_preference_duration)
        *value_active_technology_preference_duration = (QmiNasPreferenceDuration)(self->arg_active_technology_preference_duration);

    return TRUE;
}

GType
qmi_message_nas_get_technology_preference_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetTechnologyPreferenceOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_technology_preference_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_technology_preference_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetTechnologyPreferenceOutput *
qmi_message_nas_get_technology_preference_output_ref (QmiMessageNasGetTechnologyPreferenceOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_technology_preference_output_unref (QmiMessageNasGetTechnologyPreferenceOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetTechnologyPreferenceOutput, self);
    }
}

static gchar *
qmi_message_nas_get_technology_preference_output_persistent_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_PERSISTENT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_technology_preference_get_string ((QmiNasRadioTechnologyPreference)tmp));
#elif defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_technology_preference_build_string_from_mask ((QmiNasRadioTechnologyPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioTechnologyPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_technology_preference_output_active_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_ACTIVE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " technology_preference = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_technology_preference_get_string ((QmiNasRadioTechnologyPreference)tmp));
#elif defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_technology_preference_build_string_from_mask ((QmiNasRadioTechnologyPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioTechnologyPreference
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " technology_preference_duration = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PREFERENCE_DURATION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_preference_duration_get_string ((QmiNasPreferenceDuration)tmp));
#elif defined  __QMI_NAS_PREFERENCE_DURATION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_preference_duration_build_string_from_mask ((QmiNasPreferenceDuration)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPreferenceDuration
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_technology_preference_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_technology_preference_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_technology_preference_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_PERSISTENT:
            tlv_type_str = "Persistent";
            translated_value = qmi_message_nas_get_technology_preference_output_persistent_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_ACTIVE:
            tlv_type_str = "Active";
            translated_value = qmi_message_nas_get_technology_preference_output_active_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_technology_preference_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Technology Preference\" (0x002B)\n",
                            line_prefix);

    {
        struct message_get_technology_preference_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_technology_preference_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetTechnologyPreferenceOutput *
__qmi_message_nas_get_technology_preference_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetTechnologyPreferenceOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE);

    self = g_slice_new0 (QmiMessageNasGetTechnologyPreferenceOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_PERSISTENT, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_technology_preference_output_persistent_out;
            }
            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_technology_preference_output_persistent_out;
                self->arg_persistent = (QmiNasRadioTechnologyPreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Persistent' TLV", offset);
            }

            self->arg_persistent_set = TRUE;

qmi_message_nas_get_technology_preference_output_persistent_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_technology_preference_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_technology_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_ACTIVE, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Active TLV: ");
                qmi_message_nas_get_technology_preference_output_unref (self);
                return NULL;
            }
            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, error))
                    goto qmi_message_nas_get_technology_preference_output_active_out;
                self->arg_active_technology_preference = (QmiNasRadioTechnologyPreference)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_message_nas_get_technology_preference_output_active_out;
                self->arg_active_technology_preference_duration = (QmiNasPreferenceDuration)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Active' TLV", offset);
            }

            self->arg_active_set = TRUE;

qmi_message_nas_get_technology_preference_output_active_out:
            if (!self->arg_active_set) {
                qmi_message_nas_get_technology_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get RF Band Information */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_rf_band_information_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetRfBandInformationOutput {
    volatile gint ref_count;

    /* Bandwidth List */
    gboolean arg_bandwidth_list_set;
    GArray *arg_bandwidth_list;

    /* Extended List */
    gboolean arg_extended_list_set;
    GArray *arg_extended_list;

    /* List */
    gboolean arg_list_set;
    GArray *arg_list;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_BANDWIDTH_LIST 0x12
#define QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_EXTENDED_LIST 0x11
#define QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_LIST 0x01
#define QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_get_rf_band_information_output_get_bandwidth_list (
    QmiMessageNasGetRfBandInformationOutput *self,
    GArray **value_bandwidth_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_bandwidth_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Bandwidth List' was not found in the message");
        return FALSE;
    }

    if (value_bandwidth_list)
        *value_bandwidth_list = self->arg_bandwidth_list;

    return TRUE;
}

gboolean
qmi_message_nas_get_rf_band_information_output_get_extended_list (
    QmiMessageNasGetRfBandInformationOutput *self,
    GArray **value_extended_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_extended_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Extended List' was not found in the message");
        return FALSE;
    }

    if (value_extended_list)
        *value_extended_list = self->arg_extended_list;

    return TRUE;
}

gboolean
qmi_message_nas_get_rf_band_information_output_get_list (
    QmiMessageNasGetRfBandInformationOutput *self,
    GArray **value_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'List' was not found in the message");
        return FALSE;
    }

    if (value_list)
        *value_list = self->arg_list;

    return TRUE;
}

gboolean
qmi_message_nas_get_rf_band_information_output_get_result (
    QmiMessageNasGetRfBandInformationOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_get_rf_band_information_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetRfBandInformationOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_rf_band_information_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_rf_band_information_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetRfBandInformationOutput *
qmi_message_nas_get_rf_band_information_output_ref (QmiMessageNasGetRfBandInformationOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_rf_band_information_output_unref (QmiMessageNasGetRfBandInformationOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_bandwidth_list)
            g_array_unref (self->arg_bandwidth_list);
        if (self->arg_extended_list)
            g_array_unref (self->arg_extended_list);
        if (self->arg_list)
            g_array_unref (self->arg_list);
        g_slice_free (QmiMessageNasGetRfBandInformationOutput, self);
    }
}

static gchar *
qmi_message_nas_get_rf_band_information_output_bandwidth_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_BANDWIDTH_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint bandwidth_list_i;
        guint8 bandwidth_list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(bandwidth_list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (bandwidth_list_i = 0; bandwidth_list_i < bandwidth_list_n_items; bandwidth_list_i++) {
            g_string_append_printf (printable, " [%u] = '", bandwidth_list_i);
            g_string_append (printable, "[");
            g_string_append (printable, " radio_interface = '");

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " bandwidth = '");

            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_DL_BANDWIDTH_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_dl_bandwidth_get_string ((QmiNasDLBandwidth)tmp));
#elif defined  __QMI_NAS_DL_BANDWIDTH_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_dl_bandwidth_build_string_from_mask ((QmiNasDLBandwidth)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasDLBandwidth
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_rf_band_information_output_extended_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_EXTENDED_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint extended_list_i;
        guint8 extended_list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(extended_list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (extended_list_i = 0; extended_list_i < extended_list_n_items; extended_list_i++) {
            g_string_append_printf (printable, " [%u] = '", extended_list_i);
            g_string_append (printable, "[");
            g_string_append (printable, " radio_interface = '");

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " active_band_class = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_ACTIVE_BAND_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_active_band_get_string ((QmiNasActiveBand)tmp));
#elif defined  __QMI_NAS_ACTIVE_BAND_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_active_band_build_string_from_mask ((QmiNasActiveBand)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasActiveBand
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " active_channel = '");

            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_rf_band_information_output_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint list_i;
        guint8 list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (list_i = 0; list_i < list_n_items; list_i++) {
            g_string_append_printf (printable, " [%u] = '", list_i);
            g_string_append (printable, "[");
            g_string_append (printable, " radio_interface = '");

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " active_band_class = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_ACTIVE_BAND_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_active_band_get_string ((QmiNasActiveBand)tmp));
#elif defined  __QMI_NAS_ACTIVE_BAND_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_active_band_build_string_from_mask ((QmiNasActiveBand)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasActiveBand
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " active_channel = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_rf_band_information_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_rf_band_information_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_rf_band_information_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_BANDWIDTH_LIST:
            tlv_type_str = "Bandwidth List";
            translated_value = qmi_message_nas_get_rf_band_information_output_bandwidth_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_EXTENDED_LIST:
            tlv_type_str = "Extended List";
            translated_value = qmi_message_nas_get_rf_band_information_output_extended_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_LIST:
            tlv_type_str = "List";
            translated_value = qmi_message_nas_get_rf_band_information_output_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_rf_band_information_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get RF Band Information\" (0x0031)\n",
                            line_prefix);

    {
        struct message_get_rf_band_information_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_rf_band_information_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetRfBandInformationOutput *
__qmi_message_nas_get_rf_band_information_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetRfBandInformationOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION);

    self = g_slice_new0 (QmiMessageNasGetRfBandInformationOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_BANDWIDTH_LIST, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_rf_band_information_output_bandwidth_list_out;
            }
            {
                guint bandwidth_list_i;
                guint8 bandwidth_list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(bandwidth_list_n_items), NULL))
                    goto qmi_message_nas_get_rf_band_information_output_bandwidth_list_out;

                self->arg_bandwidth_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetRfBandInformationOutputBandwidthListElement),
                    (guint)bandwidth_list_n_items);

                for (bandwidth_list_i = 0; bandwidth_list_i < bandwidth_list_n_items; bandwidth_list_i++) {
                    QmiMessageNasGetRfBandInformationOutputBandwidthListElement bandwidth_list_aux;

                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_rf_band_information_output_bandwidth_list_out;
                        bandwidth_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                    }
                    {
                        guint32 tmp;

                        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                            goto qmi_message_nas_get_rf_band_information_output_bandwidth_list_out;
                        bandwidth_list_aux.bandwidth = (QmiNasDLBandwidth)tmp;
                    }
                    g_array_insert_val (self->arg_bandwidth_list, bandwidth_list_i, bandwidth_list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Bandwidth List' TLV", offset);
            }

            self->arg_bandwidth_list_set = TRUE;

qmi_message_nas_get_rf_band_information_output_bandwidth_list_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_EXTENDED_LIST, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_rf_band_information_output_extended_list_out;
            }
            {
                guint extended_list_i;
                guint8 extended_list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(extended_list_n_items), NULL))
                    goto qmi_message_nas_get_rf_band_information_output_extended_list_out;

                self->arg_extended_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetRfBandInformationOutputExtendedListElement),
                    (guint)extended_list_n_items);

                for (extended_list_i = 0; extended_list_i < extended_list_n_items; extended_list_i++) {
                    QmiMessageNasGetRfBandInformationOutputExtendedListElement extended_list_aux;

                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_rf_band_information_output_extended_list_out;
                        extended_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                    }
                    {
                        guint16 tmp;

                        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                            goto qmi_message_nas_get_rf_band_information_output_extended_list_out;
                        extended_list_aux.active_band_class = (QmiNasActiveBand)tmp;
                    }
                    if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(extended_list_aux.active_channel), NULL))
                        goto qmi_message_nas_get_rf_band_information_output_extended_list_out;
                    g_array_insert_val (self->arg_extended_list, extended_list_i, extended_list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Extended List' TLV", offset);
            }

            self->arg_extended_list_set = TRUE;

qmi_message_nas_get_rf_band_information_output_extended_list_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_LIST, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory List TLV: ");
                qmi_message_nas_get_rf_band_information_output_unref (self);
                return NULL;
            }
            {
                guint list_i;
                guint8 list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(list_n_items), error))
                    goto qmi_message_nas_get_rf_band_information_output_list_out;

                self->arg_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetRfBandInformationOutputListElement),
                    (guint)list_n_items);

                for (list_i = 0; list_i < list_n_items; list_i++) {
                    QmiMessageNasGetRfBandInformationOutputListElement list_aux;

                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, error))
                            goto qmi_message_nas_get_rf_band_information_output_list_out;
                        list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                    }
                    {
                        guint16 tmp;

                        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, error))
                            goto qmi_message_nas_get_rf_band_information_output_list_out;
                        list_aux.active_band_class = (QmiNasActiveBand)tmp;
                    }
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(list_aux.active_channel), error))
                        goto qmi_message_nas_get_rf_band_information_output_list_out;
                    g_array_insert_val (self->arg_list, list_i, list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'List' TLV", offset);
            }

            self->arg_list_set = TRUE;

qmi_message_nas_get_rf_band_information_output_list_out:
            if (!self->arg_list_set) {
                qmi_message_nas_get_rf_band_information_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_rf_band_information_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_rf_band_information_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Set System Selection Preference */


/* --- Input -- */

struct _QmiMessageNasSetSystemSelectionPreferenceInput {
    volatile gint ref_count;

    /* Extended LTE Band Preference */
    gboolean arg_extended_lte_band_preference_set;
    guint64 arg_extended_lte_band_preference_mask_low;
    guint64 arg_extended_lte_band_preference_mask_mid_low;
    guint64 arg_extended_lte_band_preference_mask_mid_high;
    guint64 arg_extended_lte_band_preference_mask_high;

    /* Voice Domain Preference */
    gboolean arg_voice_domain_preference_set;
    guint32 arg_voice_domain_preference;

    /* Usage Preference */
    gboolean arg_usage_preference_set;
    guint32 arg_usage_preference;

    /* Network Selection Registration Restriction */
    gboolean arg_network_selection_registration_restriction_set;
    guint32 arg_network_selection_registration_restriction;

    /* Acquisition Order Preference */
    gboolean arg_acquisition_order_preference_set;
    GArray *arg_acquisition_order_preference;

    /* TD SCDMA Band Preference */
    gboolean arg_td_scdma_band_preference_set;
    guint64 arg_td_scdma_band_preference;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    guint8 arg_mnc_pcs_digit_include_status;

    /* GSM WCDMA Acquisition Order Preference */
    gboolean arg_gsm_wcdma_acquisition_order_preference_set;
    guint32 arg_gsm_wcdma_acquisition_order_preference;

    /* Service Domain Preference */
    gboolean arg_service_domain_preference_set;
    guint32 arg_service_domain_preference;

    /* Change Duration */
    gboolean arg_change_duration_set;
    guint8 arg_change_duration;

    /* Network Selection Preference */
    gboolean arg_network_selection_preference_set;
    guint8 arg_network_selection_preference_mode;
    guint16 arg_network_selection_preference_mcc;
    guint16 arg_network_selection_preference_mnc;

    /* LTE Band Preference */
    gboolean arg_lte_band_preference_set;
    guint64 arg_lte_band_preference;

    /* Roaming Preference */
    gboolean arg_roaming_preference_set;
    guint16 arg_roaming_preference;

    /* CDMA PRL Preference */
    gboolean arg_cdma_prl_preference_set;
    guint16 arg_cdma_prl_preference;

    /* Band Preference */
    gboolean arg_band_preference_set;
    guint64 arg_band_preference;

    /* Mode Preference */
    gboolean arg_mode_preference_set;
    guint16 arg_mode_preference;

    /* Emergency mode */
    gboolean arg_emergency_mode_set;
    guint8 arg_emergency_mode;
};

#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EXTENDED_LTE_BAND_PREFERENCE 0x24
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_VOICE_DOMAIN_PREFERENCE 0x23
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_USAGE_PREFERENCE 0x21
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION 0x1F
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ACQUISITION_ORDER_PREFERENCE 0x1E
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_TD_SCDMA_BAND_PREFERENCE 0x1D
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x1A
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE 0x19
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_SERVICE_DOMAIN_PREFERENCE 0x18
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CHANGE_DURATION 0x17
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_PREFERENCE 0x16
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_LTE_BAND_PREFERENCE 0x15
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ROAMING_PREFERENCE 0x14
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CDMA_PRL_PREFERENCE 0x13
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_BAND_PREFERENCE 0x12
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MODE_PREFERENCE 0x11
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EMERGENCY_MODE 0x10

gboolean
qmi_message_nas_set_system_selection_preference_input_get_extended_lte_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    guint64 *value_extended_lte_band_preference_mask_low,
    guint64 *value_extended_lte_band_preference_mask_mid_low,
    guint64 *value_extended_lte_band_preference_mask_mid_high,
    guint64 *value_extended_lte_band_preference_mask_high,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_extended_lte_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Extended LTE Band Preference' was not found in the message");
        return FALSE;
    }

    if (value_extended_lte_band_preference_mask_low)
        *value_extended_lte_band_preference_mask_low = self->arg_extended_lte_band_preference_mask_low;
    if (value_extended_lte_band_preference_mask_mid_low)
        *value_extended_lte_band_preference_mask_mid_low = self->arg_extended_lte_band_preference_mask_mid_low;
    if (value_extended_lte_band_preference_mask_mid_high)
        *value_extended_lte_band_preference_mask_mid_high = self->arg_extended_lte_band_preference_mask_mid_high;
    if (value_extended_lte_band_preference_mask_high)
        *value_extended_lte_band_preference_mask_high = self->arg_extended_lte_band_preference_mask_high;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_extended_lte_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    guint64 value_extended_lte_band_preference_mask_low,
    guint64 value_extended_lte_band_preference_mask_mid_low,
    guint64 value_extended_lte_band_preference_mask_mid_high,
    guint64 value_extended_lte_band_preference_mask_high,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_extended_lte_band_preference_mask_low = value_extended_lte_band_preference_mask_low;
    self->arg_extended_lte_band_preference_mask_mid_low = value_extended_lte_band_preference_mask_mid_low;
    self->arg_extended_lte_band_preference_mask_mid_high = value_extended_lte_band_preference_mask_mid_high;
    self->arg_extended_lte_band_preference_mask_high = value_extended_lte_band_preference_mask_high;
    self->arg_extended_lte_band_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_voice_domain_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasVoiceDomainPreference *value_voice_domain_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_voice_domain_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Voice Domain Preference' was not found in the message");
        return FALSE;
    }

    if (value_voice_domain_preference)
        *value_voice_domain_preference = (QmiNasVoiceDomainPreference)(self->arg_voice_domain_preference);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_voice_domain_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasVoiceDomainPreference value_voice_domain_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_voice_domain_preference = (guint32)(value_voice_domain_preference);
    self->arg_voice_domain_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_usage_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasUsagePreference *value_usage_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_usage_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Usage Preference' was not found in the message");
        return FALSE;
    }

    if (value_usage_preference)
        *value_usage_preference = (QmiNasUsagePreference)(self->arg_usage_preference);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_usage_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasUsagePreference value_usage_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_usage_preference = (guint32)(value_usage_preference);
    self->arg_usage_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_network_selection_registration_restriction (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasNetworkSelectionRegistrationRestriction *value_network_selection_registration_restriction,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_selection_registration_restriction_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Selection Registration Restriction' was not found in the message");
        return FALSE;
    }

    if (value_network_selection_registration_restriction)
        *value_network_selection_registration_restriction = (QmiNasNetworkSelectionRegistrationRestriction)(self->arg_network_selection_registration_restriction);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_network_selection_registration_restriction (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasNetworkSelectionRegistrationRestriction value_network_selection_registration_restriction,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_network_selection_registration_restriction = (guint32)(value_network_selection_registration_restriction);
    self->arg_network_selection_registration_restriction_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_acquisition_order_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    GArray **value_acquisition_order_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_acquisition_order_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Acquisition Order Preference' was not found in the message");
        return FALSE;
    }

    if (value_acquisition_order_preference)
        *value_acquisition_order_preference = self->arg_acquisition_order_preference;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_acquisition_order_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    GArray *value_acquisition_order_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_acquisition_order_preference)
        g_array_unref (self->arg_acquisition_order_preference);
    self->arg_acquisition_order_preference = g_array_ref (value_acquisition_order_preference);
    self->arg_acquisition_order_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_td_scdma_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasTdScdmaBandPreference *value_td_scdma_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scdma_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCDMA Band Preference' was not found in the message");
        return FALSE;
    }

    if (value_td_scdma_band_preference)
        *value_td_scdma_band_preference = (QmiNasTdScdmaBandPreference)(self->arg_td_scdma_band_preference);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_td_scdma_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasTdScdmaBandPreference value_td_scdma_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_td_scdma_band_preference = (guint64)(value_td_scdma_band_preference);
    self->arg_td_scdma_band_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_mnc_pcs_digit_include_status (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    gboolean *value_mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (value_mnc_pcs_digit_include_status)
        *value_mnc_pcs_digit_include_status = (gboolean)(self->arg_mnc_pcs_digit_include_status);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_mnc_pcs_digit_include_status (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    gboolean value_mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_mnc_pcs_digit_include_status = (guint8)(value_mnc_pcs_digit_include_status);
    self->arg_mnc_pcs_digit_include_status_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_gsm_wcdma_acquisition_order_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasGsmWcdmaAcquisitionOrderPreference *value_gsm_wcdma_acquisition_order_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_wcdma_acquisition_order_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM WCDMA Acquisition Order Preference' was not found in the message");
        return FALSE;
    }

    if (value_gsm_wcdma_acquisition_order_preference)
        *value_gsm_wcdma_acquisition_order_preference = (QmiNasGsmWcdmaAcquisitionOrderPreference)(self->arg_gsm_wcdma_acquisition_order_preference);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_gsm_wcdma_acquisition_order_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasGsmWcdmaAcquisitionOrderPreference value_gsm_wcdma_acquisition_order_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_gsm_wcdma_acquisition_order_preference = (guint32)(value_gsm_wcdma_acquisition_order_preference);
    self->arg_gsm_wcdma_acquisition_order_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_service_domain_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasServiceDomainPreference *value_service_domain_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_service_domain_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Service Domain Preference' was not found in the message");
        return FALSE;
    }

    if (value_service_domain_preference)
        *value_service_domain_preference = (QmiNasServiceDomainPreference)(self->arg_service_domain_preference);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_service_domain_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasServiceDomainPreference value_service_domain_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_service_domain_preference = (guint32)(value_service_domain_preference);
    self->arg_service_domain_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_change_duration (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasChangeDuration *value_change_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_change_duration_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Change Duration' was not found in the message");
        return FALSE;
    }

    if (value_change_duration)
        *value_change_duration = (QmiNasChangeDuration)(self->arg_change_duration);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_change_duration (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasChangeDuration value_change_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_change_duration = (guint8)(value_change_duration);
    self->arg_change_duration_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_network_selection_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasNetworkSelectionPreference *value_network_selection_preference_mode,
    guint16 *value_network_selection_preference_mcc,
    guint16 *value_network_selection_preference_mnc,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_selection_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Selection Preference' was not found in the message");
        return FALSE;
    }

    if (value_network_selection_preference_mode)
        *value_network_selection_preference_mode = (QmiNasNetworkSelectionPreference)(self->arg_network_selection_preference_mode);
    if (value_network_selection_preference_mcc)
        *value_network_selection_preference_mcc = self->arg_network_selection_preference_mcc;
    if (value_network_selection_preference_mnc)
        *value_network_selection_preference_mnc = self->arg_network_selection_preference_mnc;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_network_selection_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasNetworkSelectionPreference value_network_selection_preference_mode,
    guint16 value_network_selection_preference_mcc,
    guint16 value_network_selection_preference_mnc,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_network_selection_preference_mode = (guint8)(value_network_selection_preference_mode);
    self->arg_network_selection_preference_mcc = value_network_selection_preference_mcc;
    self->arg_network_selection_preference_mnc = value_network_selection_preference_mnc;
    self->arg_network_selection_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_lte_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasLteBandPreference *value_lte_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Band Preference' was not found in the message");
        return FALSE;
    }

    if (value_lte_band_preference)
        *value_lte_band_preference = (QmiNasLteBandPreference)(self->arg_lte_band_preference);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_lte_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasLteBandPreference value_lte_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_lte_band_preference = (guint64)(value_lte_band_preference);
    self->arg_lte_band_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_roaming_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasRoamingPreference *value_roaming_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Preference' was not found in the message");
        return FALSE;
    }

    if (value_roaming_preference)
        *value_roaming_preference = (QmiNasRoamingPreference)(self->arg_roaming_preference);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_roaming_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasRoamingPreference value_roaming_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_roaming_preference = (guint16)(value_roaming_preference);
    self->arg_roaming_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_cdma_prl_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasCdmaPrlPreference *value_cdma_prl_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_prl_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA PRL Preference' was not found in the message");
        return FALSE;
    }

    if (value_cdma_prl_preference)
        *value_cdma_prl_preference = (QmiNasCdmaPrlPreference)(self->arg_cdma_prl_preference);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_cdma_prl_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasCdmaPrlPreference value_cdma_prl_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_cdma_prl_preference = (guint16)(value_cdma_prl_preference);
    self->arg_cdma_prl_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasBandPreference *value_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Band Preference' was not found in the message");
        return FALSE;
    }

    if (value_band_preference)
        *value_band_preference = (QmiNasBandPreference)(self->arg_band_preference);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasBandPreference value_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_band_preference = (guint64)(value_band_preference);
    self->arg_band_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_mode_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasRatModePreference *value_mode_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mode_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Mode Preference' was not found in the message");
        return FALSE;
    }

    if (value_mode_preference)
        *value_mode_preference = (QmiNasRatModePreference)(self->arg_mode_preference);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_mode_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasRatModePreference value_mode_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_mode_preference = (guint16)(value_mode_preference);
    self->arg_mode_preference_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_get_emergency_mode (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    gboolean *value_emergency_mode,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_emergency_mode_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Emergency mode' was not found in the message");
        return FALSE;
    }

    if (value_emergency_mode)
        *value_emergency_mode = (gboolean)(self->arg_emergency_mode);

    return TRUE;
}

gboolean
qmi_message_nas_set_system_selection_preference_input_set_emergency_mode (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    gboolean value_emergency_mode,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_emergency_mode = (guint8)(value_emergency_mode);
    self->arg_emergency_mode_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_set_system_selection_preference_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetSystemSelectionPreferenceInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_system_selection_preference_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_system_selection_preference_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasSetSystemSelectionPreferenceInput *
qmi_message_nas_set_system_selection_preference_input_ref (QmiMessageNasSetSystemSelectionPreferenceInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_set_system_selection_preference_input_unref (QmiMessageNasSetSystemSelectionPreferenceInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_acquisition_order_preference)
            g_array_unref (self->arg_acquisition_order_preference);
        g_slice_free (QmiMessageNasSetSystemSelectionPreferenceInput, self);
    }
}

QmiMessageNasSetSystemSelectionPreferenceInput *
qmi_message_nas_set_system_selection_preference_input_new (void)
{
    QmiMessageNasSetSystemSelectionPreferenceInput *self;

    self = g_slice_new0 (QmiMessageNasSetSystemSelectionPreferenceInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_set_system_selection_preference_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasSetSystemSelectionPreferenceInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return g_steal_pointer (&self);

    /* Try to add the 'Extended LTE Band Preference' TLV */
    if (input->arg_extended_lte_band_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EXTENDED_LTE_BAND_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Extended LTE Band Preference': ");
            return NULL;
        }

        /* Write the guint64 variable to the buffer */
        if (!qmi_message_tlv_write_guint64 (self, QMI_ENDIAN_LITTLE, input->arg_extended_lte_band_preference_mask_low, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'Extended LTE Band Preference': ");
            return NULL;
        }
        /* Write the guint64 variable to the buffer */
        if (!qmi_message_tlv_write_guint64 (self, QMI_ENDIAN_LITTLE, input->arg_extended_lte_band_preference_mask_mid_low, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'Extended LTE Band Preference': ");
            return NULL;
        }
        /* Write the guint64 variable to the buffer */
        if (!qmi_message_tlv_write_guint64 (self, QMI_ENDIAN_LITTLE, input->arg_extended_lte_band_preference_mask_mid_high, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'Extended LTE Band Preference': ");
            return NULL;
        }
        /* Write the guint64 variable to the buffer */
        if (!qmi_message_tlv_write_guint64 (self, QMI_ENDIAN_LITTLE, input->arg_extended_lte_band_preference_mask_high, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'Extended LTE Band Preference': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Extended LTE Band Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'Voice Domain Preference' TLV */
    if (input->arg_voice_domain_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_VOICE_DOMAIN_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Voice Domain Preference': ");
            return NULL;
        }

        {
            guint32 tmp;

            tmp = (guint32) input->arg_voice_domain_preference;
            /* Write the guint32 variable to the buffer */
            if (!qmi_message_tlv_write_guint32 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Voice Domain Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Voice Domain Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'Usage Preference' TLV */
    if (input->arg_usage_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_USAGE_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Usage Preference': ");
            return NULL;
        }

        {
            guint32 tmp;

            tmp = (guint32) input->arg_usage_preference;
            /* Write the guint32 variable to the buffer */
            if (!qmi_message_tlv_write_guint32 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Usage Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Usage Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'Network Selection Registration Restriction' TLV */
    if (input->arg_network_selection_registration_restriction_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Network Selection Registration Restriction': ");
            return NULL;
        }

        {
            guint32 tmp;

            tmp = (guint32) input->arg_network_selection_registration_restriction;
            /* Write the guint32 variable to the buffer */
            if (!qmi_message_tlv_write_guint32 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Network Selection Registration Restriction': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Network Selection Registration Restriction': ");
            return NULL;
        }
    }

    /* Try to add the 'Acquisition Order Preference' TLV */
    if (input->arg_acquisition_order_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ACQUISITION_ORDER_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Acquisition Order Preference': ");
            return NULL;
        }

        {
            guint acquisition_order_preference_i;
            guint8 acquisition_order_preference_n_items;

            /* Write the number of items in the array first */
            acquisition_order_preference_n_items = (guint8) input->arg_acquisition_order_preference->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, acquisition_order_preference_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'Acquisition Order Preference': ");
                return NULL;
            }

            for (acquisition_order_preference_i = 0; acquisition_order_preference_i < input->arg_acquisition_order_preference->len; acquisition_order_preference_i++) {
                {
                    gint8 tmp;

                    tmp = (gint8) g_array_index (input->arg_acquisition_order_preference, QmiNasRadioInterface,acquisition_order_preference_i);
                    /* Write the gint8 variable to the buffer */
                    if (!qmi_message_tlv_write_gint8 (self, tmp, error)) {
                        g_prefix_error (error, "Cannot write enum in TLV 'Acquisition Order Preference': ");
                        return NULL;
                    }
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Acquisition Order Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'TD SCDMA Band Preference' TLV */
    if (input->arg_td_scdma_band_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_TD_SCDMA_BAND_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'TD SCDMA Band Preference': ");
            return NULL;
        }

        {
            guint64 tmp;

            tmp = (guint64) input->arg_td_scdma_band_preference;
            /* Write the guint64 variable to the buffer */
            if (!qmi_message_tlv_write_guint64 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'TD SCDMA Band Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'TD SCDMA Band Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'MNC PCS Digit Include Status' TLV */
    if (input->arg_mnc_pcs_digit_include_status_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'MNC PCS Digit Include Status': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_mnc_pcs_digit_include_status;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'MNC PCS Digit Include Status': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'MNC PCS Digit Include Status': ");
            return NULL;
        }
    }

    /* Try to add the 'GSM WCDMA Acquisition Order Preference' TLV */
    if (input->arg_gsm_wcdma_acquisition_order_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'GSM WCDMA Acquisition Order Preference': ");
            return NULL;
        }

        {
            guint32 tmp;

            tmp = (guint32) input->arg_gsm_wcdma_acquisition_order_preference;
            /* Write the guint32 variable to the buffer */
            if (!qmi_message_tlv_write_guint32 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'GSM WCDMA Acquisition Order Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'GSM WCDMA Acquisition Order Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'Service Domain Preference' TLV */
    if (input->arg_service_domain_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_SERVICE_DOMAIN_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Service Domain Preference': ");
            return NULL;
        }

        {
            guint32 tmp;

            tmp = (guint32) input->arg_service_domain_preference;
            /* Write the guint32 variable to the buffer */
            if (!qmi_message_tlv_write_guint32 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Service Domain Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Service Domain Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'Change Duration' TLV */
    if (input->arg_change_duration_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CHANGE_DURATION, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Change Duration': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_change_duration;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Change Duration': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Change Duration': ");
            return NULL;
        }
    }

    /* Try to add the 'Network Selection Preference' TLV */
    if (input->arg_network_selection_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Network Selection Preference': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_network_selection_preference_mode;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Network Selection Preference': ");
                return NULL;
            }
        }
        /* Write the guint16 variable to the buffer */
        if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, input->arg_network_selection_preference_mcc, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'Network Selection Preference': ");
            return NULL;
        }
        /* Write the guint16 variable to the buffer */
        if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, input->arg_network_selection_preference_mnc, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'Network Selection Preference': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Network Selection Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'LTE Band Preference' TLV */
    if (input->arg_lte_band_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_LTE_BAND_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'LTE Band Preference': ");
            return NULL;
        }

        {
            guint64 tmp;

            tmp = (guint64) input->arg_lte_band_preference;
            /* Write the guint64 variable to the buffer */
            if (!qmi_message_tlv_write_guint64 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'LTE Band Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'LTE Band Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'Roaming Preference' TLV */
    if (input->arg_roaming_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ROAMING_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Roaming Preference': ");
            return NULL;
        }

        {
            guint16 tmp;

            tmp = (guint16) input->arg_roaming_preference;
            /* Write the guint16 variable to the buffer */
            if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Roaming Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Roaming Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'CDMA PRL Preference' TLV */
    if (input->arg_cdma_prl_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CDMA_PRL_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'CDMA PRL Preference': ");
            return NULL;
        }

        {
            guint16 tmp;

            tmp = (guint16) input->arg_cdma_prl_preference;
            /* Write the guint16 variable to the buffer */
            if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'CDMA PRL Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'CDMA PRL Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'Band Preference' TLV */
    if (input->arg_band_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_BAND_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Band Preference': ");
            return NULL;
        }

        {
            guint64 tmp;

            tmp = (guint64) input->arg_band_preference;
            /* Write the guint64 variable to the buffer */
            if (!qmi_message_tlv_write_guint64 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Band Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Band Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'Mode Preference' TLV */
    if (input->arg_mode_preference_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MODE_PREFERENCE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Mode Preference': ");
            return NULL;
        }

        {
            guint16 tmp;

            tmp = (guint16) input->arg_mode_preference;
            /* Write the guint16 variable to the buffer */
            if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Mode Preference': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Mode Preference': ");
            return NULL;
        }
    }

    /* Try to add the 'Emergency mode' TLV */
    if (input->arg_emergency_mode_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EMERGENCY_MODE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Emergency mode': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_emergency_mode;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Emergency mode': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Emergency mode': ");
            return NULL;
        }
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasSetSystemSelectionPreferenceOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_set_system_selection_preference_output_get_result (
    QmiMessageNasSetSystemSelectionPreferenceOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_set_system_selection_preference_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetSystemSelectionPreferenceOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_system_selection_preference_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_system_selection_preference_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasSetSystemSelectionPreferenceOutput *
qmi_message_nas_set_system_selection_preference_output_ref (QmiMessageNasSetSystemSelectionPreferenceOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_set_system_selection_preference_output_unref (QmiMessageNasSetSystemSelectionPreferenceOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasSetSystemSelectionPreferenceOutput, self);
    }
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_extended_lte_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EXTENDED_LTE_BAND_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mask_low = '");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mask_mid_low = '");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mask_mid_high = '");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mask_high = '");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_voice_domain_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_VOICE_DOMAIN_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_VOICE_DOMAIN_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_voice_domain_preference_get_string ((QmiNasVoiceDomainPreference)tmp));
#elif defined  __QMI_NAS_VOICE_DOMAIN_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_voice_domain_preference_build_string_from_mask ((QmiNasVoiceDomainPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasVoiceDomainPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_usage_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_USAGE_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_USAGE_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_usage_preference_get_string ((QmiNasUsagePreference)tmp));
#elif defined  __QMI_NAS_USAGE_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_usage_preference_build_string_from_mask ((QmiNasUsagePreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasUsagePreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_network_selection_registration_restriction_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_selection_registration_restriction_get_string ((QmiNasNetworkSelectionRegistrationRestriction)tmp));
#elif defined  __QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_selection_registration_restriction_build_string_from_mask ((QmiNasNetworkSelectionRegistrationRestriction)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkSelectionRegistrationRestriction
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_acquisition_order_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ACQUISITION_ORDER_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint acquisition_order_preference_i;
        guint8 acquisition_order_preference_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(acquisition_order_preference_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (acquisition_order_preference_i = 0; acquisition_order_preference_i < acquisition_order_preference_n_items; acquisition_order_preference_i++) {
            g_string_append_printf (printable, " [%u] = '", acquisition_order_preference_i);

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_td_scdma_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_TD_SCDMA_BAND_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_td_scdma_band_preference_get_string ((QmiNasTdScdmaBandPreference)tmp));
#elif defined  __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_td_scdma_band_preference_build_string_from_mask ((QmiNasTdScdmaBandPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasTdScdmaBandPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_gsm_wcdma_acquisition_order_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_gsm_wcdma_acquisition_order_preference_get_string ((QmiNasGsmWcdmaAcquisitionOrderPreference)tmp));
#elif defined  __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_gsm_wcdma_acquisition_order_preference_build_string_from_mask ((QmiNasGsmWcdmaAcquisitionOrderPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasGsmWcdmaAcquisitionOrderPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_service_domain_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_SERVICE_DOMAIN_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_domain_preference_get_string ((QmiNasServiceDomainPreference)tmp));
#elif defined  __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_domain_preference_build_string_from_mask ((QmiNasServiceDomainPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceDomainPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_change_duration_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CHANGE_DURATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CHANGE_DURATION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_change_duration_get_string ((QmiNasChangeDuration)tmp));
#elif defined  __QMI_NAS_CHANGE_DURATION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_change_duration_build_string_from_mask ((QmiNasChangeDuration)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasChangeDuration
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_network_selection_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mode = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_selection_preference_get_string ((QmiNasNetworkSelectionPreference)tmp));
#elif defined  __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_selection_preference_build_string_from_mask ((QmiNasNetworkSelectionPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkSelectionPreference
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_lte_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_LTE_BAND_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_LTE_BAND_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_lte_band_preference_get_string ((QmiNasLteBandPreference)tmp));
#elif defined  __QMI_NAS_LTE_BAND_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_lte_band_preference_build_string_from_mask ((QmiNasLteBandPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasLteBandPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_roaming_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ROAMING_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_preference_get_string ((QmiNasRoamingPreference)tmp));
#elif defined  __QMI_NAS_ROAMING_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_preference_build_string_from_mask ((QmiNasRoamingPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_cdma_prl_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CDMA_PRL_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CDMA_PRL_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_cdma_prl_preference_get_string ((QmiNasCdmaPrlPreference)tmp));
#elif defined  __QMI_NAS_CDMA_PRL_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_cdma_prl_preference_build_string_from_mask ((QmiNasCdmaPrlPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCdmaPrlPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_BAND_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_BAND_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_band_preference_get_string ((QmiNasBandPreference)tmp));
#elif defined  __QMI_NAS_BAND_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_band_preference_build_string_from_mask ((QmiNasBandPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasBandPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_mode_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MODE_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RAT_MODE_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_rat_mode_preference_get_string ((QmiNasRatModePreference)tmp));
#elif defined  __QMI_NAS_RAT_MODE_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_rat_mode_preference_build_string_from_mask ((QmiNasRatModePreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRatModePreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_set_system_selection_preference_input_emergency_mode_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EMERGENCY_MODE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_set_system_selection_preference_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_system_selection_preference_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_system_selection_preference_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EXTENDED_LTE_BAND_PREFERENCE:
            tlv_type_str = "Extended LTE Band Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_extended_lte_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_VOICE_DOMAIN_PREFERENCE:
            tlv_type_str = "Voice Domain Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_voice_domain_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_USAGE_PREFERENCE:
            tlv_type_str = "Usage Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_usage_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION:
            tlv_type_str = "Network Selection Registration Restriction";
            translated_value = qmi_message_nas_set_system_selection_preference_input_network_selection_registration_restriction_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ACQUISITION_ORDER_PREFERENCE:
            tlv_type_str = "Acquisition Order Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_acquisition_order_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_TD_SCDMA_BAND_PREFERENCE:
            tlv_type_str = "TD SCDMA Band Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_td_scdma_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_message_nas_set_system_selection_preference_input_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE:
            tlv_type_str = "GSM WCDMA Acquisition Order Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_gsm_wcdma_acquisition_order_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_SERVICE_DOMAIN_PREFERENCE:
            tlv_type_str = "Service Domain Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_service_domain_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CHANGE_DURATION:
            tlv_type_str = "Change Duration";
            translated_value = qmi_message_nas_set_system_selection_preference_input_change_duration_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_PREFERENCE:
            tlv_type_str = "Network Selection Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_network_selection_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_LTE_BAND_PREFERENCE:
            tlv_type_str = "LTE Band Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_lte_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ROAMING_PREFERENCE:
            tlv_type_str = "Roaming Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_roaming_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CDMA_PRL_PREFERENCE:
            tlv_type_str = "CDMA PRL Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_cdma_prl_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_BAND_PREFERENCE:
            tlv_type_str = "Band Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MODE_PREFERENCE:
            tlv_type_str = "Mode Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_mode_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EMERGENCY_MODE:
            tlv_type_str = "Emergency mode";
            translated_value = qmi_message_nas_set_system_selection_preference_input_emergency_mode_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_set_system_selection_preference_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set System Selection Preference\" (0x0033)\n",
                            line_prefix);

    {
        struct message_set_system_selection_preference_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_system_selection_preference_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasSetSystemSelectionPreferenceOutput *
__qmi_message_nas_set_system_selection_preference_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasSetSystemSelectionPreferenceOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE);

    self = g_slice_new0 (QmiMessageNasSetSystemSelectionPreferenceOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_set_system_selection_preference_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_set_system_selection_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get System Selection Preference */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_system_selection_preference_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetSystemSelectionPreferenceOutput {
    volatile gint ref_count;

    /* Extended LTE Band Preference */
    gboolean arg_extended_lte_band_preference_set;
    guint64 arg_extended_lte_band_preference_mask_low;
    guint64 arg_extended_lte_band_preference_mask_mid_low;
    guint64 arg_extended_lte_band_preference_mask_mid_high;
    guint64 arg_extended_lte_band_preference_mask_high;

    /* Disabled Modes */
    gboolean arg_disabled_modes_set;
    guint16 arg_disabled_modes;

    /* Voice Domain Preference */
    gboolean arg_voice_domain_preference_set;
    guint32 arg_voice_domain_preference;

    /* Usage Preference */
    gboolean arg_usage_preference_set;
    guint32 arg_usage_preference;

    /* Network Selection Registration Restriction */
    gboolean arg_network_selection_registration_restriction_set;
    guint32 arg_network_selection_registration_restriction;

    /* Manual Network Selection */
    gboolean arg_manual_network_selection_set;
    guint16 arg_manual_network_selection_mcc;
    guint16 arg_manual_network_selection_mnc;
    guint8 arg_manual_network_selection_includes_pcs_digit;

    /* Acquisition Order Preference */
    gboolean arg_acquisition_order_preference_set;
    GArray *arg_acquisition_order_preference;

    /* TD SCDMA Band Preference */
    gboolean arg_td_scdma_band_preference_set;
    guint64 arg_td_scdma_band_preference;

    /* GSM WCDMA Acquisition Order Preference */
    gboolean arg_gsm_wcdma_acquisition_order_preference_set;
    guint32 arg_gsm_wcdma_acquisition_order_preference;

    /* Service Domain Preference */
    gboolean arg_service_domain_preference_set;
    guint32 arg_service_domain_preference;

    /* Network Selection Preference */
    gboolean arg_network_selection_preference_set;
    guint8 arg_network_selection_preference;

    /* LTE Band Preference */
    gboolean arg_lte_band_preference_set;
    guint64 arg_lte_band_preference;

    /* Roaming Preference */
    gboolean arg_roaming_preference_set;
    guint16 arg_roaming_preference;

    /* CDMA PRL Preference */
    gboolean arg_cdma_prl_preference_set;
    guint16 arg_cdma_prl_preference;

    /* Band Preference */
    gboolean arg_band_preference_set;
    guint64 arg_band_preference;

    /* Mode Preference */
    gboolean arg_mode_preference_set;
    guint16 arg_mode_preference;

    /* Emergency mode */
    gboolean arg_emergency_mode_set;
    guint8 arg_emergency_mode;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EXTENDED_LTE_BAND_PREFERENCE 0x23
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_DISABLED_MODES 0x22
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_VOICE_DOMAIN_PREFERENCE 0x20
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_USAGE_PREFERENCE 0x1F
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION 0x1D
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MANUAL_NETWORK_SELECTION 0x1B
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ACQUISITION_ORDER_PREFERENCE 0x1C
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_TD_SCDMA_BAND_PREFERENCE 0x1A
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE 0x19
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_SERVICE_DOMAIN_PREFERENCE 0x18
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_PREFERENCE 0x16
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_LTE_BAND_PREFERENCE 0x15
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ROAMING_PREFERENCE 0x14
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_CDMA_PRL_PREFERENCE 0x13
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_BAND_PREFERENCE 0x12
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MODE_PREFERENCE 0x11
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EMERGENCY_MODE 0x10
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_get_system_selection_preference_output_get_extended_lte_band_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    guint64 *value_extended_lte_band_preference_mask_low,
    guint64 *value_extended_lte_band_preference_mask_mid_low,
    guint64 *value_extended_lte_band_preference_mask_mid_high,
    guint64 *value_extended_lte_band_preference_mask_high,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_extended_lte_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Extended LTE Band Preference' was not found in the message");
        return FALSE;
    }

    if (value_extended_lte_band_preference_mask_low)
        *value_extended_lte_band_preference_mask_low = self->arg_extended_lte_band_preference_mask_low;
    if (value_extended_lte_band_preference_mask_mid_low)
        *value_extended_lte_band_preference_mask_mid_low = self->arg_extended_lte_band_preference_mask_mid_low;
    if (value_extended_lte_band_preference_mask_mid_high)
        *value_extended_lte_band_preference_mask_mid_high = self->arg_extended_lte_band_preference_mask_mid_high;
    if (value_extended_lte_band_preference_mask_high)
        *value_extended_lte_band_preference_mask_high = self->arg_extended_lte_band_preference_mask_high;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_disabled_modes (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasRatModePreference *value_disabled_modes,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_disabled_modes_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Disabled Modes' was not found in the message");
        return FALSE;
    }

    if (value_disabled_modes)
        *value_disabled_modes = (QmiNasRatModePreference)(self->arg_disabled_modes);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_voice_domain_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasVoiceDomainPreference *value_voice_domain_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_voice_domain_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Voice Domain Preference' was not found in the message");
        return FALSE;
    }

    if (value_voice_domain_preference)
        *value_voice_domain_preference = (QmiNasVoiceDomainPreference)(self->arg_voice_domain_preference);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_usage_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasUsagePreference *value_usage_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_usage_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Usage Preference' was not found in the message");
        return FALSE;
    }

    if (value_usage_preference)
        *value_usage_preference = (QmiNasUsagePreference)(self->arg_usage_preference);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_network_selection_registration_restriction (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasNetworkSelectionRegistrationRestriction *value_network_selection_registration_restriction,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_selection_registration_restriction_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Selection Registration Restriction' was not found in the message");
        return FALSE;
    }

    if (value_network_selection_registration_restriction)
        *value_network_selection_registration_restriction = (QmiNasNetworkSelectionRegistrationRestriction)(self->arg_network_selection_registration_restriction);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_manual_network_selection (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    guint16 *value_manual_network_selection_mcc,
    guint16 *value_manual_network_selection_mnc,
    gboolean *value_manual_network_selection_includes_pcs_digit,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_manual_network_selection_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Manual Network Selection' was not found in the message");
        return FALSE;
    }

    if (value_manual_network_selection_mcc)
        *value_manual_network_selection_mcc = self->arg_manual_network_selection_mcc;
    if (value_manual_network_selection_mnc)
        *value_manual_network_selection_mnc = self->arg_manual_network_selection_mnc;
    if (value_manual_network_selection_includes_pcs_digit)
        *value_manual_network_selection_includes_pcs_digit = (gboolean)(self->arg_manual_network_selection_includes_pcs_digit);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_acquisition_order_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    GArray **value_acquisition_order_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_acquisition_order_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Acquisition Order Preference' was not found in the message");
        return FALSE;
    }

    if (value_acquisition_order_preference)
        *value_acquisition_order_preference = self->arg_acquisition_order_preference;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_td_scdma_band_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasTdScdmaBandPreference *value_td_scdma_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scdma_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCDMA Band Preference' was not found in the message");
        return FALSE;
    }

    if (value_td_scdma_band_preference)
        *value_td_scdma_band_preference = (QmiNasTdScdmaBandPreference)(self->arg_td_scdma_band_preference);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_gsm_wcdma_acquisition_order_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasGsmWcdmaAcquisitionOrderPreference *value_gsm_wcdma_acquisition_order_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_wcdma_acquisition_order_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM WCDMA Acquisition Order Preference' was not found in the message");
        return FALSE;
    }

    if (value_gsm_wcdma_acquisition_order_preference)
        *value_gsm_wcdma_acquisition_order_preference = (QmiNasGsmWcdmaAcquisitionOrderPreference)(self->arg_gsm_wcdma_acquisition_order_preference);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_service_domain_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasServiceDomainPreference *value_service_domain_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_service_domain_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Service Domain Preference' was not found in the message");
        return FALSE;
    }

    if (value_service_domain_preference)
        *value_service_domain_preference = (QmiNasServiceDomainPreference)(self->arg_service_domain_preference);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_network_selection_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasNetworkSelectionPreference *value_network_selection_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_selection_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Selection Preference' was not found in the message");
        return FALSE;
    }

    if (value_network_selection_preference)
        *value_network_selection_preference = (QmiNasNetworkSelectionPreference)(self->arg_network_selection_preference);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_lte_band_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasLteBandPreference *value_lte_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Band Preference' was not found in the message");
        return FALSE;
    }

    if (value_lte_band_preference)
        *value_lte_band_preference = (QmiNasLteBandPreference)(self->arg_lte_band_preference);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_roaming_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasRoamingPreference *value_roaming_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Preference' was not found in the message");
        return FALSE;
    }

    if (value_roaming_preference)
        *value_roaming_preference = (QmiNasRoamingPreference)(self->arg_roaming_preference);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_cdma_prl_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasCdmaPrlPreference *value_cdma_prl_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_prl_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA PRL Preference' was not found in the message");
        return FALSE;
    }

    if (value_cdma_prl_preference)
        *value_cdma_prl_preference = (QmiNasCdmaPrlPreference)(self->arg_cdma_prl_preference);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_band_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasBandPreference *value_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Band Preference' was not found in the message");
        return FALSE;
    }

    if (value_band_preference)
        *value_band_preference = (QmiNasBandPreference)(self->arg_band_preference);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_mode_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasRatModePreference *value_mode_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mode_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Mode Preference' was not found in the message");
        return FALSE;
    }

    if (value_mode_preference)
        *value_mode_preference = (QmiNasRatModePreference)(self->arg_mode_preference);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_emergency_mode (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    gboolean *value_emergency_mode,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_emergency_mode_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Emergency mode' was not found in the message");
        return FALSE;
    }

    if (value_emergency_mode)
        *value_emergency_mode = (gboolean)(self->arg_emergency_mode);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_selection_preference_output_get_result (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_get_system_selection_preference_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetSystemSelectionPreferenceOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_system_selection_preference_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_system_selection_preference_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetSystemSelectionPreferenceOutput *
qmi_message_nas_get_system_selection_preference_output_ref (QmiMessageNasGetSystemSelectionPreferenceOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_system_selection_preference_output_unref (QmiMessageNasGetSystemSelectionPreferenceOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_acquisition_order_preference)
            g_array_unref (self->arg_acquisition_order_preference);
        g_slice_free (QmiMessageNasGetSystemSelectionPreferenceOutput, self);
    }
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_extended_lte_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EXTENDED_LTE_BAND_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mask_low = '");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mask_mid_low = '");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mask_mid_high = '");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mask_high = '");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_disabled_modes_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_DISABLED_MODES, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RAT_MODE_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_rat_mode_preference_get_string ((QmiNasRatModePreference)tmp));
#elif defined  __QMI_NAS_RAT_MODE_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_rat_mode_preference_build_string_from_mask ((QmiNasRatModePreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRatModePreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_voice_domain_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_VOICE_DOMAIN_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_VOICE_DOMAIN_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_voice_domain_preference_get_string ((QmiNasVoiceDomainPreference)tmp));
#elif defined  __QMI_NAS_VOICE_DOMAIN_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_voice_domain_preference_build_string_from_mask ((QmiNasVoiceDomainPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasVoiceDomainPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_usage_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_USAGE_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_USAGE_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_usage_preference_get_string ((QmiNasUsagePreference)tmp));
#elif defined  __QMI_NAS_USAGE_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_usage_preference_build_string_from_mask ((QmiNasUsagePreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasUsagePreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_network_selection_registration_restriction_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_selection_registration_restriction_get_string ((QmiNasNetworkSelectionRegistrationRestriction)tmp));
#elif defined  __QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_selection_registration_restriction_build_string_from_mask ((QmiNasNetworkSelectionRegistrationRestriction)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkSelectionRegistrationRestriction
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_manual_network_selection_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MANUAL_NETWORK_SELECTION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " includes_pcs_digit = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_acquisition_order_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ACQUISITION_ORDER_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint acquisition_order_preference_i;
        guint8 acquisition_order_preference_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(acquisition_order_preference_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (acquisition_order_preference_i = 0; acquisition_order_preference_i < acquisition_order_preference_n_items; acquisition_order_preference_i++) {
            g_string_append_printf (printable, " [%u] = '", acquisition_order_preference_i);

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_td_scdma_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_TD_SCDMA_BAND_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_td_scdma_band_preference_get_string ((QmiNasTdScdmaBandPreference)tmp));
#elif defined  __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_td_scdma_band_preference_build_string_from_mask ((QmiNasTdScdmaBandPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasTdScdmaBandPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_gsm_wcdma_acquisition_order_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_gsm_wcdma_acquisition_order_preference_get_string ((QmiNasGsmWcdmaAcquisitionOrderPreference)tmp));
#elif defined  __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_gsm_wcdma_acquisition_order_preference_build_string_from_mask ((QmiNasGsmWcdmaAcquisitionOrderPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasGsmWcdmaAcquisitionOrderPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_service_domain_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_SERVICE_DOMAIN_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_domain_preference_get_string ((QmiNasServiceDomainPreference)tmp));
#elif defined  __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_domain_preference_build_string_from_mask ((QmiNasServiceDomainPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceDomainPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_network_selection_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_selection_preference_get_string ((QmiNasNetworkSelectionPreference)tmp));
#elif defined  __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_selection_preference_build_string_from_mask ((QmiNasNetworkSelectionPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkSelectionPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_lte_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_LTE_BAND_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_LTE_BAND_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_lte_band_preference_get_string ((QmiNasLteBandPreference)tmp));
#elif defined  __QMI_NAS_LTE_BAND_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_lte_band_preference_build_string_from_mask ((QmiNasLteBandPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasLteBandPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_roaming_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ROAMING_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_preference_get_string ((QmiNasRoamingPreference)tmp));
#elif defined  __QMI_NAS_ROAMING_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_preference_build_string_from_mask ((QmiNasRoamingPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_cdma_prl_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_CDMA_PRL_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CDMA_PRL_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_cdma_prl_preference_get_string ((QmiNasCdmaPrlPreference)tmp));
#elif defined  __QMI_NAS_CDMA_PRL_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_cdma_prl_preference_build_string_from_mask ((QmiNasCdmaPrlPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCdmaPrlPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_BAND_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_BAND_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_band_preference_get_string ((QmiNasBandPreference)tmp));
#elif defined  __QMI_NAS_BAND_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_band_preference_build_string_from_mask ((QmiNasBandPreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasBandPreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_mode_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MODE_PREFERENCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RAT_MODE_PREFERENCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_rat_mode_preference_get_string ((QmiNasRatModePreference)tmp));
#elif defined  __QMI_NAS_RAT_MODE_PREFERENCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_rat_mode_preference_build_string_from_mask ((QmiNasRatModePreference)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRatModePreference
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_selection_preference_output_emergency_mode_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EMERGENCY_MODE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_system_selection_preference_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_system_selection_preference_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_system_selection_preference_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EXTENDED_LTE_BAND_PREFERENCE:
            tlv_type_str = "Extended LTE Band Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_extended_lte_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_DISABLED_MODES:
            tlv_type_str = "Disabled Modes";
            translated_value = qmi_message_nas_get_system_selection_preference_output_disabled_modes_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_VOICE_DOMAIN_PREFERENCE:
            tlv_type_str = "Voice Domain Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_voice_domain_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_USAGE_PREFERENCE:
            tlv_type_str = "Usage Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_usage_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION:
            tlv_type_str = "Network Selection Registration Restriction";
            translated_value = qmi_message_nas_get_system_selection_preference_output_network_selection_registration_restriction_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MANUAL_NETWORK_SELECTION:
            tlv_type_str = "Manual Network Selection";
            translated_value = qmi_message_nas_get_system_selection_preference_output_manual_network_selection_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ACQUISITION_ORDER_PREFERENCE:
            tlv_type_str = "Acquisition Order Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_acquisition_order_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_TD_SCDMA_BAND_PREFERENCE:
            tlv_type_str = "TD SCDMA Band Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_td_scdma_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE:
            tlv_type_str = "GSM WCDMA Acquisition Order Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_gsm_wcdma_acquisition_order_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_SERVICE_DOMAIN_PREFERENCE:
            tlv_type_str = "Service Domain Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_service_domain_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_PREFERENCE:
            tlv_type_str = "Network Selection Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_network_selection_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_LTE_BAND_PREFERENCE:
            tlv_type_str = "LTE Band Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_lte_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ROAMING_PREFERENCE:
            tlv_type_str = "Roaming Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_roaming_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_CDMA_PRL_PREFERENCE:
            tlv_type_str = "CDMA PRL Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_cdma_prl_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_BAND_PREFERENCE:
            tlv_type_str = "Band Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MODE_PREFERENCE:
            tlv_type_str = "Mode Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_mode_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EMERGENCY_MODE:
            tlv_type_str = "Emergency mode";
            translated_value = qmi_message_nas_get_system_selection_preference_output_emergency_mode_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_system_selection_preference_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get System Selection Preference\" (0x0034)\n",
                            line_prefix);

    {
        struct message_get_system_selection_preference_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_system_selection_preference_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetSystemSelectionPreferenceOutput *
__qmi_message_nas_get_system_selection_preference_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetSystemSelectionPreferenceOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE);

    self = g_slice_new0 (QmiMessageNasGetSystemSelectionPreferenceOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EXTENDED_LTE_BAND_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_extended_lte_band_preference_out;
            }
            if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_extended_lte_band_preference_mask_low), NULL))
                goto qmi_message_nas_get_system_selection_preference_output_extended_lte_band_preference_out;
            if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_extended_lte_band_preference_mask_mid_low), NULL))
                goto qmi_message_nas_get_system_selection_preference_output_extended_lte_band_preference_out;
            if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_extended_lte_band_preference_mask_mid_high), NULL))
                goto qmi_message_nas_get_system_selection_preference_output_extended_lte_band_preference_out;
            if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_extended_lte_band_preference_mask_high), NULL))
                goto qmi_message_nas_get_system_selection_preference_output_extended_lte_band_preference_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Extended LTE Band Preference' TLV", offset);
            }

            self->arg_extended_lte_band_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_extended_lte_band_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_DISABLED_MODES, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_disabled_modes_out;
            }
            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_disabled_modes_out;
                self->arg_disabled_modes = (QmiNasRatModePreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Disabled Modes' TLV", offset);
            }

            self->arg_disabled_modes_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_disabled_modes_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_VOICE_DOMAIN_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_voice_domain_preference_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_voice_domain_preference_out;
                self->arg_voice_domain_preference = (QmiNasVoiceDomainPreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Voice Domain Preference' TLV", offset);
            }

            self->arg_voice_domain_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_voice_domain_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_USAGE_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_usage_preference_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_usage_preference_out;
                self->arg_usage_preference = (QmiNasUsagePreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Usage Preference' TLV", offset);
            }

            self->arg_usage_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_usage_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_network_selection_registration_restriction_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_network_selection_registration_restriction_out;
                self->arg_network_selection_registration_restriction = (QmiNasNetworkSelectionRegistrationRestriction)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Network Selection Registration Restriction' TLV", offset);
            }

            self->arg_network_selection_registration_restriction_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_network_selection_registration_restriction_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MANUAL_NETWORK_SELECTION, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_manual_network_selection_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_manual_network_selection_mcc), NULL))
                goto qmi_message_nas_get_system_selection_preference_output_manual_network_selection_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_manual_network_selection_mnc), NULL))
                goto qmi_message_nas_get_system_selection_preference_output_manual_network_selection_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_manual_network_selection_out;
                self->arg_manual_network_selection_includes_pcs_digit = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Manual Network Selection' TLV", offset);
            }

            self->arg_manual_network_selection_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_manual_network_selection_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ACQUISITION_ORDER_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_acquisition_order_preference_out;
            }
            {
                guint acquisition_order_preference_i;
                guint8 acquisition_order_preference_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(acquisition_order_preference_n_items), NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_acquisition_order_preference_out;

                self->arg_acquisition_order_preference = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiNasRadioInterface),
                    (guint)acquisition_order_preference_n_items);

                for (acquisition_order_preference_i = 0; acquisition_order_preference_i < acquisition_order_preference_n_items; acquisition_order_preference_i++) {
                    QmiNasRadioInterface acquisition_order_preference_aux;

                    {
                        gint8 tmp;

                        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_system_selection_preference_output_acquisition_order_preference_out;
                        acquisition_order_preference_aux = (QmiNasRadioInterface)tmp;
                    }
                    g_array_insert_val (self->arg_acquisition_order_preference, acquisition_order_preference_i, acquisition_order_preference_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Acquisition Order Preference' TLV", offset);
            }

            self->arg_acquisition_order_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_acquisition_order_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_TD_SCDMA_BAND_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_td_scdma_band_preference_out;
            }
            {
                guint64 tmp;

                if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_td_scdma_band_preference_out;
                self->arg_td_scdma_band_preference = (QmiNasTdScdmaBandPreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'TD SCDMA Band Preference' TLV", offset);
            }

            self->arg_td_scdma_band_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_td_scdma_band_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_gsm_wcdma_acquisition_order_preference_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_gsm_wcdma_acquisition_order_preference_out;
                self->arg_gsm_wcdma_acquisition_order_preference = (QmiNasGsmWcdmaAcquisitionOrderPreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM WCDMA Acquisition Order Preference' TLV", offset);
            }

            self->arg_gsm_wcdma_acquisition_order_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_gsm_wcdma_acquisition_order_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_SERVICE_DOMAIN_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_service_domain_preference_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_service_domain_preference_out;
                self->arg_service_domain_preference = (QmiNasServiceDomainPreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Service Domain Preference' TLV", offset);
            }

            self->arg_service_domain_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_service_domain_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_network_selection_preference_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_network_selection_preference_out;
                self->arg_network_selection_preference = (QmiNasNetworkSelectionPreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Network Selection Preference' TLV", offset);
            }

            self->arg_network_selection_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_network_selection_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_LTE_BAND_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_lte_band_preference_out;
            }
            {
                guint64 tmp;

                if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_lte_band_preference_out;
                self->arg_lte_band_preference = (QmiNasLteBandPreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Band Preference' TLV", offset);
            }

            self->arg_lte_band_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_lte_band_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ROAMING_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_roaming_preference_out;
            }
            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_roaming_preference_out;
                self->arg_roaming_preference = (QmiNasRoamingPreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Roaming Preference' TLV", offset);
            }

            self->arg_roaming_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_roaming_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_CDMA_PRL_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_cdma_prl_preference_out;
            }
            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_cdma_prl_preference_out;
                self->arg_cdma_prl_preference = (QmiNasCdmaPrlPreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA PRL Preference' TLV", offset);
            }

            self->arg_cdma_prl_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_cdma_prl_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_BAND_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_band_preference_out;
            }
            {
                guint64 tmp;

                if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_band_preference_out;
                self->arg_band_preference = (QmiNasBandPreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Band Preference' TLV", offset);
            }

            self->arg_band_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_band_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MODE_PREFERENCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_mode_preference_out;
            }
            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_mode_preference_out;
                self->arg_mode_preference = (QmiNasRatModePreference)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Mode Preference' TLV", offset);
            }

            self->arg_mode_preference_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_mode_preference_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EMERGENCY_MODE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_selection_preference_output_emergency_mode_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_selection_preference_output_emergency_mode_out;
                self->arg_emergency_mode = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Emergency mode' TLV", offset);
            }

            self->arg_emergency_mode_set = TRUE;

qmi_message_nas_get_system_selection_preference_output_emergency_mode_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_system_selection_preference_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_system_selection_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Operator Name */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_operator_name_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_OPERATOR_NAME);

    return g_steal_pointer (&self);
}

/* --- Output -- */

static void
operator_plmn_list_qmimessagenasgetoperatornameoutputoperatorplmnlistelement_clear (QmiMessageNasGetOperatorNameOutputOperatorPlmnListElement *p)
{
    g_free ((*p).mcc);
    g_free ((*p).mnc);
}

static void
operator_plmn_name_qmimessagenasgetoperatornameoutputoperatorplmnnameelement_clear (QmiMessageNasGetOperatorNameOutputOperatorPlmnNameElement *p)
{
    if ((*p).long_name)
        g_array_unref ((*p).long_name);
    if ((*p).short_name)
        g_array_unref ((*p).short_name);
}

struct _QmiMessageNasGetOperatorNameOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Service Provider Name */
    gboolean arg_service_provider_name_set;
    guint8 arg_service_provider_name_name_display_condition;
    gchar *arg_service_provider_name_name;

    /* Operator PLMN List */
    gboolean arg_operator_plmn_list_set;
    GArray *arg_operator_plmn_list;

    /* Operator PLMN Name */
    gboolean arg_operator_plmn_name_set;
    GArray *arg_operator_plmn_name;

    /* Operator String Name */
    gboolean arg_operator_string_name_set;
    gchar *arg_operator_string_name;

    /* NITZ Information */
    gboolean arg_nitz_information_set;
    guint8 arg_nitz_information_name_encoding;
    guint8 arg_nitz_information_short_country_initials;
    guint8 arg_nitz_information_long_name_spare_bits;
    guint8 arg_nitz_information_short_name_spare_bits;
    GArray *arg_nitz_information_long_name;
    GArray *arg_nitz_information_short_name;
};

#define QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_SERVICE_PROVIDER_NAME 0x10
#define QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_LIST 0x11
#define QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_NAME 0x12
#define QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_STRING_NAME 0x13
#define QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_NITZ_INFORMATION 0x14

gboolean
qmi_message_nas_get_operator_name_output_get_result (
    QmiMessageNasGetOperatorNameOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_get_operator_name_output_get_service_provider_name (
    QmiMessageNasGetOperatorNameOutput *self,
    QmiNasNetworkNameDisplayCondition *value_service_provider_name_name_display_condition,
    const gchar **value_service_provider_name_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_service_provider_name_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Service Provider Name' was not found in the message");
        return FALSE;
    }

    if (value_service_provider_name_name_display_condition)
        *value_service_provider_name_name_display_condition = (QmiNasNetworkNameDisplayCondition)(self->arg_service_provider_name_name_display_condition);
    if (value_service_provider_name_name)
        *value_service_provider_name_name = self->arg_service_provider_name_name;

    return TRUE;
}

gboolean
qmi_message_nas_get_operator_name_output_get_operator_plmn_list (
    QmiMessageNasGetOperatorNameOutput *self,
    GArray **value_operator_plmn_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_operator_plmn_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Operator PLMN List' was not found in the message");
        return FALSE;
    }

    if (value_operator_plmn_list)
        *value_operator_plmn_list = self->arg_operator_plmn_list;

    return TRUE;
}

gboolean
qmi_message_nas_get_operator_name_output_get_operator_plmn_name (
    QmiMessageNasGetOperatorNameOutput *self,
    GArray **value_operator_plmn_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_operator_plmn_name_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Operator PLMN Name' was not found in the message");
        return FALSE;
    }

    if (value_operator_plmn_name)
        *value_operator_plmn_name = self->arg_operator_plmn_name;

    return TRUE;
}

gboolean
qmi_message_nas_get_operator_name_output_get_operator_string_name (
    QmiMessageNasGetOperatorNameOutput *self,
    const gchar **value_operator_string_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_operator_string_name_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Operator String Name' was not found in the message");
        return FALSE;
    }

    if (value_operator_string_name)
        *value_operator_string_name = self->arg_operator_string_name;

    return TRUE;
}

gboolean
qmi_message_nas_get_operator_name_output_get_nitz_information (
    QmiMessageNasGetOperatorNameOutput *self,
    QmiNasPlmnEncodingScheme *value_nitz_information_name_encoding,
    QmiNasPlmnNameCountryInitials *value_nitz_information_short_country_initials,
    QmiNasPlmnNameSpareBits *value_nitz_information_long_name_spare_bits,
    QmiNasPlmnNameSpareBits *value_nitz_information_short_name_spare_bits,
    GArray **value_nitz_information_long_name,
    GArray **value_nitz_information_short_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_nitz_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'NITZ Information' was not found in the message");
        return FALSE;
    }

    if (value_nitz_information_name_encoding)
        *value_nitz_information_name_encoding = (QmiNasPlmnEncodingScheme)(self->arg_nitz_information_name_encoding);
    if (value_nitz_information_short_country_initials)
        *value_nitz_information_short_country_initials = (QmiNasPlmnNameCountryInitials)(self->arg_nitz_information_short_country_initials);
    if (value_nitz_information_long_name_spare_bits)
        *value_nitz_information_long_name_spare_bits = (QmiNasPlmnNameSpareBits)(self->arg_nitz_information_long_name_spare_bits);
    if (value_nitz_information_short_name_spare_bits)
        *value_nitz_information_short_name_spare_bits = (QmiNasPlmnNameSpareBits)(self->arg_nitz_information_short_name_spare_bits);
    if (value_nitz_information_long_name)
        *value_nitz_information_long_name = self->arg_nitz_information_long_name;
    if (value_nitz_information_short_name)
        *value_nitz_information_short_name = self->arg_nitz_information_short_name;

    return TRUE;
}

GType
qmi_message_nas_get_operator_name_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetOperatorNameOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_operator_name_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_operator_name_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetOperatorNameOutput *
qmi_message_nas_get_operator_name_output_ref (QmiMessageNasGetOperatorNameOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_operator_name_output_unref (QmiMessageNasGetOperatorNameOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_service_provider_name_name);
        if (self->arg_operator_plmn_list)
            g_array_unref (self->arg_operator_plmn_list);
        if (self->arg_operator_plmn_name)
            g_array_unref (self->arg_operator_plmn_name);
        g_free (self->arg_operator_string_name);
        if (self->arg_nitz_information_long_name)
            g_array_unref (self->arg_nitz_information_long_name);
        if (self->arg_nitz_information_short_name)
            g_array_unref (self->arg_nitz_information_short_name);
        g_slice_free (QmiMessageNasGetOperatorNameOutput, self);
    }
}

static gchar *
qmi_message_nas_get_operator_name_output_service_provider_name_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_SERVICE_PROVIDER_NAME, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " name_display_condition = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_name_display_condition_get_string ((QmiNasNetworkNameDisplayCondition)tmp));
#elif defined  __QMI_NAS_NETWORK_NAME_DISPLAY_CONDITION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_name_display_condition_build_string_from_mask ((QmiNasNetworkNameDisplayCondition)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkNameDisplayCondition
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " name = '");

    {
        g_autofree gchar *tmp = NULL;

        if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &tmp, &error))
            goto out;
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_operator_name_output_operator_plmn_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_LIST, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint operator_plmn_list_i;
        guint16 operator_plmn_list_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(operator_plmn_list_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (operator_plmn_list_i = 0; operator_plmn_list_i < operator_plmn_list_n_items; operator_plmn_list_i++) {
            g_string_append_printf (printable, " [%u] = '", operator_plmn_list_i);
            g_string_append (printable, "[");
            g_string_append (printable, " mcc = '");

            {
                gchar tmp[4];

                if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
                    goto out;
                tmp[3] = '\0';
                g_string_append (printable, tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " mnc = '");

            {
                gchar tmp[4];

                if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
                    goto out;
                tmp[3] = '\0';
                g_string_append (printable, tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " lac1 = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " lac2 = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " plmn_name_record_identifier = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_operator_name_output_operator_plmn_name_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_NAME, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint operator_plmn_name_i;
        guint8 operator_plmn_name_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(operator_plmn_name_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (operator_plmn_name_i = 0; operator_plmn_name_i < operator_plmn_name_n_items; operator_plmn_name_i++) {
            g_string_append_printf (printable, " [%u] = '", operator_plmn_name_i);
            g_string_append (printable, "[");
            g_string_append (printable, " name_encoding = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_PLMN_ENCODING_SCHEME_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_plmn_encoding_scheme_get_string ((QmiNasPlmnEncodingScheme)tmp));
#elif defined  __QMI_NAS_PLMN_ENCODING_SCHEME_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_plmn_encoding_scheme_build_string_from_mask ((QmiNasPlmnEncodingScheme)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasPlmnEncodingScheme
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " short_country_initials = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_plmn_name_country_initials_get_string ((QmiNasPlmnNameCountryInitials)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_plmn_name_country_initials_build_string_from_mask ((QmiNasPlmnNameCountryInitials)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasPlmnNameCountryInitials
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " long_name_spare_bits = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_plmn_name_spare_bits_get_string ((QmiNasPlmnNameSpareBits)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_plmn_name_spare_bits_build_string_from_mask ((QmiNasPlmnNameSpareBits)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasPlmnNameSpareBits
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " short_name_spare_bits = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_plmn_name_spare_bits_get_string ((QmiNasPlmnNameSpareBits)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_plmn_name_spare_bits_build_string_from_mask ((QmiNasPlmnNameSpareBits)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasPlmnNameSpareBits
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " long_name = '");
            {
                guint long_name_i;
                guint8 long_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), &error))
                    goto out;

                g_string_append (printable, "{");

                for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
                    g_string_append_printf (printable, " [%u] = '", long_name_i);

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%u", (guint)tmp);
                    }
                    g_string_append (printable, " '");
                }

                g_string_append (printable, "}");
            }            g_string_append (printable, "'");
            g_string_append (printable, " short_name = '");
            {
                guint short_name_i;
                guint8 short_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), &error))
                    goto out;

                g_string_append (printable, "{");

                for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
                    g_string_append_printf (printable, " [%u] = '", short_name_i);

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%u", (guint)tmp);
                    }
                    g_string_append (printable, " '");
                }

                g_string_append (printable, "}");
            }            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_operator_name_output_operator_string_name_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_STRING_NAME, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        g_autofree gchar *tmp = NULL;

        if (!qmi_message_tlv_read_string (message, init_offset, &offset, 0, 0, &tmp, &error))
            goto out;
        g_string_append (printable, tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_operator_name_output_nitz_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_NITZ_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " name_encoding = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_ENCODING_SCHEME_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_encoding_scheme_get_string ((QmiNasPlmnEncodingScheme)tmp));
#elif defined  __QMI_NAS_PLMN_ENCODING_SCHEME_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_encoding_scheme_build_string_from_mask ((QmiNasPlmnEncodingScheme)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnEncodingScheme
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " short_country_initials = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_name_country_initials_get_string ((QmiNasPlmnNameCountryInitials)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_name_country_initials_build_string_from_mask ((QmiNasPlmnNameCountryInitials)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnNameCountryInitials
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " long_name_spare_bits = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_name_spare_bits_get_string ((QmiNasPlmnNameSpareBits)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_name_spare_bits_build_string_from_mask ((QmiNasPlmnNameSpareBits)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnNameSpareBits
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " short_name_spare_bits = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_name_spare_bits_get_string ((QmiNasPlmnNameSpareBits)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_name_spare_bits_build_string_from_mask ((QmiNasPlmnNameSpareBits)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnNameSpareBits
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " long_name = '");
    {
        guint long_name_i;
        guint8 long_name_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
            g_string_append_printf (printable, " [%u] = '", long_name_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " short_name = '");
    {
        guint short_name_i;
        guint8 short_name_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
            g_string_append_printf (printable, " [%u] = '", short_name_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_operator_name_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_operator_name_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_operator_name_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_SERVICE_PROVIDER_NAME:
            tlv_type_str = "Service Provider Name";
            translated_value = qmi_message_nas_get_operator_name_output_service_provider_name_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_LIST:
            tlv_type_str = "Operator PLMN List";
            translated_value = qmi_message_nas_get_operator_name_output_operator_plmn_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_NAME:
            tlv_type_str = "Operator PLMN Name";
            translated_value = qmi_message_nas_get_operator_name_output_operator_plmn_name_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_STRING_NAME:
            tlv_type_str = "Operator String Name";
            translated_value = qmi_message_nas_get_operator_name_output_operator_string_name_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_NITZ_INFORMATION:
            tlv_type_str = "NITZ Information";
            translated_value = qmi_message_nas_get_operator_name_output_nitz_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_operator_name_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Operator Name\" (0x0039)\n",
                            line_prefix);

    {
        struct message_get_operator_name_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_operator_name_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetOperatorNameOutput *
__qmi_message_nas_get_operator_name_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetOperatorNameOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_OPERATOR_NAME);

    self = g_slice_new0 (QmiMessageNasGetOperatorNameOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_operator_name_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_operator_name_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_SERVICE_PROVIDER_NAME, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_operator_name_output_service_provider_name_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_operator_name_output_service_provider_name_out;
                self->arg_service_provider_name_name_display_condition = (QmiNasNetworkNameDisplayCondition)tmp;
            }
            if (!qmi_message_tlv_read_string (message, init_offset, &offset, 1, 0, &(self->arg_service_provider_name_name), NULL))
                goto qmi_message_nas_get_operator_name_output_service_provider_name_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Service Provider Name' TLV", offset);
            }

            self->arg_service_provider_name_set = TRUE;

qmi_message_nas_get_operator_name_output_service_provider_name_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_LIST, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_operator_name_output_operator_plmn_list_out;
            }
            {
                guint operator_plmn_list_i;
                guint16 operator_plmn_list_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(operator_plmn_list_n_items), NULL))
                    goto qmi_message_nas_get_operator_name_output_operator_plmn_list_out;

                self->arg_operator_plmn_list = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetOperatorNameOutputOperatorPlmnListElement),
                    (guint)operator_plmn_list_n_items);

                g_array_set_clear_func (self->arg_operator_plmn_list,
                                        (GDestroyNotify)operator_plmn_list_qmimessagenasgetoperatornameoutputoperatorplmnlistelement_clear);

                for (operator_plmn_list_i = 0; operator_plmn_list_i < operator_plmn_list_n_items; operator_plmn_list_i++) {
                    QmiMessageNasGetOperatorNameOutputOperatorPlmnListElement operator_plmn_list_aux;

                    operator_plmn_list_aux.mcc = g_malloc (4);
                    if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &operator_plmn_list_aux.mcc[0], NULL)) {
                        g_free (operator_plmn_list_aux.mcc);
                        operator_plmn_list_aux.mcc = NULL;
                        goto qmi_message_nas_get_operator_name_output_operator_plmn_list_out;
                    }
                    operator_plmn_list_aux.mcc[3] = '\0';
                    operator_plmn_list_aux.mnc = g_malloc (4);
                    if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &operator_plmn_list_aux.mnc[0], NULL)) {
                        g_free (operator_plmn_list_aux.mnc);
                        operator_plmn_list_aux.mnc = NULL;
                        goto qmi_message_nas_get_operator_name_output_operator_plmn_list_out;
                    }
                    operator_plmn_list_aux.mnc[3] = '\0';
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(operator_plmn_list_aux.lac1), NULL))
                        goto qmi_message_nas_get_operator_name_output_operator_plmn_list_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(operator_plmn_list_aux.lac2), NULL))
                        goto qmi_message_nas_get_operator_name_output_operator_plmn_list_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(operator_plmn_list_aux.plmn_name_record_identifier), NULL))
                        goto qmi_message_nas_get_operator_name_output_operator_plmn_list_out;
                    g_array_insert_val (self->arg_operator_plmn_list, operator_plmn_list_i, operator_plmn_list_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Operator PLMN List' TLV", offset);
            }

            self->arg_operator_plmn_list_set = TRUE;

qmi_message_nas_get_operator_name_output_operator_plmn_list_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_PLMN_NAME, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_operator_name_output_operator_plmn_name_out;
            }
            {
                guint operator_plmn_name_i;
                guint8 operator_plmn_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(operator_plmn_name_n_items), NULL))
                    goto qmi_message_nas_get_operator_name_output_operator_plmn_name_out;

                self->arg_operator_plmn_name = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetOperatorNameOutputOperatorPlmnNameElement),
                    (guint)operator_plmn_name_n_items);

                g_array_set_clear_func (self->arg_operator_plmn_name,
                                        (GDestroyNotify)operator_plmn_name_qmimessagenasgetoperatornameoutputoperatorplmnnameelement_clear);

                for (operator_plmn_name_i = 0; operator_plmn_name_i < operator_plmn_name_n_items; operator_plmn_name_i++) {
                    QmiMessageNasGetOperatorNameOutputOperatorPlmnNameElement operator_plmn_name_aux;

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_operator_name_output_operator_plmn_name_out;
                        operator_plmn_name_aux.name_encoding = (QmiNasPlmnEncodingScheme)tmp;
                    }
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_operator_name_output_operator_plmn_name_out;
                        operator_plmn_name_aux.short_country_initials = (QmiNasPlmnNameCountryInitials)tmp;
                    }
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_operator_name_output_operator_plmn_name_out;
                        operator_plmn_name_aux.long_name_spare_bits = (QmiNasPlmnNameSpareBits)tmp;
                    }
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_operator_name_output_operator_plmn_name_out;
                        operator_plmn_name_aux.short_name_spare_bits = (QmiNasPlmnNameSpareBits)tmp;
                    }
                    {
                        guint long_name_i;
                        guint8 long_name_n_items;

                        /* Read number of items in the array */
                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), NULL))
                            goto qmi_message_nas_get_operator_name_output_operator_plmn_name_out;

                        operator_plmn_name_aux.long_name = g_array_sized_new (
                            FALSE,
                            FALSE,
                            sizeof (guint8),
                            (guint)long_name_n_items);

                        for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
                            guint8 long_name_aux;

                            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_aux), NULL))
                                goto qmi_message_nas_get_operator_name_output_operator_plmn_name_out;
                            g_array_insert_val (operator_plmn_name_aux.long_name, long_name_i, long_name_aux);
                        }
                    }
                    {
                        guint short_name_i;
                        guint8 short_name_n_items;

                        /* Read number of items in the array */
                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), NULL))
                            goto qmi_message_nas_get_operator_name_output_operator_plmn_name_out;

                        operator_plmn_name_aux.short_name = g_array_sized_new (
                            FALSE,
                            FALSE,
                            sizeof (guint8),
                            (guint)short_name_n_items);

                        for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
                            guint8 short_name_aux;

                            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_aux), NULL))
                                goto qmi_message_nas_get_operator_name_output_operator_plmn_name_out;
                            g_array_insert_val (operator_plmn_name_aux.short_name, short_name_i, short_name_aux);
                        }
                    }
                    g_array_insert_val (self->arg_operator_plmn_name, operator_plmn_name_i, operator_plmn_name_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Operator PLMN Name' TLV", offset);
            }

            self->arg_operator_plmn_name_set = TRUE;

qmi_message_nas_get_operator_name_output_operator_plmn_name_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_OPERATOR_STRING_NAME, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_operator_name_output_operator_string_name_out;
            }
            if (!qmi_message_tlv_read_string (message, init_offset, &offset, 0, 0, &(self->arg_operator_string_name), NULL))
                goto qmi_message_nas_get_operator_name_output_operator_string_name_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Operator String Name' TLV", offset);
            }

            self->arg_operator_string_name_set = TRUE;

qmi_message_nas_get_operator_name_output_operator_string_name_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_OPERATOR_NAME_OUTPUT_TLV_NITZ_INFORMATION, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_operator_name_output_nitz_information_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_operator_name_output_nitz_information_out;
                self->arg_nitz_information_name_encoding = (QmiNasPlmnEncodingScheme)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_operator_name_output_nitz_information_out;
                self->arg_nitz_information_short_country_initials = (QmiNasPlmnNameCountryInitials)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_operator_name_output_nitz_information_out;
                self->arg_nitz_information_long_name_spare_bits = (QmiNasPlmnNameSpareBits)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_operator_name_output_nitz_information_out;
                self->arg_nitz_information_short_name_spare_bits = (QmiNasPlmnNameSpareBits)tmp;
            }
            {
                guint long_name_i;
                guint8 long_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), NULL))
                    goto qmi_message_nas_get_operator_name_output_nitz_information_out;

                self->arg_nitz_information_long_name = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)long_name_n_items);

                for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
                    guint8 long_name_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_aux), NULL))
                        goto qmi_message_nas_get_operator_name_output_nitz_information_out;
                    g_array_insert_val (self->arg_nitz_information_long_name, long_name_i, long_name_aux);
                }
            }
            {
                guint short_name_i;
                guint8 short_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), NULL))
                    goto qmi_message_nas_get_operator_name_output_nitz_information_out;

                self->arg_nitz_information_short_name = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)short_name_n_items);

                for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
                    guint8 short_name_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_aux), NULL))
                        goto qmi_message_nas_get_operator_name_output_nitz_information_out;
                    g_array_insert_val (self->arg_nitz_information_short_name, short_name_i, short_name_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'NITZ Information' TLV", offset);
            }

            self->arg_nitz_information_set = TRUE;

qmi_message_nas_get_operator_name_output_nitz_information_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Cell Location Info */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_cell_location_info_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO);

    return g_steal_pointer (&self);
}

/* --- Output -- */

static void
frequency_qmimessagenasgetcelllocationinfooutputlteinfoneighboringwcdmafrequencyelement_clear (QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElement *p)
{
    if ((*p).cell)
        g_array_unref ((*p).cell);
}

static void
frequency_qmimessagenasgetcelllocationinfooutputlteinfoneighboringgsmfrequencyelement_clear (QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElement *p)
{
    if ((*p).cell)
        g_array_unref ((*p).cell);
}

static void
frequency_qmimessagenasgetcelllocationinfooutputinterfrequencylteinfofrequencyelement_clear (QmiMessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElement *p)
{
    if ((*p).cell)
        g_array_unref ((*p).cell);
}

static void
cell_qmimessagenasgetcelllocationinfooutputgeraninfov_2cellelement_clear (QmiMessageNasGetCellLocationInfoOutputGeranInfoV2CellElement *p)
{
    if ((*p).plmn)
        g_array_unref ((*p).plmn);
}

struct _QmiMessageNasGetCellLocationInfoOutput {
    volatile gint ref_count;

    /* NR5G Cell Information */
    gboolean arg_nr5g_cell_information_set;
    GArray *arg_nr5g_cell_information_plmn;
    GArray *arg_nr5g_cell_information_tracking_area_code;
    guint64 arg_nr5g_cell_information_global_cell_id;
    guint16 arg_nr5g_cell_information_physical_cell_id;
    gint16 arg_nr5g_cell_information_rsrq;
    gint16 arg_nr5g_cell_information_rsrp;
    gint16 arg_nr5g_cell_information_snr;

    /* NR5G ARFCN */
    gboolean arg_nr5g_arfcn_set;
    guint32 arg_nr5g_arfcn;

    /* LTE Info Timing Advance */
    gboolean arg_lte_info_timing_advance_set;
    guint32 arg_lte_info_timing_advance;

    /* UMTS Info Neighboring LTE */
    gboolean arg_umts_info_neighboring_lte_set;
    guint32 arg_umts_info_neighboring_lte_rrc_state;
    GArray *arg_umts_info_neighboring_lte_frequency;

    /* UMTS Cell ID */
    gboolean arg_umts_cell_id_set;
    guint32 arg_umts_cell_id;

    /* LTE Info Neighboring WCDMA */
    gboolean arg_lte_info_neighboring_wcdma_set;
    guint8 arg_lte_info_neighboring_wcdma_ue_in_idle;
    GArray *arg_lte_info_neighboring_wcdma_frequency;

    /* LTE Info Neighboring GSM */
    gboolean arg_lte_info_neighboring_gsm_set;
    guint8 arg_lte_info_neighboring_gsm_ue_in_idle;
    GArray *arg_lte_info_neighboring_gsm_frequency;

    /* Interfrequency LTE Info */
    gboolean arg_interfrequency_lte_info_set;
    guint8 arg_interfrequency_lte_info_ue_in_idle;
    GArray *arg_interfrequency_lte_info_frequency;

    /* Intrafrequency LTE Info v2 */
    gboolean arg_intrafrequency_lte_info_v2_set;
    guint8 arg_intrafrequency_lte_info_v2_ue_in_idle;
    GArray *arg_intrafrequency_lte_info_v2_plmn;
    guint16 arg_intrafrequency_lte_info_v2_tracking_area_code;
    guint32 arg_intrafrequency_lte_info_v2_global_cell_id;
    guint16 arg_intrafrequency_lte_info_v2_eutra_absolute_rf_channel_number;
    guint16 arg_intrafrequency_lte_info_v2_serving_cell_id;
    guint8 arg_intrafrequency_lte_info_v2_cell_reselection_priority;
    guint8 arg_intrafrequency_lte_info_v2_s_non_intra_search_threshold;
    guint8 arg_intrafrequency_lte_info_v2_serving_cell_low_threshold;
    guint8 arg_intrafrequency_lte_info_v2_s_intra_search_threshold;
    GArray *arg_intrafrequency_lte_info_v2_cell;

    /* CDMA Info */
    gboolean arg_cdma_info_set;
    guint16 arg_cdma_info_system_id;
    guint16 arg_cdma_info_network_id;
    guint16 arg_cdma_info_base_station_id;
    guint16 arg_cdma_info_reference_pn;
    guint32 arg_cdma_info_latitude;
    guint32 arg_cdma_info_longitude;

    /* UMTS Info v2 */
    gboolean arg_umts_info_v2_set;
    guint16 arg_umts_info_v2_cell_id;
    GArray *arg_umts_info_v2_plmn;
    guint16 arg_umts_info_v2_lac;
    guint16 arg_umts_info_v2_utra_absolute_rf_channel_number;
    guint16 arg_umts_info_v2_primary_scrambling_code;
    gint16 arg_umts_info_v2_rscp;
    gint16 arg_umts_info_v2_ecio;
    GArray *arg_umts_info_v2_cell;
    GArray *arg_umts_info_v2_neighboring_geran;

    /* GERAN Info v2 */
    gboolean arg_geran_info_v2_set;
    guint32 arg_geran_info_v2_cell_id;
    GArray *arg_geran_info_v2_plmn;
    guint16 arg_geran_info_v2_lac;
    guint16 arg_geran_info_v2_geran_absolute_rf_channel_number;
    guint8 arg_geran_info_v2_base_station_identity_code;
    guint32 arg_geran_info_v2_timing_advance;
    guint16 arg_geran_info_v2_rx_level;
    GArray *arg_geran_info_v2_cell;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_NR5G_CELL_INFORMATION 0x2F
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_NR5G_ARFCN 0x2E
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_TIMING_ADVANCE 0x1E
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_INFO_NEIGHBORING_LTE 0x18
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_CELL_ID 0x17
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_NEIGHBORING_WCDMA 0x16
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_NEIGHBORING_GSM 0x15
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_INTERFREQUENCY_LTE_INFO 0x14
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_INTRAFREQUENCY_LTE_INFO_V2 0x13
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_CDMA_INFO 0x12
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_INFO_V2 0x11
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_GERAN_INFO_V2 0x10
#define QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_get_cell_location_info_output_get_nr5g_cell_information (
    QmiMessageNasGetCellLocationInfoOutput *self,
    GArray **value_nr5g_cell_information_plmn,
    GArray **value_nr5g_cell_information_tracking_area_code,
    guint64 *value_nr5g_cell_information_global_cell_id,
    guint16 *value_nr5g_cell_information_physical_cell_id,
    gint16 *value_nr5g_cell_information_rsrq,
    gint16 *value_nr5g_cell_information_rsrp,
    gint16 *value_nr5g_cell_information_snr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_nr5g_cell_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'NR5G Cell Information' was not found in the message");
        return FALSE;
    }

    if (value_nr5g_cell_information_plmn)
        *value_nr5g_cell_information_plmn = self->arg_nr5g_cell_information_plmn;
    if (value_nr5g_cell_information_tracking_area_code)
        *value_nr5g_cell_information_tracking_area_code = self->arg_nr5g_cell_information_tracking_area_code;
    if (value_nr5g_cell_information_global_cell_id)
        *value_nr5g_cell_information_global_cell_id = self->arg_nr5g_cell_information_global_cell_id;
    if (value_nr5g_cell_information_physical_cell_id)
        *value_nr5g_cell_information_physical_cell_id = self->arg_nr5g_cell_information_physical_cell_id;
    if (value_nr5g_cell_information_rsrq)
        *value_nr5g_cell_information_rsrq = self->arg_nr5g_cell_information_rsrq;
    if (value_nr5g_cell_information_rsrp)
        *value_nr5g_cell_information_rsrp = self->arg_nr5g_cell_information_rsrp;
    if (value_nr5g_cell_information_snr)
        *value_nr5g_cell_information_snr = self->arg_nr5g_cell_information_snr;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_nr5g_arfcn (
    QmiMessageNasGetCellLocationInfoOutput *self,
    guint32 *value_nr5g_arfcn,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_nr5g_arfcn_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'NR5G ARFCN' was not found in the message");
        return FALSE;
    }

    if (value_nr5g_arfcn)
        *value_nr5g_arfcn = self->arg_nr5g_arfcn;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_lte_info_timing_advance (
    QmiMessageNasGetCellLocationInfoOutput *self,
    guint32 *value_lte_info_timing_advance,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_info_timing_advance_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Info Timing Advance' was not found in the message");
        return FALSE;
    }

    if (value_lte_info_timing_advance)
        *value_lte_info_timing_advance = self->arg_lte_info_timing_advance;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_umts_info_neighboring_lte (
    QmiMessageNasGetCellLocationInfoOutput *self,
    QmiNasWcdmaRrcState *value_umts_info_neighboring_lte_rrc_state,
    GArray **value_umts_info_neighboring_lte_frequency,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_umts_info_neighboring_lte_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'UMTS Info Neighboring LTE' was not found in the message");
        return FALSE;
    }

    if (value_umts_info_neighboring_lte_rrc_state)
        *value_umts_info_neighboring_lte_rrc_state = (QmiNasWcdmaRrcState)(self->arg_umts_info_neighboring_lte_rrc_state);
    if (value_umts_info_neighboring_lte_frequency)
        *value_umts_info_neighboring_lte_frequency = self->arg_umts_info_neighboring_lte_frequency;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_umts_cell_id (
    QmiMessageNasGetCellLocationInfoOutput *self,
    guint32 *value_umts_cell_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_umts_cell_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'UMTS Cell ID' was not found in the message");
        return FALSE;
    }

    if (value_umts_cell_id)
        *value_umts_cell_id = self->arg_umts_cell_id;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_lte_info_neighboring_wcdma (
    QmiMessageNasGetCellLocationInfoOutput *self,
    gboolean *value_lte_info_neighboring_wcdma_ue_in_idle,
    GArray **value_lte_info_neighboring_wcdma_frequency,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_info_neighboring_wcdma_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Info Neighboring WCDMA' was not found in the message");
        return FALSE;
    }

    if (value_lte_info_neighboring_wcdma_ue_in_idle)
        *value_lte_info_neighboring_wcdma_ue_in_idle = (gboolean)(self->arg_lte_info_neighboring_wcdma_ue_in_idle);
    if (value_lte_info_neighboring_wcdma_frequency)
        *value_lte_info_neighboring_wcdma_frequency = self->arg_lte_info_neighboring_wcdma_frequency;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_lte_info_neighboring_gsm (
    QmiMessageNasGetCellLocationInfoOutput *self,
    gboolean *value_lte_info_neighboring_gsm_ue_in_idle,
    GArray **value_lte_info_neighboring_gsm_frequency,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_info_neighboring_gsm_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Info Neighboring GSM' was not found in the message");
        return FALSE;
    }

    if (value_lte_info_neighboring_gsm_ue_in_idle)
        *value_lte_info_neighboring_gsm_ue_in_idle = (gboolean)(self->arg_lte_info_neighboring_gsm_ue_in_idle);
    if (value_lte_info_neighboring_gsm_frequency)
        *value_lte_info_neighboring_gsm_frequency = self->arg_lte_info_neighboring_gsm_frequency;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_interfrequency_lte_info (
    QmiMessageNasGetCellLocationInfoOutput *self,
    gboolean *value_interfrequency_lte_info_ue_in_idle,
    GArray **value_interfrequency_lte_info_frequency,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_interfrequency_lte_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Interfrequency LTE Info' was not found in the message");
        return FALSE;
    }

    if (value_interfrequency_lte_info_ue_in_idle)
        *value_interfrequency_lte_info_ue_in_idle = (gboolean)(self->arg_interfrequency_lte_info_ue_in_idle);
    if (value_interfrequency_lte_info_frequency)
        *value_interfrequency_lte_info_frequency = self->arg_interfrequency_lte_info_frequency;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_intrafrequency_lte_info_v2 (
    QmiMessageNasGetCellLocationInfoOutput *self,
    gboolean *value_intrafrequency_lte_info_v2_ue_in_idle,
    GArray **value_intrafrequency_lte_info_v2_plmn,
    guint16 *value_intrafrequency_lte_info_v2_tracking_area_code,
    guint32 *value_intrafrequency_lte_info_v2_global_cell_id,
    guint16 *value_intrafrequency_lte_info_v2_eutra_absolute_rf_channel_number,
    guint16 *value_intrafrequency_lte_info_v2_serving_cell_id,
    guint8 *value_intrafrequency_lte_info_v2_cell_reselection_priority,
    guint8 *value_intrafrequency_lte_info_v2_s_non_intra_search_threshold,
    guint8 *value_intrafrequency_lte_info_v2_serving_cell_low_threshold,
    guint8 *value_intrafrequency_lte_info_v2_s_intra_search_threshold,
    GArray **value_intrafrequency_lte_info_v2_cell,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_intrafrequency_lte_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Intrafrequency LTE Info v2' was not found in the message");
        return FALSE;
    }

    if (value_intrafrequency_lte_info_v2_ue_in_idle)
        *value_intrafrequency_lte_info_v2_ue_in_idle = (gboolean)(self->arg_intrafrequency_lte_info_v2_ue_in_idle);
    if (value_intrafrequency_lte_info_v2_plmn)
        *value_intrafrequency_lte_info_v2_plmn = self->arg_intrafrequency_lte_info_v2_plmn;
    if (value_intrafrequency_lte_info_v2_tracking_area_code)
        *value_intrafrequency_lte_info_v2_tracking_area_code = self->arg_intrafrequency_lte_info_v2_tracking_area_code;
    if (value_intrafrequency_lte_info_v2_global_cell_id)
        *value_intrafrequency_lte_info_v2_global_cell_id = self->arg_intrafrequency_lte_info_v2_global_cell_id;
    if (value_intrafrequency_lte_info_v2_eutra_absolute_rf_channel_number)
        *value_intrafrequency_lte_info_v2_eutra_absolute_rf_channel_number = self->arg_intrafrequency_lte_info_v2_eutra_absolute_rf_channel_number;
    if (value_intrafrequency_lte_info_v2_serving_cell_id)
        *value_intrafrequency_lte_info_v2_serving_cell_id = self->arg_intrafrequency_lte_info_v2_serving_cell_id;
    if (value_intrafrequency_lte_info_v2_cell_reselection_priority)
        *value_intrafrequency_lte_info_v2_cell_reselection_priority = self->arg_intrafrequency_lte_info_v2_cell_reselection_priority;
    if (value_intrafrequency_lte_info_v2_s_non_intra_search_threshold)
        *value_intrafrequency_lte_info_v2_s_non_intra_search_threshold = self->arg_intrafrequency_lte_info_v2_s_non_intra_search_threshold;
    if (value_intrafrequency_lte_info_v2_serving_cell_low_threshold)
        *value_intrafrequency_lte_info_v2_serving_cell_low_threshold = self->arg_intrafrequency_lte_info_v2_serving_cell_low_threshold;
    if (value_intrafrequency_lte_info_v2_s_intra_search_threshold)
        *value_intrafrequency_lte_info_v2_s_intra_search_threshold = self->arg_intrafrequency_lte_info_v2_s_intra_search_threshold;
    if (value_intrafrequency_lte_info_v2_cell)
        *value_intrafrequency_lte_info_v2_cell = self->arg_intrafrequency_lte_info_v2_cell;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_cdma_info (
    QmiMessageNasGetCellLocationInfoOutput *self,
    guint16 *value_cdma_info_system_id,
    guint16 *value_cdma_info_network_id,
    guint16 *value_cdma_info_base_station_id,
    guint16 *value_cdma_info_reference_pn,
    guint32 *value_cdma_info_latitude,
    guint32 *value_cdma_info_longitude,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Info' was not found in the message");
        return FALSE;
    }

    if (value_cdma_info_system_id)
        *value_cdma_info_system_id = self->arg_cdma_info_system_id;
    if (value_cdma_info_network_id)
        *value_cdma_info_network_id = self->arg_cdma_info_network_id;
    if (value_cdma_info_base_station_id)
        *value_cdma_info_base_station_id = self->arg_cdma_info_base_station_id;
    if (value_cdma_info_reference_pn)
        *value_cdma_info_reference_pn = self->arg_cdma_info_reference_pn;
    if (value_cdma_info_latitude)
        *value_cdma_info_latitude = self->arg_cdma_info_latitude;
    if (value_cdma_info_longitude)
        *value_cdma_info_longitude = self->arg_cdma_info_longitude;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_umts_info_v2 (
    QmiMessageNasGetCellLocationInfoOutput *self,
    guint16 *value_umts_info_v2_cell_id,
    GArray **value_umts_info_v2_plmn,
    guint16 *value_umts_info_v2_lac,
    guint16 *value_umts_info_v2_utra_absolute_rf_channel_number,
    guint16 *value_umts_info_v2_primary_scrambling_code,
    gint16 *value_umts_info_v2_rscp,
    gint16 *value_umts_info_v2_ecio,
    GArray **value_umts_info_v2_cell,
    GArray **value_umts_info_v2_neighboring_geran,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_umts_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'UMTS Info v2' was not found in the message");
        return FALSE;
    }

    if (value_umts_info_v2_cell_id)
        *value_umts_info_v2_cell_id = self->arg_umts_info_v2_cell_id;
    if (value_umts_info_v2_plmn)
        *value_umts_info_v2_plmn = self->arg_umts_info_v2_plmn;
    if (value_umts_info_v2_lac)
        *value_umts_info_v2_lac = self->arg_umts_info_v2_lac;
    if (value_umts_info_v2_utra_absolute_rf_channel_number)
        *value_umts_info_v2_utra_absolute_rf_channel_number = self->arg_umts_info_v2_utra_absolute_rf_channel_number;
    if (value_umts_info_v2_primary_scrambling_code)
        *value_umts_info_v2_primary_scrambling_code = self->arg_umts_info_v2_primary_scrambling_code;
    if (value_umts_info_v2_rscp)
        *value_umts_info_v2_rscp = self->arg_umts_info_v2_rscp;
    if (value_umts_info_v2_ecio)
        *value_umts_info_v2_ecio = self->arg_umts_info_v2_ecio;
    if (value_umts_info_v2_cell)
        *value_umts_info_v2_cell = self->arg_umts_info_v2_cell;
    if (value_umts_info_v2_neighboring_geran)
        *value_umts_info_v2_neighboring_geran = self->arg_umts_info_v2_neighboring_geran;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_geran_info_v2 (
    QmiMessageNasGetCellLocationInfoOutput *self,
    guint32 *value_geran_info_v2_cell_id,
    GArray **value_geran_info_v2_plmn,
    guint16 *value_geran_info_v2_lac,
    guint16 *value_geran_info_v2_geran_absolute_rf_channel_number,
    guint8 *value_geran_info_v2_base_station_identity_code,
    guint32 *value_geran_info_v2_timing_advance,
    guint16 *value_geran_info_v2_rx_level,
    GArray **value_geran_info_v2_cell,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_geran_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GERAN Info v2' was not found in the message");
        return FALSE;
    }

    if (value_geran_info_v2_cell_id)
        *value_geran_info_v2_cell_id = self->arg_geran_info_v2_cell_id;
    if (value_geran_info_v2_plmn)
        *value_geran_info_v2_plmn = self->arg_geran_info_v2_plmn;
    if (value_geran_info_v2_lac)
        *value_geran_info_v2_lac = self->arg_geran_info_v2_lac;
    if (value_geran_info_v2_geran_absolute_rf_channel_number)
        *value_geran_info_v2_geran_absolute_rf_channel_number = self->arg_geran_info_v2_geran_absolute_rf_channel_number;
    if (value_geran_info_v2_base_station_identity_code)
        *value_geran_info_v2_base_station_identity_code = self->arg_geran_info_v2_base_station_identity_code;
    if (value_geran_info_v2_timing_advance)
        *value_geran_info_v2_timing_advance = self->arg_geran_info_v2_timing_advance;
    if (value_geran_info_v2_rx_level)
        *value_geran_info_v2_rx_level = self->arg_geran_info_v2_rx_level;
    if (value_geran_info_v2_cell)
        *value_geran_info_v2_cell = self->arg_geran_info_v2_cell;

    return TRUE;
}

gboolean
qmi_message_nas_get_cell_location_info_output_get_result (
    QmiMessageNasGetCellLocationInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_get_cell_location_info_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetCellLocationInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_cell_location_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_cell_location_info_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetCellLocationInfoOutput *
qmi_message_nas_get_cell_location_info_output_ref (QmiMessageNasGetCellLocationInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_cell_location_info_output_unref (QmiMessageNasGetCellLocationInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_nr5g_cell_information_plmn)
            g_array_unref (self->arg_nr5g_cell_information_plmn);
        if (self->arg_nr5g_cell_information_tracking_area_code)
            g_array_unref (self->arg_nr5g_cell_information_tracking_area_code);
        if (self->arg_umts_info_neighboring_lte_frequency)
            g_array_unref (self->arg_umts_info_neighboring_lte_frequency);
        if (self->arg_lte_info_neighboring_wcdma_frequency)
            g_array_unref (self->arg_lte_info_neighboring_wcdma_frequency);
        if (self->arg_lte_info_neighboring_gsm_frequency)
            g_array_unref (self->arg_lte_info_neighboring_gsm_frequency);
        if (self->arg_interfrequency_lte_info_frequency)
            g_array_unref (self->arg_interfrequency_lte_info_frequency);
        if (self->arg_intrafrequency_lte_info_v2_plmn)
            g_array_unref (self->arg_intrafrequency_lte_info_v2_plmn);
        if (self->arg_intrafrequency_lte_info_v2_cell)
            g_array_unref (self->arg_intrafrequency_lte_info_v2_cell);
        if (self->arg_umts_info_v2_plmn)
            g_array_unref (self->arg_umts_info_v2_plmn);
        if (self->arg_umts_info_v2_cell)
            g_array_unref (self->arg_umts_info_v2_cell);
        if (self->arg_umts_info_v2_neighboring_geran)
            g_array_unref (self->arg_umts_info_v2_neighboring_geran);
        if (self->arg_geran_info_v2_plmn)
            g_array_unref (self->arg_geran_info_v2_plmn);
        if (self->arg_geran_info_v2_cell)
            g_array_unref (self->arg_geran_info_v2_cell);
        g_slice_free (QmiMessageNasGetCellLocationInfoOutput, self);
    }
}

static gchar *
qmi_message_nas_get_cell_location_info_output_nr5g_cell_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_NR5G_CELL_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " plmn = '");
    {
        guint plmn_i;
        guint16 plmn_n_items = 3;


        g_string_append (printable, "{");

        for (plmn_i = 0; plmn_i < plmn_n_items; plmn_i++) {
            g_string_append_printf (printable, " [%u] = '", plmn_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " tracking_area_code = '");
    {
        guint tracking_area_code_i;
        guint16 tracking_area_code_n_items = 3;


        g_string_append (printable, "{");

        for (tracking_area_code_i = 0; tracking_area_code_i < tracking_area_code_n_items; tracking_area_code_i++) {
            g_string_append_printf (printable, " [%u] = '", tracking_area_code_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " global_cell_id = '");

    {
        guint64 tmp;

        if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " physical_cell_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rsrq = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rsrp = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " snr = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_cell_location_info_output_nr5g_arfcn_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_NR5G_ARFCN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_cell_location_info_output_lte_info_timing_advance_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_TIMING_ADVANCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_INFO_NEIGHBORING_LTE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rrc_state = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_WCDMA_RRC_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_wcdma_rrc_state_get_string ((QmiNasWcdmaRrcState)tmp));
#elif defined  __QMI_NAS_WCDMA_RRC_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_wcdma_rrc_state_build_string_from_mask ((QmiNasWcdmaRrcState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasWcdmaRrcState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " frequency = '");
    {
        guint frequency_i;
        guint8 frequency_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (frequency_i = 0; frequency_i < frequency_n_items; frequency_i++) {
            g_string_append_printf (printable, " [%u] = '", frequency_i);
            g_string_append (printable, "[");
            g_string_append (printable, " eutra_absolute_rf_channel_number = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " physical_cell_id = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " rsrp = '");

            {
                gfloat tmp;

                if (!qmi_message_tlv_read_gfloat_endian (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%lf", (gdouble)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " rsrq = '");

            {
                gfloat tmp;

                if (!qmi_message_tlv_read_gfloat_endian (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%lf", (gdouble)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell_selection_rx_level = '");

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " is_tdd = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_cell_location_info_output_umts_cell_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_CELL_ID, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_NEIGHBORING_WCDMA, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " ue_in_idle = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " frequency = '");
    {
        guint frequency_i;
        guint8 frequency_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (frequency_i = 0; frequency_i < frequency_n_items; frequency_i++) {
            g_string_append_printf (printable, " [%u] = '", frequency_i);
            g_string_append (printable, "[");
            g_string_append (printable, " utra_absolute_rf_channel_number = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell_reselection_priority = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell_reselection_high_threshold = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell_reselection_low_threshold = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell = '");
            {
                guint cell_i;
                guint8 cell_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), &error))
                    goto out;

                g_string_append (printable, "{");

                for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
                    g_string_append_printf (printable, " [%u] = '", cell_i);
                    g_string_append (printable, "[");
                    g_string_append (printable, " primary_scrambling_code = '");

                    {
                        guint16 tmp;

                        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " cpich_rscp = '");

                    {
                        gint16 tmp;

                        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " cpich_ecno = '");

                    {
                        gint16 tmp;

                        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " cell_selection_rx_level = '");

                    {
                        gint16 tmp;

                        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " ]");
                    g_string_append (printable, " '");
                }

                g_string_append (printable, "}");
            }            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_NEIGHBORING_GSM, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " ue_in_idle = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " frequency = '");
    {
        guint frequency_i;
        guint8 frequency_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (frequency_i = 0; frequency_i < frequency_n_items; frequency_i++) {
            g_string_append_printf (printable, " [%u] = '", frequency_i);
            g_string_append (printable, "[");
            g_string_append (printable, " cell_reselection_priority = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell_reselection_high_threshold = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell_reselection_low_threshold = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ncc_permitted = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell = '");
            {
                guint cell_i;
                guint8 cell_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), &error))
                    goto out;

                g_string_append (printable, "{");

                for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
                    g_string_append_printf (printable, " [%u] = '", cell_i);
                    g_string_append (printable, "[");
                    g_string_append (printable, " geran_absolute_rf_channel_number = '");

                    {
                        guint16 tmp;

                        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " band_is_1900 = '");

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " cell_id_valid = '");

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " base_station_identity_code = '");

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%u", (guint)tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " rssi = '");

                    {
                        gint16 tmp;

                        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " cell_selection_rx_level = '");

                    {
                        gint16 tmp;

                        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " ]");
                    g_string_append (printable, " '");
                }

                g_string_append (printable, "}");
            }            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_INTERFREQUENCY_LTE_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " ue_in_idle = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " frequency = '");
    {
        guint frequency_i;
        guint8 frequency_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (frequency_i = 0; frequency_i < frequency_n_items; frequency_i++) {
            g_string_append_printf (printable, " [%u] = '", frequency_i);
            g_string_append (printable, "[");
            g_string_append (printable, " eutra_absolute_rf_channel_number = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell_selection_rx_level_low_threshold = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell_selection_rx_level_high_threshold = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell_reselection_priority = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell = '");
            {
                guint cell_i;
                guint8 cell_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), &error))
                    goto out;

                g_string_append (printable, "{");

                for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
                    g_string_append_printf (printable, " [%u] = '", cell_i);
                    g_string_append (printable, "[");
                    g_string_append (printable, " physical_cell_id = '");

                    {
                        guint16 tmp;

                        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " rsrq = '");

                    {
                        gint16 tmp;

                        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " rsrp = '");

                    {
                        gint16 tmp;

                        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " rssi = '");

                    {
                        gint16 tmp;

                        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " cell_selection_rx_level = '");

                    {
                        gint16 tmp;

                        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, "'");
                    g_string_append (printable, " ]");
                    g_string_append (printable, " '");
                }

                g_string_append (printable, "}");
            }            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_INTRAFREQUENCY_LTE_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " ue_in_idle = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " plmn = '");
    {
        guint plmn_i;
        guint16 plmn_n_items = 3;


        g_string_append (printable, "{");

        for (plmn_i = 0; plmn_i < plmn_n_items; plmn_i++) {
            g_string_append_printf (printable, " [%u] = '", plmn_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " tracking_area_code = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " global_cell_id = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " eutra_absolute_rf_channel_number = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " serving_cell_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_reselection_priority = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " s_non_intra_search_threshold = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " serving_cell_low_threshold = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " s_intra_search_threshold = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell = '");
    {
        guint cell_i;
        guint8 cell_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
            g_string_append_printf (printable, " [%u] = '", cell_i);
            g_string_append (printable, "[");
            g_string_append (printable, " physical_cell_id = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " rsrq = '");

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " rsrp = '");

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " rssi = '");

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell_selection_rx_level = '");

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_cell_location_info_output_cdma_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_CDMA_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " system_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " reference_pn = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " latitude = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " longitude = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_cell_location_info_output_umts_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " cell_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " plmn = '");
    {
        guint plmn_i;
        guint16 plmn_n_items = 3;


        g_string_append (printable, "{");

        for (plmn_i = 0; plmn_i < plmn_n_items; plmn_i++) {
            g_string_append_printf (printable, " [%u] = '", plmn_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " utra_absolute_rf_channel_number = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " primary_scrambling_code = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rscp = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell = '");
    {
        guint cell_i;
        guint8 cell_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
            g_string_append_printf (printable, " [%u] = '", cell_i);
            g_string_append (printable, "[");
            g_string_append (printable, " utra_absolute_rf_channel_number = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " primary_scrambling_code = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " rscp = '");

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ecio = '");

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " neighboring_geran = '");
    {
        guint neighboring_geran_i;
        guint8 neighboring_geran_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(neighboring_geran_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (neighboring_geran_i = 0; neighboring_geran_i < neighboring_geran_n_items; neighboring_geran_i++) {
            g_string_append_printf (printable, " [%u] = '", neighboring_geran_i);
            g_string_append (printable, "[");
            g_string_append (printable, " geran_absolute_rf_channel_number = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " network_color_code = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " base_station_color_code = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " rssi = '");

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_cell_location_info_output_geran_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_GERAN_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " cell_id = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " plmn = '");
    {
        guint plmn_i;
        guint16 plmn_n_items = 3;


        g_string_append (printable, "{");

        for (plmn_i = 0; plmn_i < plmn_n_items; plmn_i++) {
            g_string_append_printf (printable, " [%u] = '", plmn_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " geran_absolute_rf_channel_number = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_identity_code = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " timing_advance = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rx_level = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell = '");
    {
        guint cell_i;
        guint8 cell_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
            g_string_append_printf (printable, " [%u] = '", cell_i);
            g_string_append (printable, "[");
            g_string_append (printable, " cell_id = '");

            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " plmn = '");
            {
                guint plmn_i;
                guint16 plmn_n_items = 3;


                g_string_append (printable, "{");

                for (plmn_i = 0; plmn_i < plmn_n_items; plmn_i++) {
                    g_string_append_printf (printable, " [%u] = '", plmn_i);

                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%u", (guint)tmp);
                    }
                    g_string_append (printable, " '");
                }

                g_string_append (printable, "}");
            }            g_string_append (printable, "'");
            g_string_append (printable, " lac = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " geran_absolute_rf_channel_number = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " base_station_identity_code = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " rx_level = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_cell_location_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_cell_location_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_cell_location_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_NR5G_CELL_INFORMATION:
            tlv_type_str = "NR5G Cell Information";
            translated_value = qmi_message_nas_get_cell_location_info_output_nr5g_cell_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_NR5G_ARFCN:
            tlv_type_str = "NR5G ARFCN";
            translated_value = qmi_message_nas_get_cell_location_info_output_nr5g_arfcn_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_TIMING_ADVANCE:
            tlv_type_str = "LTE Info Timing Advance";
            translated_value = qmi_message_nas_get_cell_location_info_output_lte_info_timing_advance_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_INFO_NEIGHBORING_LTE:
            tlv_type_str = "UMTS Info Neighboring LTE";
            translated_value = qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_CELL_ID:
            tlv_type_str = "UMTS Cell ID";
            translated_value = qmi_message_nas_get_cell_location_info_output_umts_cell_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_NEIGHBORING_WCDMA:
            tlv_type_str = "LTE Info Neighboring WCDMA";
            translated_value = qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_NEIGHBORING_GSM:
            tlv_type_str = "LTE Info Neighboring GSM";
            translated_value = qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_INTERFREQUENCY_LTE_INFO:
            tlv_type_str = "Interfrequency LTE Info";
            translated_value = qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_INTRAFREQUENCY_LTE_INFO_V2:
            tlv_type_str = "Intrafrequency LTE Info v2";
            translated_value = qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_CDMA_INFO:
            tlv_type_str = "CDMA Info";
            translated_value = qmi_message_nas_get_cell_location_info_output_cdma_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_INFO_V2:
            tlv_type_str = "UMTS Info v2";
            translated_value = qmi_message_nas_get_cell_location_info_output_umts_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_GERAN_INFO_V2:
            tlv_type_str = "GERAN Info v2";
            translated_value = qmi_message_nas_get_cell_location_info_output_geran_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_cell_location_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Cell Location Info\" (0x0043)\n",
                            line_prefix);

    {
        struct message_get_cell_location_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_cell_location_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetCellLocationInfoOutput *
__qmi_message_nas_get_cell_location_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetCellLocationInfoOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO);

    self = g_slice_new0 (QmiMessageNasGetCellLocationInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_NR5G_CELL_INFORMATION, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_nr5g_cell_information_out;
            }
            {
                guint plmn_i;
                guint16 plmn_n_items = 3;


                self->arg_nr5g_cell_information_plmn = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)plmn_n_items);

                for (plmn_i = 0; plmn_i < plmn_n_items; plmn_i++) {
                    guint8 plmn_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(plmn_aux), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_nr5g_cell_information_out;
                    g_array_insert_val (self->arg_nr5g_cell_information_plmn, plmn_i, plmn_aux);
                }
            }
            {
                guint tracking_area_code_i;
                guint16 tracking_area_code_n_items = 3;


                self->arg_nr5g_cell_information_tracking_area_code = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)tracking_area_code_n_items);

                for (tracking_area_code_i = 0; tracking_area_code_i < tracking_area_code_n_items; tracking_area_code_i++) {
                    guint8 tracking_area_code_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(tracking_area_code_aux), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_nr5g_cell_information_out;
                    g_array_insert_val (self->arg_nr5g_cell_information_tracking_area_code, tracking_area_code_i, tracking_area_code_aux);
                }
            }
            if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_cell_information_global_cell_id), NULL))
                goto qmi_message_nas_get_cell_location_info_output_nr5g_cell_information_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_cell_information_physical_cell_id), NULL))
                goto qmi_message_nas_get_cell_location_info_output_nr5g_cell_information_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_cell_information_rsrq), NULL))
                goto qmi_message_nas_get_cell_location_info_output_nr5g_cell_information_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_cell_information_rsrp), NULL))
                goto qmi_message_nas_get_cell_location_info_output_nr5g_cell_information_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_cell_information_snr), NULL))
                goto qmi_message_nas_get_cell_location_info_output_nr5g_cell_information_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'NR5G Cell Information' TLV", offset);
            }

            self->arg_nr5g_cell_information_set = TRUE;

qmi_message_nas_get_cell_location_info_output_nr5g_cell_information_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_NR5G_ARFCN, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_nr5g_arfcn_out;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_arfcn), NULL))
                goto qmi_message_nas_get_cell_location_info_output_nr5g_arfcn_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'NR5G ARFCN' TLV", offset);
            }

            self->arg_nr5g_arfcn_set = TRUE;

qmi_message_nas_get_cell_location_info_output_nr5g_arfcn_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_TIMING_ADVANCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_lte_info_timing_advance_out;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_info_timing_advance), NULL))
                goto qmi_message_nas_get_cell_location_info_output_lte_info_timing_advance_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Info Timing Advance' TLV", offset);
            }

            self->arg_lte_info_timing_advance_set = TRUE;

qmi_message_nas_get_cell_location_info_output_lte_info_timing_advance_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_INFO_NEIGHBORING_LTE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_out;
                self->arg_umts_info_neighboring_lte_rrc_state = (QmiNasWcdmaRrcState)tmp;
            }
            {
                guint frequency_i;
                guint8 frequency_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_n_items), NULL))
                    goto qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_out;

                self->arg_umts_info_neighboring_lte_frequency = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetCellLocationInfoOutputUmtsInfoNeighboringLteFrequencyElement),
                    (guint)frequency_n_items);

                for (frequency_i = 0; frequency_i < frequency_n_items; frequency_i++) {
                    QmiMessageNasGetCellLocationInfoOutputUmtsInfoNeighboringLteFrequencyElement frequency_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(frequency_aux.eutra_absolute_rf_channel_number), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(frequency_aux.physical_cell_id), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_out;
                    if (!qmi_message_tlv_read_gfloat_endian (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(frequency_aux.rsrp), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_out;
                    if (!qmi_message_tlv_read_gfloat_endian (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(frequency_aux.rsrq), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_out;
                    if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(frequency_aux.cell_selection_rx_level), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_out;
                    {
                        guint8 tmp;

                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                            goto qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_out;
                        frequency_aux.is_tdd = (gboolean)tmp;
                    }
                    g_array_insert_val (self->arg_umts_info_neighboring_lte_frequency, frequency_i, frequency_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'UMTS Info Neighboring LTE' TLV", offset);
            }

            self->arg_umts_info_neighboring_lte_set = TRUE;

qmi_message_nas_get_cell_location_info_output_umts_info_neighboring_lte_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_CELL_ID, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_umts_cell_id_out;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_umts_cell_id), NULL))
                goto qmi_message_nas_get_cell_location_info_output_umts_cell_id_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'UMTS Cell ID' TLV", offset);
            }

            self->arg_umts_cell_id_set = TRUE;

qmi_message_nas_get_cell_location_info_output_umts_cell_id_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_NEIGHBORING_WCDMA, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;
                self->arg_lte_info_neighboring_wcdma_ue_in_idle = (gboolean)tmp;
            }
            {
                guint frequency_i;
                guint8 frequency_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_n_items), NULL))
                    goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;

                self->arg_lte_info_neighboring_wcdma_frequency = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElement),
                    (guint)frequency_n_items);

                g_array_set_clear_func (self->arg_lte_info_neighboring_wcdma_frequency,
                                        (GDestroyNotify)frequency_qmimessagenasgetcelllocationinfooutputlteinfoneighboringwcdmafrequencyelement_clear);

                for (frequency_i = 0; frequency_i < frequency_n_items; frequency_i++) {
                    QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElement frequency_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(frequency_aux.utra_absolute_rf_channel_number), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_aux.cell_reselection_priority), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(frequency_aux.cell_reselection_high_threshold), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(frequency_aux.cell_reselection_low_threshold), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;
                    {
                        guint cell_i;
                        guint8 cell_n_items;

                        /* Read number of items in the array */
                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), NULL))
                            goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;

                        frequency_aux.cell = g_array_sized_new (
                            FALSE,
                            FALSE,
                            sizeof (QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement),
                            (guint)cell_n_items);

                        for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
                            QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement cell_aux;

                            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.primary_scrambling_code), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;
                            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.cpich_rscp), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;
                            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.cpich_ecno), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;
                            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.cell_selection_rx_level), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out;
                            g_array_insert_val (frequency_aux.cell, cell_i, cell_aux);
                        }
                    }
                    g_array_insert_val (self->arg_lte_info_neighboring_wcdma_frequency, frequency_i, frequency_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Info Neighboring WCDMA' TLV", offset);
            }

            self->arg_lte_info_neighboring_wcdma_set = TRUE;

qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_wcdma_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_LTE_INFO_NEIGHBORING_GSM, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
                self->arg_lte_info_neighboring_gsm_ue_in_idle = (gboolean)tmp;
            }
            {
                guint frequency_i;
                guint8 frequency_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_n_items), NULL))
                    goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;

                self->arg_lte_info_neighboring_gsm_frequency = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElement),
                    (guint)frequency_n_items);

                g_array_set_clear_func (self->arg_lte_info_neighboring_gsm_frequency,
                                        (GDestroyNotify)frequency_qmimessagenasgetcelllocationinfooutputlteinfoneighboringgsmfrequencyelement_clear);

                for (frequency_i = 0; frequency_i < frequency_n_items; frequency_i++) {
                    QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElement frequency_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_aux.cell_reselection_priority), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_aux.cell_reselection_high_threshold), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_aux.cell_reselection_low_threshold), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_aux.ncc_permitted), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
                    {
                        guint cell_i;
                        guint8 cell_n_items;

                        /* Read number of items in the array */
                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), NULL))
                            goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;

                        frequency_aux.cell = g_array_sized_new (
                            FALSE,
                            FALSE,
                            sizeof (QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement),
                            (guint)cell_n_items);

                        for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
                            QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement cell_aux;

                            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.geran_absolute_rf_channel_number), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
                            {
                                guint8 tmp;

                                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                                    goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
                                cell_aux.band_is_1900 = (gboolean)tmp;
                            }
                            {
                                guint8 tmp;

                                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                                    goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
                                cell_aux.cell_id_valid = (gboolean)tmp;
                            }
                            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_aux.base_station_identity_code), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
                            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.rssi), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
                            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.cell_selection_rx_level), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out;
                            g_array_insert_val (frequency_aux.cell, cell_i, cell_aux);
                        }
                    }
                    g_array_insert_val (self->arg_lte_info_neighboring_gsm_frequency, frequency_i, frequency_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Info Neighboring GSM' TLV", offset);
            }

            self->arg_lte_info_neighboring_gsm_set = TRUE;

qmi_message_nas_get_cell_location_info_output_lte_info_neighboring_gsm_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_INTERFREQUENCY_LTE_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;
                self->arg_interfrequency_lte_info_ue_in_idle = (gboolean)tmp;
            }
            {
                guint frequency_i;
                guint8 frequency_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_n_items), NULL))
                    goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;

                self->arg_interfrequency_lte_info_frequency = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElement),
                    (guint)frequency_n_items);

                g_array_set_clear_func (self->arg_interfrequency_lte_info_frequency,
                                        (GDestroyNotify)frequency_qmimessagenasgetcelllocationinfooutputinterfrequencylteinfofrequencyelement_clear);

                for (frequency_i = 0; frequency_i < frequency_n_items; frequency_i++) {
                    QmiMessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElement frequency_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(frequency_aux.eutra_absolute_rf_channel_number), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_aux.cell_selection_rx_level_low_threshold), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_aux.cell_selection_rx_level_high_threshold), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(frequency_aux.cell_reselection_priority), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;
                    {
                        guint cell_i;
                        guint8 cell_n_items;

                        /* Read number of items in the array */
                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), NULL))
                            goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;

                        frequency_aux.cell = g_array_sized_new (
                            FALSE,
                            FALSE,
                            sizeof (QmiMessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement),
                            (guint)cell_n_items);

                        for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
                            QmiMessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement cell_aux;

                            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.physical_cell_id), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;
                            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.rsrq), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;
                            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.rsrp), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;
                            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.rssi), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;
                            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.cell_selection_rx_level), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out;
                            g_array_insert_val (frequency_aux.cell, cell_i, cell_aux);
                        }
                    }
                    g_array_insert_val (self->arg_interfrequency_lte_info_frequency, frequency_i, frequency_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Interfrequency LTE Info' TLV", offset);
            }

            self->arg_interfrequency_lte_info_set = TRUE;

qmi_message_nas_get_cell_location_info_output_interfrequency_lte_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_INTRAFREQUENCY_LTE_INFO_V2, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
                self->arg_intrafrequency_lte_info_v2_ue_in_idle = (gboolean)tmp;
            }
            {
                guint plmn_i;
                guint16 plmn_n_items = 3;


                self->arg_intrafrequency_lte_info_v2_plmn = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)plmn_n_items);

                for (plmn_i = 0; plmn_i < plmn_n_items; plmn_i++) {
                    guint8 plmn_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(plmn_aux), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
                    g_array_insert_val (self->arg_intrafrequency_lte_info_v2_plmn, plmn_i, plmn_aux);
                }
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_intrafrequency_lte_info_v2_tracking_area_code), NULL))
                goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_intrafrequency_lte_info_v2_global_cell_id), NULL))
                goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_intrafrequency_lte_info_v2_eutra_absolute_rf_channel_number), NULL))
                goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_intrafrequency_lte_info_v2_serving_cell_id), NULL))
                goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_intrafrequency_lte_info_v2_cell_reselection_priority), NULL))
                goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_intrafrequency_lte_info_v2_s_non_intra_search_threshold), NULL))
                goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_intrafrequency_lte_info_v2_serving_cell_low_threshold), NULL))
                goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_intrafrequency_lte_info_v2_s_intra_search_threshold), NULL))
                goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
            {
                guint cell_i;
                guint8 cell_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), NULL))
                    goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;

                self->arg_intrafrequency_lte_info_v2_cell = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetCellLocationInfoOutputIntrafrequencyLteInfoV2CellElement),
                    (guint)cell_n_items);

                for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
                    QmiMessageNasGetCellLocationInfoOutputIntrafrequencyLteInfoV2CellElement cell_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.physical_cell_id), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
                    if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.rsrq), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
                    if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.rsrp), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
                    if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.rssi), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
                    if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.cell_selection_rx_level), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out;
                    g_array_insert_val (self->arg_intrafrequency_lte_info_v2_cell, cell_i, cell_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Intrafrequency LTE Info v2' TLV", offset);
            }

            self->arg_intrafrequency_lte_info_v2_set = TRUE;

qmi_message_nas_get_cell_location_info_output_intrafrequency_lte_info_v2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_CDMA_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_cdma_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_info_system_id), NULL))
                goto qmi_message_nas_get_cell_location_info_output_cdma_info_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_info_network_id), NULL))
                goto qmi_message_nas_get_cell_location_info_output_cdma_info_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_info_base_station_id), NULL))
                goto qmi_message_nas_get_cell_location_info_output_cdma_info_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_info_reference_pn), NULL))
                goto qmi_message_nas_get_cell_location_info_output_cdma_info_out;
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_info_latitude), NULL))
                goto qmi_message_nas_get_cell_location_info_output_cdma_info_out;
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_info_longitude), NULL))
                goto qmi_message_nas_get_cell_location_info_output_cdma_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA Info' TLV", offset);
            }

            self->arg_cdma_info_set = TRUE;

qmi_message_nas_get_cell_location_info_output_cdma_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_UMTS_INFO_V2, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_umts_info_v2_cell_id), NULL))
                goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
            {
                guint plmn_i;
                guint16 plmn_n_items = 3;


                self->arg_umts_info_v2_plmn = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)plmn_n_items);

                for (plmn_i = 0; plmn_i < plmn_n_items; plmn_i++) {
                    guint8 plmn_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(plmn_aux), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
                    g_array_insert_val (self->arg_umts_info_v2_plmn, plmn_i, plmn_aux);
                }
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_umts_info_v2_lac), NULL))
                goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_umts_info_v2_utra_absolute_rf_channel_number), NULL))
                goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_umts_info_v2_primary_scrambling_code), NULL))
                goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_umts_info_v2_rscp), NULL))
                goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_umts_info_v2_ecio), NULL))
                goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
            {
                guint cell_i;
                guint8 cell_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), NULL))
                    goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;

                self->arg_umts_info_v2_cell = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetCellLocationInfoOutputUmtsInfoV2CellElement),
                    (guint)cell_n_items);

                for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
                    QmiMessageNasGetCellLocationInfoOutputUmtsInfoV2CellElement cell_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.utra_absolute_rf_channel_number), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.primary_scrambling_code), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
                    if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.rscp), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
                    if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.ecio), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
                    g_array_insert_val (self->arg_umts_info_v2_cell, cell_i, cell_aux);
                }
            }
            {
                guint neighboring_geran_i;
                guint8 neighboring_geran_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(neighboring_geran_n_items), NULL))
                    goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;

                self->arg_umts_info_v2_neighboring_geran = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetCellLocationInfoOutputUmtsInfoV2NeighboringGeranElement),
                    (guint)neighboring_geran_n_items);

                for (neighboring_geran_i = 0; neighboring_geran_i < neighboring_geran_n_items; neighboring_geran_i++) {
                    QmiMessageNasGetCellLocationInfoOutputUmtsInfoV2NeighboringGeranElement neighboring_geran_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(neighboring_geran_aux.geran_absolute_rf_channel_number), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(neighboring_geran_aux.network_color_code), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(neighboring_geran_aux.base_station_color_code), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
                    if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(neighboring_geran_aux.rssi), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_umts_info_v2_out;
                    g_array_insert_val (self->arg_umts_info_v2_neighboring_geran, neighboring_geran_i, neighboring_geran_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'UMTS Info v2' TLV", offset);
            }

            self->arg_umts_info_v2_set = TRUE;

qmi_message_nas_get_cell_location_info_output_umts_info_v2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_GERAN_INFO_V2, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_geran_info_v2_cell_id), NULL))
                goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
            {
                guint plmn_i;
                guint16 plmn_n_items = 3;


                self->arg_geran_info_v2_plmn = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)plmn_n_items);

                for (plmn_i = 0; plmn_i < plmn_n_items; plmn_i++) {
                    guint8 plmn_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(plmn_aux), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
                    g_array_insert_val (self->arg_geran_info_v2_plmn, plmn_i, plmn_aux);
                }
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_geran_info_v2_lac), NULL))
                goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_geran_info_v2_geran_absolute_rf_channel_number), NULL))
                goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_geran_info_v2_base_station_identity_code), NULL))
                goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_geran_info_v2_timing_advance), NULL))
                goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_geran_info_v2_rx_level), NULL))
                goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
            {
                guint cell_i;
                guint8 cell_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_n_items), NULL))
                    goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;

                self->arg_geran_info_v2_cell = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetCellLocationInfoOutputGeranInfoV2CellElement),
                    (guint)cell_n_items);

                g_array_set_clear_func (self->arg_geran_info_v2_cell,
                                        (GDestroyNotify)cell_qmimessagenasgetcelllocationinfooutputgeraninfov_2cellelement_clear);

                for (cell_i = 0; cell_i < cell_n_items; cell_i++) {
                    QmiMessageNasGetCellLocationInfoOutputGeranInfoV2CellElement cell_aux;

                    if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.cell_id), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
                    {
                        guint plmn_i;
                        guint16 plmn_n_items = 3;


                        cell_aux.plmn = g_array_sized_new (
                            FALSE,
                            FALSE,
                            sizeof (guint8),
                            (guint)plmn_n_items);

                        for (plmn_i = 0; plmn_i < plmn_n_items; plmn_i++) {
                            guint8 plmn_aux;

                            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(plmn_aux), NULL))
                                goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
                            g_array_insert_val (cell_aux.plmn, plmn_i, plmn_aux);
                        }
                    }
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.lac), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.geran_absolute_rf_channel_number), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(cell_aux.base_station_identity_code), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(cell_aux.rx_level), NULL))
                        goto qmi_message_nas_get_cell_location_info_output_geran_info_v2_out;
                    g_array_insert_val (self->arg_geran_info_v2_cell, cell_i, cell_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GERAN Info v2' TLV", offset);
            }

            self->arg_geran_info_v2_set = TRUE;

qmi_message_nas_get_cell_location_info_output_geran_info_v2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_cell_location_info_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_cell_location_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get PLMN Name */


/* --- Input -- */

struct _QmiMessageNasGetPlmnNameInput {
    volatile gint ref_count;

    /* Send All Information */
    gboolean arg_send_all_information_set;
    guint8 arg_send_all_information;

    /* Radio Access Technology */
    gboolean arg_radio_access_technology_set;
    guint8 arg_radio_access_technology;

    /* CSG ID */
    gboolean arg_csg_id_set;
    guint32 arg_csg_id;

    /* Use Static Table Only */
    gboolean arg_use_static_table_only_set;
    guint8 arg_use_static_table_only;

    /* Always Send PLMN Name */
    gboolean arg_always_send_plmn_name_set;
    guint8 arg_always_send_plmn_name;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    guint8 arg_mnc_pcs_digit_include_status;

    /* Suppress SIM Error */
    gboolean arg_suppress_sim_error_set;
    guint8 arg_suppress_sim_error;

    /* PLMN */
    gboolean arg_plmn_set;
    guint16 arg_plmn_mcc;
    guint16 arg_plmn_mnc;
};

#define QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_SEND_ALL_INFORMATION 0x16
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_RADIO_ACCESS_TECHNOLOGY 0x15
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_CSG_ID 0x14
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_USE_STATIC_TABLE_ONLY 0x13
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_ALWAYS_SEND_PLMN_NAME 0x12
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x11
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_SUPPRESS_SIM_ERROR 0x10
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_PLMN 0x01

gboolean
qmi_message_nas_get_plmn_name_input_get_send_all_information (
    QmiMessageNasGetPlmnNameInput *self,
    gboolean *value_send_all_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_send_all_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Send All Information' was not found in the message");
        return FALSE;
    }

    if (value_send_all_information)
        *value_send_all_information = (gboolean)(self->arg_send_all_information);

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_set_send_all_information (
    QmiMessageNasGetPlmnNameInput *self,
    gboolean value_send_all_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_send_all_information = (guint8)(value_send_all_information);
    self->arg_send_all_information_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_get_radio_access_technology (
    QmiMessageNasGetPlmnNameInput *self,
    QmiNasRadioInterface *value_radio_access_technology,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_radio_access_technology_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Radio Access Technology' was not found in the message");
        return FALSE;
    }

    if (value_radio_access_technology)
        *value_radio_access_technology = (QmiNasRadioInterface)(self->arg_radio_access_technology);

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_set_radio_access_technology (
    QmiMessageNasGetPlmnNameInput *self,
    QmiNasRadioInterface value_radio_access_technology,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_radio_access_technology = (guint8)(value_radio_access_technology);
    self->arg_radio_access_technology_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_get_csg_id (
    QmiMessageNasGetPlmnNameInput *self,
    guint32 *value_csg_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_csg_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CSG ID' was not found in the message");
        return FALSE;
    }

    if (value_csg_id)
        *value_csg_id = self->arg_csg_id;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_set_csg_id (
    QmiMessageNasGetPlmnNameInput *self,
    guint32 value_csg_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_csg_id = value_csg_id;
    self->arg_csg_id_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_get_use_static_table_only (
    QmiMessageNasGetPlmnNameInput *self,
    gboolean *value_use_static_table_only,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_use_static_table_only_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Use Static Table Only' was not found in the message");
        return FALSE;
    }

    if (value_use_static_table_only)
        *value_use_static_table_only = (gboolean)(self->arg_use_static_table_only);

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_set_use_static_table_only (
    QmiMessageNasGetPlmnNameInput *self,
    gboolean value_use_static_table_only,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_use_static_table_only = (guint8)(value_use_static_table_only);
    self->arg_use_static_table_only_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_get_always_send_plmn_name (
    QmiMessageNasGetPlmnNameInput *self,
    gboolean *value_always_send_plmn_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_always_send_plmn_name_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Always Send PLMN Name' was not found in the message");
        return FALSE;
    }

    if (value_always_send_plmn_name)
        *value_always_send_plmn_name = (gboolean)(self->arg_always_send_plmn_name);

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_set_always_send_plmn_name (
    QmiMessageNasGetPlmnNameInput *self,
    gboolean value_always_send_plmn_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_always_send_plmn_name = (guint8)(value_always_send_plmn_name);
    self->arg_always_send_plmn_name_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_get_mnc_pcs_digit_include_status (
    QmiMessageNasGetPlmnNameInput *self,
    gboolean *value_mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (value_mnc_pcs_digit_include_status)
        *value_mnc_pcs_digit_include_status = (gboolean)(self->arg_mnc_pcs_digit_include_status);

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_set_mnc_pcs_digit_include_status (
    QmiMessageNasGetPlmnNameInput *self,
    gboolean value_mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_mnc_pcs_digit_include_status = (guint8)(value_mnc_pcs_digit_include_status);
    self->arg_mnc_pcs_digit_include_status_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_get_suppress_sim_error (
    QmiMessageNasGetPlmnNameInput *self,
    gboolean *value_suppress_sim_error,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_suppress_sim_error_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Suppress SIM Error' was not found in the message");
        return FALSE;
    }

    if (value_suppress_sim_error)
        *value_suppress_sim_error = (gboolean)(self->arg_suppress_sim_error);

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_set_suppress_sim_error (
    QmiMessageNasGetPlmnNameInput *self,
    gboolean value_suppress_sim_error,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_suppress_sim_error = (guint8)(value_suppress_sim_error);
    self->arg_suppress_sim_error_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_get_plmn (
    QmiMessageNasGetPlmnNameInput *self,
    guint16 *value_plmn_mcc,
    guint16 *value_plmn_mnc,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_plmn_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PLMN' was not found in the message");
        return FALSE;
    }

    if (value_plmn_mcc)
        *value_plmn_mcc = self->arg_plmn_mcc;
    if (value_plmn_mnc)
        *value_plmn_mnc = self->arg_plmn_mnc;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_input_set_plmn (
    QmiMessageNasGetPlmnNameInput *self,
    guint16 value_plmn_mcc,
    guint16 value_plmn_mnc,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_plmn_mcc = value_plmn_mcc;
    self->arg_plmn_mnc = value_plmn_mnc;
    self->arg_plmn_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_get_plmn_name_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetPlmnNameInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_plmn_name_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_plmn_name_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetPlmnNameInput *
qmi_message_nas_get_plmn_name_input_ref (QmiMessageNasGetPlmnNameInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_plmn_name_input_unref (QmiMessageNasGetPlmnNameInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetPlmnNameInput, self);
    }
}

QmiMessageNasGetPlmnNameInput *
qmi_message_nas_get_plmn_name_input_new (void)
{
    QmiMessageNasGetPlmnNameInput *self;

    self = g_slice_new0 (QmiMessageNasGetPlmnNameInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_get_plmn_name_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasGetPlmnNameInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_PLMN_NAME);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Get PLMN Name' has mandatory TLVs");
        return NULL;
    }

    /* Try to add the 'Send All Information' TLV */
    if (input->arg_send_all_information_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_SEND_ALL_INFORMATION, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Send All Information': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_send_all_information;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Send All Information': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Send All Information': ");
            return NULL;
        }
    }

    /* Try to add the 'Radio Access Technology' TLV */
    if (input->arg_radio_access_technology_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_RADIO_ACCESS_TECHNOLOGY, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Radio Access Technology': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_radio_access_technology;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Radio Access Technology': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Radio Access Technology': ");
            return NULL;
        }
    }

    /* Try to add the 'CSG ID' TLV */
    if (input->arg_csg_id_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_CSG_ID, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'CSG ID': ");
            return NULL;
        }

        /* Write the guint32 variable to the buffer */
        if (!qmi_message_tlv_write_guint32 (self, QMI_ENDIAN_LITTLE, input->arg_csg_id, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'CSG ID': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'CSG ID': ");
            return NULL;
        }
    }

    /* Try to add the 'Use Static Table Only' TLV */
    if (input->arg_use_static_table_only_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_USE_STATIC_TABLE_ONLY, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Use Static Table Only': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_use_static_table_only;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Use Static Table Only': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Use Static Table Only': ");
            return NULL;
        }
    }

    /* Try to add the 'Always Send PLMN Name' TLV */
    if (input->arg_always_send_plmn_name_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_ALWAYS_SEND_PLMN_NAME, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Always Send PLMN Name': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_always_send_plmn_name;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Always Send PLMN Name': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Always Send PLMN Name': ");
            return NULL;
        }
    }

    /* Try to add the 'MNC PCS Digit Include Status' TLV */
    if (input->arg_mnc_pcs_digit_include_status_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'MNC PCS Digit Include Status': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_mnc_pcs_digit_include_status;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'MNC PCS Digit Include Status': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'MNC PCS Digit Include Status': ");
            return NULL;
        }
    }

    /* Try to add the 'Suppress SIM Error' TLV */
    if (input->arg_suppress_sim_error_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_SUPPRESS_SIM_ERROR, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Suppress SIM Error': ");
            return NULL;
        }

        {
            guint8 tmp;

            tmp = (guint8) input->arg_suppress_sim_error;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Suppress SIM Error': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Suppress SIM Error': ");
            return NULL;
        }
    }

    /* Try to add the 'PLMN' TLV */
    if (input->arg_plmn_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_PLMN, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'PLMN': ");
            return NULL;
        }

        /* Write the guint16 variable to the buffer */
        if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, input->arg_plmn_mcc, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'PLMN': ");
            return NULL;
        }
        /* Write the guint16 variable to the buffer */
        if (!qmi_message_tlv_write_guint16 (self, QMI_ENDIAN_LITTLE, input->arg_plmn_mnc, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'PLMN': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'PLMN': ");
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'PLMN' in message 'Get PLMN Name'");
        return NULL;
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

static void
plmn_name_with_language_id_qmimessagenasgetplmnnameoutputplmnnamewithlanguageidelement_clear (QmiMessageNasGetPlmnNameOutputPlmnNameWithLanguageIdElement *p)
{
    if ((*p).long_name)
        g_array_unref ((*p).long_name);
    if ((*p).short_name)
        g_array_unref ((*p).short_name);
}

struct _QmiMessageNasGetPlmnNameOutput {
    volatile gint ref_count;

    /* Network Name Source */
    gboolean arg_network_name_source_set;
    guint32 arg_network_name_source;

    /* Additional Information */
    gboolean arg_additional_information_set;
    GArray *arg_additional_information;

    /* PLMN Name With Language Id */
    gboolean arg_plmn_name_with_language_id_set;
    GArray *arg_plmn_name_with_language_id;

    /* Network Information */
    gboolean arg_network_information_set;
    guint32 arg_network_information;

    /* Display Bit Information */
    gboolean arg_display_bit_information_set;
    guint32 arg_display_bit_information_service_provider_name_set;
    guint32 arg_display_bit_information_plmn_name_set;

    /* 3GPP EONS PLMN Name */
    gboolean arg_3gpp_eons_plmn_name_set;
    guint8 arg_3gpp_eons_plmn_name_service_provider_name_encoding;
    GArray *arg_3gpp_eons_plmn_name_service_provider_name;
    guint8 arg_3gpp_eons_plmn_name_short_name_encoding;
    guint8 arg_3gpp_eons_plmn_name_short_name_country_initials;
    guint8 arg_3gpp_eons_plmn_name_short_name_spare_bits;
    GArray *arg_3gpp_eons_plmn_name_short_name;
    guint8 arg_3gpp_eons_plmn_name_long_name_encoding;
    guint8 arg_3gpp_eons_plmn_name_long_name_country_initials;
    guint8 arg_3gpp_eons_plmn_name_long_name_spare_bits;
    GArray *arg_3gpp_eons_plmn_name_long_name;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_NETWORK_NAME_SOURCE 0x15
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_ADDITIONAL_INFORMATION 0x14
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_PLMN_NAME_WITH_LANGUAGE_ID 0x13
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_NETWORK_INFORMATION 0x12
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_DISPLAY_BIT_INFORMATION 0x11
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_3GPP_EONS_PLMN_NAME 0x10
#define QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_get_plmn_name_output_get_network_name_source (
    QmiMessageNasGetPlmnNameOutput *self,
    QmiNasNetworkNameSource *value_network_name_source,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_name_source_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Name Source' was not found in the message");
        return FALSE;
    }

    if (value_network_name_source)
        *value_network_name_source = (QmiNasNetworkNameSource)(self->arg_network_name_source);

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_output_get_additional_information (
    QmiMessageNasGetPlmnNameOutput *self,
    GArray **value_additional_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional Information' was not found in the message");
        return FALSE;
    }

    if (value_additional_information)
        *value_additional_information = self->arg_additional_information;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_output_get_plmn_name_with_language_id (
    QmiMessageNasGetPlmnNameOutput *self,
    GArray **value_plmn_name_with_language_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_plmn_name_with_language_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PLMN Name With Language Id' was not found in the message");
        return FALSE;
    }

    if (value_plmn_name_with_language_id)
        *value_plmn_name_with_language_id = self->arg_plmn_name_with_language_id;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_output_get_network_information (
    QmiMessageNasGetPlmnNameOutput *self,
    QmiNasBoolean *value_network_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Information' was not found in the message");
        return FALSE;
    }

    if (value_network_information)
        *value_network_information = (QmiNasBoolean)(self->arg_network_information);

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_output_get_display_bit_information (
    QmiMessageNasGetPlmnNameOutput *self,
    QmiNasBoolean *value_display_bit_information_service_provider_name_set,
    QmiNasBoolean *value_display_bit_information_plmn_name_set,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_display_bit_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Display Bit Information' was not found in the message");
        return FALSE;
    }

    if (value_display_bit_information_service_provider_name_set)
        *value_display_bit_information_service_provider_name_set = (QmiNasBoolean)(self->arg_display_bit_information_service_provider_name_set);
    if (value_display_bit_information_plmn_name_set)
        *value_display_bit_information_plmn_name_set = (QmiNasBoolean)(self->arg_display_bit_information_plmn_name_set);

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_output_get_3gpp_eons_plmn_name (
    QmiMessageNasGetPlmnNameOutput *self,
    QmiNasNetworkDescriptionEncoding *value_3gpp_eons_plmn_name_service_provider_name_encoding,
    GArray **value_3gpp_eons_plmn_name_service_provider_name,
    QmiNasNetworkDescriptionEncoding *value_3gpp_eons_plmn_name_short_name_encoding,
    QmiNasPlmnNameCountryInitials *value_3gpp_eons_plmn_name_short_name_country_initials,
    QmiNasPlmnNameSpareBits *value_3gpp_eons_plmn_name_short_name_spare_bits,
    GArray **value_3gpp_eons_plmn_name_short_name,
    QmiNasNetworkDescriptionEncoding *value_3gpp_eons_plmn_name_long_name_encoding,
    QmiNasPlmnNameCountryInitials *value_3gpp_eons_plmn_name_long_name_country_initials,
    QmiNasPlmnNameSpareBits *value_3gpp_eons_plmn_name_long_name_spare_bits,
    GArray **value_3gpp_eons_plmn_name_long_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_3gpp_eons_plmn_name_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field '3GPP EONS PLMN Name' was not found in the message");
        return FALSE;
    }

    if (value_3gpp_eons_plmn_name_service_provider_name_encoding)
        *value_3gpp_eons_plmn_name_service_provider_name_encoding = (QmiNasNetworkDescriptionEncoding)(self->arg_3gpp_eons_plmn_name_service_provider_name_encoding);
    if (value_3gpp_eons_plmn_name_service_provider_name)
        *value_3gpp_eons_plmn_name_service_provider_name = self->arg_3gpp_eons_plmn_name_service_provider_name;
    if (value_3gpp_eons_plmn_name_short_name_encoding)
        *value_3gpp_eons_plmn_name_short_name_encoding = (QmiNasNetworkDescriptionEncoding)(self->arg_3gpp_eons_plmn_name_short_name_encoding);
    if (value_3gpp_eons_plmn_name_short_name_country_initials)
        *value_3gpp_eons_plmn_name_short_name_country_initials = (QmiNasPlmnNameCountryInitials)(self->arg_3gpp_eons_plmn_name_short_name_country_initials);
    if (value_3gpp_eons_plmn_name_short_name_spare_bits)
        *value_3gpp_eons_plmn_name_short_name_spare_bits = (QmiNasPlmnNameSpareBits)(self->arg_3gpp_eons_plmn_name_short_name_spare_bits);
    if (value_3gpp_eons_plmn_name_short_name)
        *value_3gpp_eons_plmn_name_short_name = self->arg_3gpp_eons_plmn_name_short_name;
    if (value_3gpp_eons_plmn_name_long_name_encoding)
        *value_3gpp_eons_plmn_name_long_name_encoding = (QmiNasNetworkDescriptionEncoding)(self->arg_3gpp_eons_plmn_name_long_name_encoding);
    if (value_3gpp_eons_plmn_name_long_name_country_initials)
        *value_3gpp_eons_plmn_name_long_name_country_initials = (QmiNasPlmnNameCountryInitials)(self->arg_3gpp_eons_plmn_name_long_name_country_initials);
    if (value_3gpp_eons_plmn_name_long_name_spare_bits)
        *value_3gpp_eons_plmn_name_long_name_spare_bits = (QmiNasPlmnNameSpareBits)(self->arg_3gpp_eons_plmn_name_long_name_spare_bits);
    if (value_3gpp_eons_plmn_name_long_name)
        *value_3gpp_eons_plmn_name_long_name = self->arg_3gpp_eons_plmn_name_long_name;

    return TRUE;
}

gboolean
qmi_message_nas_get_plmn_name_output_get_result (
    QmiMessageNasGetPlmnNameOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_get_plmn_name_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetPlmnNameOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_plmn_name_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_plmn_name_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetPlmnNameOutput *
qmi_message_nas_get_plmn_name_output_ref (QmiMessageNasGetPlmnNameOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_plmn_name_output_unref (QmiMessageNasGetPlmnNameOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_additional_information)
            g_array_unref (self->arg_additional_information);
        if (self->arg_plmn_name_with_language_id)
            g_array_unref (self->arg_plmn_name_with_language_id);
        if (self->arg_3gpp_eons_plmn_name_service_provider_name)
            g_array_unref (self->arg_3gpp_eons_plmn_name_service_provider_name);
        if (self->arg_3gpp_eons_plmn_name_short_name)
            g_array_unref (self->arg_3gpp_eons_plmn_name_short_name);
        if (self->arg_3gpp_eons_plmn_name_long_name)
            g_array_unref (self->arg_3gpp_eons_plmn_name_long_name);
        g_slice_free (QmiMessageNasGetPlmnNameOutput, self);
    }
}

static gchar *
qmi_message_nas_get_plmn_name_input_send_all_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_SEND_ALL_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_input_radio_access_technology_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_RADIO_ACCESS_TECHNOLOGY, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_input_csg_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_CSG_ID, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_input_use_static_table_only_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_USE_STATIC_TABLE_ONLY, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_input_always_send_plmn_name_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_ALWAYS_SEND_PLMN_NAME, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_input_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_input_suppress_sim_error_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_SUPPRESS_SIM_ERROR, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_input_plmn_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_PLMN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " mcc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_output_network_name_source_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_NETWORK_NAME_SOURCE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_NAME_SOURCE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_name_source_get_string ((QmiNasNetworkNameSource)tmp));
#elif defined  __QMI_NAS_NETWORK_NAME_SOURCE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_name_source_build_string_from_mask ((QmiNasNetworkNameSource)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkNameSource
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_output_additional_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_ADDITIONAL_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint additional_information_i;
        guint8 additional_information_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(additional_information_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (additional_information_i = 0; additional_information_i < additional_information_n_items; additional_information_i++) {
            g_string_append_printf (printable, " [%u] = '", additional_information_i);

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_output_plmn_name_with_language_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_PLMN_NAME_WITH_LANGUAGE_ID, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint plmn_name_with_language_id_i;
        guint8 plmn_name_with_language_id_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(plmn_name_with_language_id_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (plmn_name_with_language_id_i = 0; plmn_name_with_language_id_i < plmn_name_with_language_id_n_items; plmn_name_with_language_id_i++) {
            g_string_append_printf (printable, " [%u] = '", plmn_name_with_language_id_i);
            g_string_append (printable, "[");
            g_string_append (printable, " long_name = '");
            {
                guint long_name_i;
                guint8 long_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), &error))
                    goto out;

                g_string_append (printable, "{");

                for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
                    g_string_append_printf (printable, " [%u] = '", long_name_i);

                    {
                        guint16 tmp;

                        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, " '");
                }

                g_string_append (printable, "}");
            }            g_string_append (printable, "'");
            g_string_append (printable, " short_name = '");
            {
                guint short_name_i;
                guint8 short_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), &error))
                    goto out;

                g_string_append (printable, "{");

                for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
                    g_string_append_printf (printable, " [%u] = '", short_name_i);

                    {
                        guint16 tmp;

                        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                            goto out;
                        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                    }
                    g_string_append (printable, " '");
                }

                g_string_append (printable, "}");
            }            g_string_append (printable, "'");
            g_string_append (printable, " language_id = '");

            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_PLMN_LANGUAGE_ID_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_plmn_language_id_get_string ((QmiNasPlmnLanguageId)tmp));
#elif defined  __QMI_NAS_PLMN_LANGUAGE_ID_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_plmn_language_id_build_string_from_mask ((QmiNasPlmnLanguageId)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasPlmnLanguageId
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_output_network_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_NETWORK_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_BOOLEAN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_boolean_get_string ((QmiNasBoolean)tmp));
#elif defined  __QMI_NAS_BOOLEAN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_boolean_build_string_from_mask ((QmiNasBoolean)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasBoolean
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_output_display_bit_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_DISPLAY_BIT_INFORMATION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_provider_name_set = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_BOOLEAN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_boolean_get_string ((QmiNasBoolean)tmp));
#elif defined  __QMI_NAS_BOOLEAN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_boolean_build_string_from_mask ((QmiNasBoolean)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasBoolean
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " plmn_name_set = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_BOOLEAN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_boolean_get_string ((QmiNasBoolean)tmp));
#elif defined  __QMI_NAS_BOOLEAN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_boolean_build_string_from_mask ((QmiNasBoolean)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasBoolean
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_3GPP_EONS_PLMN_NAME, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_provider_name_encoding = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_description_encoding_get_string ((QmiNasNetworkDescriptionEncoding)tmp));
#elif defined  __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_description_encoding_build_string_from_mask ((QmiNasNetworkDescriptionEncoding)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkDescriptionEncoding
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_provider_name = '");
    {
        guint service_provider_name_i;
        guint8 service_provider_name_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(service_provider_name_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (service_provider_name_i = 0; service_provider_name_i < service_provider_name_n_items; service_provider_name_i++) {
            g_string_append_printf (printable, " [%u] = '", service_provider_name_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " short_name_encoding = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_description_encoding_get_string ((QmiNasNetworkDescriptionEncoding)tmp));
#elif defined  __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_description_encoding_build_string_from_mask ((QmiNasNetworkDescriptionEncoding)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkDescriptionEncoding
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " short_name_country_initials = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_name_country_initials_get_string ((QmiNasPlmnNameCountryInitials)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_name_country_initials_build_string_from_mask ((QmiNasPlmnNameCountryInitials)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnNameCountryInitials
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " short_name_spare_bits = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_name_spare_bits_get_string ((QmiNasPlmnNameSpareBits)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_name_spare_bits_build_string_from_mask ((QmiNasPlmnNameSpareBits)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnNameSpareBits
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " short_name = '");
    {
        guint short_name_i;
        guint8 short_name_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
            g_string_append_printf (printable, " [%u] = '", short_name_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " long_name_encoding = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_description_encoding_get_string ((QmiNasNetworkDescriptionEncoding)tmp));
#elif defined  __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_description_encoding_build_string_from_mask ((QmiNasNetworkDescriptionEncoding)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkDescriptionEncoding
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " long_name_country_initials = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_name_country_initials_get_string ((QmiNasPlmnNameCountryInitials)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_COUNTRY_INITIALS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_name_country_initials_build_string_from_mask ((QmiNasPlmnNameCountryInitials)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnNameCountryInitials
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " long_name_spare_bits = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_plmn_name_spare_bits_get_string ((QmiNasPlmnNameSpareBits)tmp));
#elif defined  __QMI_NAS_PLMN_NAME_SPARE_BITS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_plmn_name_spare_bits_build_string_from_mask ((QmiNasPlmnNameSpareBits)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasPlmnNameSpareBits
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " long_name = '");
    {
        guint long_name_i;
        guint8 long_name_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
            g_string_append_printf (printable, " [%u] = '", long_name_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_plmn_name_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_plmn_name_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_plmn_name_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_SEND_ALL_INFORMATION:
            tlv_type_str = "Send All Information";
            translated_value = qmi_message_nas_get_plmn_name_input_send_all_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_RADIO_ACCESS_TECHNOLOGY:
            tlv_type_str = "Radio Access Technology";
            translated_value = qmi_message_nas_get_plmn_name_input_radio_access_technology_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_CSG_ID:
            tlv_type_str = "CSG ID";
            translated_value = qmi_message_nas_get_plmn_name_input_csg_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_USE_STATIC_TABLE_ONLY:
            tlv_type_str = "Use Static Table Only";
            translated_value = qmi_message_nas_get_plmn_name_input_use_static_table_only_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_ALWAYS_SEND_PLMN_NAME:
            tlv_type_str = "Always Send PLMN Name";
            translated_value = qmi_message_nas_get_plmn_name_input_always_send_plmn_name_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_message_nas_get_plmn_name_input_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_SUPPRESS_SIM_ERROR:
            tlv_type_str = "Suppress SIM Error";
            translated_value = qmi_message_nas_get_plmn_name_input_suppress_sim_error_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_INPUT_TLV_PLMN:
            tlv_type_str = "PLMN";
            translated_value = qmi_message_nas_get_plmn_name_input_plmn_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_NETWORK_NAME_SOURCE:
            tlv_type_str = "Network Name Source";
            translated_value = qmi_message_nas_get_plmn_name_output_network_name_source_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_ADDITIONAL_INFORMATION:
            tlv_type_str = "Additional Information";
            translated_value = qmi_message_nas_get_plmn_name_output_additional_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_PLMN_NAME_WITH_LANGUAGE_ID:
            tlv_type_str = "PLMN Name With Language Id";
            translated_value = qmi_message_nas_get_plmn_name_output_plmn_name_with_language_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_NETWORK_INFORMATION:
            tlv_type_str = "Network Information";
            translated_value = qmi_message_nas_get_plmn_name_output_network_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_DISPLAY_BIT_INFORMATION:
            tlv_type_str = "Display Bit Information";
            translated_value = qmi_message_nas_get_plmn_name_output_display_bit_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_3GPP_EONS_PLMN_NAME:
            tlv_type_str = "3GPP EONS PLMN Name";
            translated_value = qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_plmn_name_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get PLMN Name\" (0x0044)\n",
                            line_prefix);

    {
        struct message_get_plmn_name_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_plmn_name_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetPlmnNameOutput *
__qmi_message_nas_get_plmn_name_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetPlmnNameOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_PLMN_NAME);

    self = g_slice_new0 (QmiMessageNasGetPlmnNameOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_NETWORK_NAME_SOURCE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_plmn_name_output_network_name_source_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_plmn_name_output_network_name_source_out;
                self->arg_network_name_source = (QmiNasNetworkNameSource)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Network Name Source' TLV", offset);
            }

            self->arg_network_name_source_set = TRUE;

qmi_message_nas_get_plmn_name_output_network_name_source_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_ADDITIONAL_INFORMATION, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_plmn_name_output_additional_information_out;
            }
            {
                guint additional_information_i;
                guint8 additional_information_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(additional_information_n_items), NULL))
                    goto qmi_message_nas_get_plmn_name_output_additional_information_out;

                self->arg_additional_information = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint16),
                    (guint)additional_information_n_items);

                for (additional_information_i = 0; additional_information_i < additional_information_n_items; additional_information_i++) {
                    guint16 additional_information_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(additional_information_aux), NULL))
                        goto qmi_message_nas_get_plmn_name_output_additional_information_out;
                    g_array_insert_val (self->arg_additional_information, additional_information_i, additional_information_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Additional Information' TLV", offset);
            }

            self->arg_additional_information_set = TRUE;

qmi_message_nas_get_plmn_name_output_additional_information_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_PLMN_NAME_WITH_LANGUAGE_ID, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_plmn_name_output_plmn_name_with_language_id_out;
            }
            {
                guint plmn_name_with_language_id_i;
                guint8 plmn_name_with_language_id_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(plmn_name_with_language_id_n_items), NULL))
                    goto qmi_message_nas_get_plmn_name_output_plmn_name_with_language_id_out;

                self->arg_plmn_name_with_language_id = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetPlmnNameOutputPlmnNameWithLanguageIdElement),
                    (guint)plmn_name_with_language_id_n_items);

                g_array_set_clear_func (self->arg_plmn_name_with_language_id,
                                        (GDestroyNotify)plmn_name_with_language_id_qmimessagenasgetplmnnameoutputplmnnamewithlanguageidelement_clear);

                for (plmn_name_with_language_id_i = 0; plmn_name_with_language_id_i < plmn_name_with_language_id_n_items; plmn_name_with_language_id_i++) {
                    QmiMessageNasGetPlmnNameOutputPlmnNameWithLanguageIdElement plmn_name_with_language_id_aux;

                    {
                        guint long_name_i;
                        guint8 long_name_n_items;

                        /* Read number of items in the array */
                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), NULL))
                            goto qmi_message_nas_get_plmn_name_output_plmn_name_with_language_id_out;

                        plmn_name_with_language_id_aux.long_name = g_array_sized_new (
                            FALSE,
                            FALSE,
                            sizeof (guint16),
                            (guint)long_name_n_items);

                        for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
                            guint16 long_name_aux;

                            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(long_name_aux), NULL))
                                goto qmi_message_nas_get_plmn_name_output_plmn_name_with_language_id_out;
                            g_array_insert_val (plmn_name_with_language_id_aux.long_name, long_name_i, long_name_aux);
                        }
                    }
                    {
                        guint short_name_i;
                        guint8 short_name_n_items;

                        /* Read number of items in the array */
                        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), NULL))
                            goto qmi_message_nas_get_plmn_name_output_plmn_name_with_language_id_out;

                        plmn_name_with_language_id_aux.short_name = g_array_sized_new (
                            FALSE,
                            FALSE,
                            sizeof (guint16),
                            (guint)short_name_n_items);

                        for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
                            guint16 short_name_aux;

                            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(short_name_aux), NULL))
                                goto qmi_message_nas_get_plmn_name_output_plmn_name_with_language_id_out;
                            g_array_insert_val (plmn_name_with_language_id_aux.short_name, short_name_i, short_name_aux);
                        }
                    }
                    {
                        guint32 tmp;

                        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                            goto qmi_message_nas_get_plmn_name_output_plmn_name_with_language_id_out;
                        plmn_name_with_language_id_aux.language_id = (QmiNasPlmnLanguageId)tmp;
                    }
                    g_array_insert_val (self->arg_plmn_name_with_language_id, plmn_name_with_language_id_i, plmn_name_with_language_id_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'PLMN Name With Language Id' TLV", offset);
            }

            self->arg_plmn_name_with_language_id_set = TRUE;

qmi_message_nas_get_plmn_name_output_plmn_name_with_language_id_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_NETWORK_INFORMATION, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_plmn_name_output_network_information_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_plmn_name_output_network_information_out;
                self->arg_network_information = (QmiNasBoolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Network Information' TLV", offset);
            }

            self->arg_network_information_set = TRUE;

qmi_message_nas_get_plmn_name_output_network_information_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_DISPLAY_BIT_INFORMATION, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_plmn_name_output_display_bit_information_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_plmn_name_output_display_bit_information_out;
                self->arg_display_bit_information_service_provider_name_set = (QmiNasBoolean)tmp;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_plmn_name_output_display_bit_information_out;
                self->arg_display_bit_information_plmn_name_set = (QmiNasBoolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Display Bit Information' TLV", offset);
            }

            self->arg_display_bit_information_set = TRUE;

qmi_message_nas_get_plmn_name_output_display_bit_information_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_3GPP_EONS_PLMN_NAME, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;
                self->arg_3gpp_eons_plmn_name_service_provider_name_encoding = (QmiNasNetworkDescriptionEncoding)tmp;
            }
            {
                guint service_provider_name_i;
                guint8 service_provider_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(service_provider_name_n_items), NULL))
                    goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;

                self->arg_3gpp_eons_plmn_name_service_provider_name = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)service_provider_name_n_items);

                for (service_provider_name_i = 0; service_provider_name_i < service_provider_name_n_items; service_provider_name_i++) {
                    guint8 service_provider_name_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(service_provider_name_aux), NULL))
                        goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;
                    g_array_insert_val (self->arg_3gpp_eons_plmn_name_service_provider_name, service_provider_name_i, service_provider_name_aux);
                }
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;
                self->arg_3gpp_eons_plmn_name_short_name_encoding = (QmiNasNetworkDescriptionEncoding)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;
                self->arg_3gpp_eons_plmn_name_short_name_country_initials = (QmiNasPlmnNameCountryInitials)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;
                self->arg_3gpp_eons_plmn_name_short_name_spare_bits = (QmiNasPlmnNameSpareBits)tmp;
            }
            {
                guint short_name_i;
                guint8 short_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_n_items), NULL))
                    goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;

                self->arg_3gpp_eons_plmn_name_short_name = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)short_name_n_items);

                for (short_name_i = 0; short_name_i < short_name_n_items; short_name_i++) {
                    guint8 short_name_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(short_name_aux), NULL))
                        goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;
                    g_array_insert_val (self->arg_3gpp_eons_plmn_name_short_name, short_name_i, short_name_aux);
                }
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;
                self->arg_3gpp_eons_plmn_name_long_name_encoding = (QmiNasNetworkDescriptionEncoding)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;
                self->arg_3gpp_eons_plmn_name_long_name_country_initials = (QmiNasPlmnNameCountryInitials)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;
                self->arg_3gpp_eons_plmn_name_long_name_spare_bits = (QmiNasPlmnNameSpareBits)tmp;
            }
            {
                guint long_name_i;
                guint8 long_name_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_n_items), NULL))
                    goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;

                self->arg_3gpp_eons_plmn_name_long_name = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)long_name_n_items);

                for (long_name_i = 0; long_name_i < long_name_n_items; long_name_i++) {
                    guint8 long_name_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(long_name_aux), NULL))
                        goto qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out;
                    g_array_insert_val (self->arg_3gpp_eons_plmn_name_long_name, long_name_i, long_name_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the '3GPP EONS PLMN Name' TLV", offset);
            }

            self->arg_3gpp_eons_plmn_name_set = TRUE;

qmi_message_nas_get_plmn_name_output_3gpp_eons_plmn_name_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_PLMN_NAME_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_plmn_name_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_plmn_name_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get System Info */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_system_info_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_SYSTEM_INFO);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetSystemInfoOutput {
    volatile gint ref_count;

    /* NR5G Tracking Area Code */
    gboolean arg_nr5g_tracking_area_code_set;
    GArray *arg_nr5g_tracking_area_code;

    /* DCNR restriction Info */
    gboolean arg_dcnr_restriction_info_set;
    guint8 arg_dcnr_restriction_info;

    /* EUTRA with NR5G availability */
    gboolean arg_eutra_with_nr5g_availability_set;
    guint8 arg_eutra_with_nr5g_availability;

    /* NR5G System Info */
    gboolean arg_nr5g_system_info_set;
    guint8 arg_nr5g_system_info_domain_valid;
    guint8 arg_nr5g_system_info_domain;
    guint8 arg_nr5g_system_info_service_capability_valid;
    guint8 arg_nr5g_system_info_service_capability;
    guint8 arg_nr5g_system_info_roaming_status_valid;
    guint8 arg_nr5g_system_info_roaming_status;
    guint8 arg_nr5g_system_info_forbidden_valid;
    guint8 arg_nr5g_system_info_forbidden;
    guint8 arg_nr5g_system_info_lac_valid;
    guint16 arg_nr5g_system_info_lac;
    guint8 arg_nr5g_system_info_cid_valid;
    guint32 arg_nr5g_system_info_cid;
    guint8 arg_nr5g_system_info_registration_reject_info_valid;
    guint8 arg_nr5g_system_info_registration_reject_domain;
    guint8 arg_nr5g_system_info_registration_reject_cause;
    guint8 arg_nr5g_system_info_network_id_valid;
    gchar arg_nr5g_system_info_mcc[4];
    gchar arg_nr5g_system_info_mnc[4];
    guint8 arg_nr5g_system_info_tac_valid;
    guint16 arg_nr5g_system_info_tac;

    /* NR5G Service Status Info */
    gboolean arg_nr5g_service_status_info_set;
    guint8 arg_nr5g_service_status_info_service_status;
    guint8 arg_nr5g_service_status_info_true_service_status;
    guint8 arg_nr5g_service_status_info_preferred_data_path;

    /* LTE Cell Access Status */
    gboolean arg_lte_cell_access_status_set;
    guint32 arg_lte_cell_access_status;

    /* LTE eMBMS Coverage Info Trace ID */
    gboolean arg_lte_embms_coverage_info_trace_id_set;
    guint16 arg_lte_embms_coverage_info_trace_id;

    /* LTE Registration Domain */
    gboolean arg_lte_registration_domain_set;
    guint32 arg_lte_registration_domain;

    /* Network Selection Registration Restriction */
    gboolean arg_network_selection_registration_restriction_set;
    guint32 arg_network_selection_registration_restriction;

    /* CDMA Resolved MCC */
    gboolean arg_cdma_resolved_mcc_set;
    guint16 arg_cdma_resolved_mcc;

    /* WCDMA Routing Area Code */
    gboolean arg_wcdma_routing_area_code_set;
    guint8 arg_wcdma_routing_area_code;

    /* GSM Routing Area Code */
    gboolean arg_gsm_routing_area_code_set;
    guint8 arg_gsm_routing_area_code;

    /* CDMA Registration Zone ID */
    gboolean arg_cdma_registration_zone_id_set;
    guint16 arg_cdma_registration_zone_id;

    /* LTE Voice Domain */
    gboolean arg_lte_voice_domain_set;
    guint32 arg_lte_voice_domain;

    /* IMS Voice Support */
    gboolean arg_ims_voice_support_set;
    guint8 arg_ims_voice_support;

    /* SIM Reject Info */
    gboolean arg_sim_reject_info_set;
    guint32 arg_sim_reject_info;

    /* LTE eMBMS Coverage Info Support */
    gboolean arg_lte_embms_coverage_info_support_set;
    guint8 arg_lte_embms_coverage_info_support;

    /* TD SCDMA System Info v2 */
    gboolean arg_td_scdma_system_info_v2_set;
    guint8 arg_td_scdma_system_info_v2_domain_valid;
    guint8 arg_td_scdma_system_info_v2_domain;
    guint8 arg_td_scdma_system_info_v2_service_capability_valid;
    guint8 arg_td_scdma_system_info_v2_service_capability;
    guint8 arg_td_scdma_system_info_v2_roaming_status_valid;
    guint8 arg_td_scdma_system_info_v2_roaming_status;
    guint8 arg_td_scdma_system_info_v2_forbidden_valid;
    guint8 arg_td_scdma_system_info_v2_forbidden;
    guint8 arg_td_scdma_system_info_v2_lac_valid;
    guint16 arg_td_scdma_system_info_v2_lac;
    guint8 arg_td_scdma_system_info_v2_cid_valid;
    guint32 arg_td_scdma_system_info_v2_cid;
    guint8 arg_td_scdma_system_info_v2_registration_reject_info_valid;
    guint8 arg_td_scdma_system_info_v2_registration_reject_domain;
    guint8 arg_td_scdma_system_info_v2_registration_reject_cause;
    guint8 arg_td_scdma_system_info_v2_network_id_valid;
    gchar arg_td_scdma_system_info_v2_mcc[4];
    gchar arg_td_scdma_system_info_v2_mnc[4];
    guint8 arg_td_scdma_system_info_v2_hs_call_status_valid;
    guint8 arg_td_scdma_system_info_v2_hs_call_status;
    guint8 arg_td_scdma_system_info_v2_hs_service_valid;
    guint8 arg_td_scdma_system_info_v2_hs_service;
    guint8 arg_td_scdma_system_info_v2_cell_parameter_id_valid;
    guint16 arg_td_scdma_system_info_v2_cell_parameter_id;
    guint8 arg_td_scdma_system_info_v2_cell_broadcast_support_valid;
    guint32 arg_td_scdma_system_info_v2_cell_broadcast_support;
    guint8 arg_td_scdma_system_info_v2_cs_call_barring_status_valid;
    gint32 arg_td_scdma_system_info_v2_cs_call_barring_status;
    guint8 arg_td_scdma_system_info_v2_ps_call_barring_status_valid;
    gint32 arg_td_scdma_system_info_v2_ps_call_barring_status;
    guint8 arg_td_scdma_system_info_v2_cipher_domain_valid;
    guint8 arg_td_scdma_system_info_v2_cipher_domain;

    /* TD SCDMA Service Status */
    gboolean arg_td_scdma_service_status_set;
    guint8 arg_td_scdma_service_status_service_status;
    guint8 arg_td_scdma_service_status_true_service_status;
    guint8 arg_td_scdma_service_status_preferred_data_path;

    /* WCDMA Cipher Domain */
    gboolean arg_wcdma_cipher_domain_set;
    guint8 arg_wcdma_cipher_domain;

    /* GSM Cipher Domain */
    gboolean arg_gsm_cipher_domain_set;
    guint8 arg_gsm_cipher_domain;

    /* LTE Voice Support */
    gboolean arg_lte_voice_support_set;
    guint8 arg_lte_voice_support;

    /* WCDMA Call Barring Status */
    gboolean arg_wcdma_call_barring_status_set;
    gint32 arg_wcdma_call_barring_status_cs_status;
    gint32 arg_wcdma_call_barring_status_ps_status;

    /* GSM Call Barring Status */
    gboolean arg_gsm_call_barring_status_set;
    gint32 arg_gsm_call_barring_status_cs_status;
    gint32 arg_gsm_call_barring_status_ps_status;

    /* Additional LTE System Info */
    gboolean arg_additional_lte_system_info_set;
    guint16 arg_additional_lte_system_info_geo_system_index;

    /* Additional WCDMA System Info */
    gboolean arg_additional_wcdma_system_info_set;
    guint16 arg_additional_wcdma_system_info_geo_system_index;
    guint32 arg_additional_wcdma_system_info_cell_broadcast_support;

    /* Additional GSM System Info */
    gboolean arg_additional_gsm_system_info_set;
    guint16 arg_additional_gsm_system_info_geo_system_index;
    guint32 arg_additional_gsm_system_info_cell_broadcast_support;

    /* Additional HDR System Info */
    gboolean arg_additional_hdr_system_info_set;
    guint16 arg_additional_hdr_system_info_geo_system_index;

    /* Additional CDMA System Info */
    gboolean arg_additional_cdma_system_info_set;
    guint16 arg_additional_cdma_system_info_geo_system_index;
    guint16 arg_additional_cdma_system_info_registration_period;

    /* LTE System Info v2 */
    gboolean arg_lte_system_info_v2_set;
    guint8 arg_lte_system_info_v2_domain_valid;
    guint8 arg_lte_system_info_v2_domain;
    guint8 arg_lte_system_info_v2_service_capability_valid;
    guint8 arg_lte_system_info_v2_service_capability;
    guint8 arg_lte_system_info_v2_roaming_status_valid;
    guint8 arg_lte_system_info_v2_roaming_status;
    guint8 arg_lte_system_info_v2_forbidden_valid;
    guint8 arg_lte_system_info_v2_forbidden;
    guint8 arg_lte_system_info_v2_lac_valid;
    guint16 arg_lte_system_info_v2_lac;
    guint8 arg_lte_system_info_v2_cid_valid;
    guint32 arg_lte_system_info_v2_cid;
    guint8 arg_lte_system_info_v2_registration_reject_info_valid;
    guint8 arg_lte_system_info_v2_registration_reject_domain;
    guint8 arg_lte_system_info_v2_registration_reject_cause;
    guint8 arg_lte_system_info_v2_network_id_valid;
    gchar arg_lte_system_info_v2_mcc[4];
    gchar arg_lte_system_info_v2_mnc[4];
    guint8 arg_lte_system_info_v2_tac_valid;
    guint16 arg_lte_system_info_v2_tac;

    /* WCDMA System Info v2 */
    gboolean arg_wcdma_system_info_v2_set;
    guint8 arg_wcdma_system_info_v2_domain_valid;
    guint8 arg_wcdma_system_info_v2_domain;
    guint8 arg_wcdma_system_info_v2_service_capability_valid;
    guint8 arg_wcdma_system_info_v2_service_capability;
    guint8 arg_wcdma_system_info_v2_roaming_status_valid;
    guint8 arg_wcdma_system_info_v2_roaming_status;
    guint8 arg_wcdma_system_info_v2_forbidden_valid;
    guint8 arg_wcdma_system_info_v2_forbidden;
    guint8 arg_wcdma_system_info_v2_lac_valid;
    guint16 arg_wcdma_system_info_v2_lac;
    guint8 arg_wcdma_system_info_v2_cid_valid;
    guint32 arg_wcdma_system_info_v2_cid;
    guint8 arg_wcdma_system_info_v2_registration_reject_info_valid;
    guint8 arg_wcdma_system_info_v2_registration_reject_domain;
    guint8 arg_wcdma_system_info_v2_registration_reject_cause;
    guint8 arg_wcdma_system_info_v2_network_id_valid;
    gchar arg_wcdma_system_info_v2_mcc[4];
    gchar arg_wcdma_system_info_v2_mnc[4];
    guint8 arg_wcdma_system_info_v2_hs_call_status_valid;
    guint8 arg_wcdma_system_info_v2_hs_call_status;
    guint8 arg_wcdma_system_info_v2_hs_service_valid;
    guint8 arg_wcdma_system_info_v2_hs_service;
    guint8 arg_wcdma_system_info_v2_primary_scrambling_code_valid;
    guint16 arg_wcdma_system_info_v2_primary_scrambling_code;

    /* GSM System Info v2 */
    gboolean arg_gsm_system_info_v2_set;
    guint8 arg_gsm_system_info_v2_domain_valid;
    guint8 arg_gsm_system_info_v2_domain;
    guint8 arg_gsm_system_info_v2_service_capability_valid;
    guint8 arg_gsm_system_info_v2_service_capability;
    guint8 arg_gsm_system_info_v2_roaming_status_valid;
    guint8 arg_gsm_system_info_v2_roaming_status;
    guint8 arg_gsm_system_info_v2_forbidden_valid;
    guint8 arg_gsm_system_info_v2_forbidden;
    guint8 arg_gsm_system_info_v2_lac_valid;
    guint16 arg_gsm_system_info_v2_lac;
    guint8 arg_gsm_system_info_v2_cid_valid;
    guint32 arg_gsm_system_info_v2_cid;
    guint8 arg_gsm_system_info_v2_registration_reject_info_valid;
    guint8 arg_gsm_system_info_v2_registration_reject_domain;
    guint8 arg_gsm_system_info_v2_registration_reject_cause;
    guint8 arg_gsm_system_info_v2_network_id_valid;
    gchar arg_gsm_system_info_v2_mcc[4];
    gchar arg_gsm_system_info_v2_mnc[4];
    guint8 arg_gsm_system_info_v2_egprs_support_valid;
    guint8 arg_gsm_system_info_v2_egprs_support;
    guint8 arg_gsm_system_info_v2_dtm_support_valid;
    guint8 arg_gsm_system_info_v2_dtm_support;

    /* HDR System Info */
    gboolean arg_hdr_system_info_set;
    guint8 arg_hdr_system_info_domain_valid;
    guint8 arg_hdr_system_info_domain;
    guint8 arg_hdr_system_info_service_capability_valid;
    guint8 arg_hdr_system_info_service_capability;
    guint8 arg_hdr_system_info_roaming_status_valid;
    guint8 arg_hdr_system_info_roaming_status;
    guint8 arg_hdr_system_info_forbidden_valid;
    guint8 arg_hdr_system_info_forbidden;
    guint8 arg_hdr_system_info_prl_match_valid;
    guint8 arg_hdr_system_info_prl_match;
    guint8 arg_hdr_system_info_personality_valid;
    guint8 arg_hdr_system_info_personality;
    guint8 arg_hdr_system_info_protocol_revision_valid;
    guint8 arg_hdr_system_info_protocol_revision;
    guint8 arg_hdr_system_info_is_856_system_id_valid;
    gchar arg_hdr_system_info_is_856_system_id[17];

    /* CDMA System Info */
    gboolean arg_cdma_system_info_set;
    guint8 arg_cdma_system_info_domain_valid;
    guint8 arg_cdma_system_info_domain;
    guint8 arg_cdma_system_info_service_capability_valid;
    guint8 arg_cdma_system_info_service_capability;
    guint8 arg_cdma_system_info_roaming_status_valid;
    guint8 arg_cdma_system_info_roaming_status;
    guint8 arg_cdma_system_info_forbidden_valid;
    guint8 arg_cdma_system_info_forbidden;
    guint8 arg_cdma_system_info_prl_match_valid;
    guint8 arg_cdma_system_info_prl_match;
    guint8 arg_cdma_system_info_p_rev_valid;
    guint8 arg_cdma_system_info_p_rev;
    guint8 arg_cdma_system_info_base_station_p_rev_valid;
    guint8 arg_cdma_system_info_base_station_p_rev;
    guint8 arg_cdma_system_info_concurrent_service_support_valid;
    guint8 arg_cdma_system_info_concurrent_service_support;
    guint8 arg_cdma_system_info_cdma_system_id_valid;
    guint16 arg_cdma_system_info_sid;
    guint16 arg_cdma_system_info_nid;
    guint8 arg_cdma_system_info_base_station_info_valid;
    guint16 arg_cdma_system_info_base_station_id;
    gint32 arg_cdma_system_info_base_station_latitude;
    gint32 arg_cdma_system_info_base_station_longitude;
    guint8 arg_cdma_system_info_packet_zone_valid;
    guint16 arg_cdma_system_info_packet_zone;
    guint8 arg_cdma_system_info_network_id_valid;
    gchar arg_cdma_system_info_mcc[4];
    gchar arg_cdma_system_info_mnc[4];

    /* LTE Service Status */
    gboolean arg_lte_service_status_set;
    guint8 arg_lte_service_status_service_status;
    guint8 arg_lte_service_status_true_service_status;
    guint8 arg_lte_service_status_preferred_data_path;

    /* WCDMA Service Status */
    gboolean arg_wcdma_service_status_set;
    guint8 arg_wcdma_service_status_service_status;
    guint8 arg_wcdma_service_status_true_service_status;
    guint8 arg_wcdma_service_status_preferred_data_path;

    /* GSM Service Status */
    gboolean arg_gsm_service_status_set;
    guint8 arg_gsm_service_status_service_status;
    guint8 arg_gsm_service_status_true_service_status;
    guint8 arg_gsm_service_status_preferred_data_path;

    /* HDR Service Status */
    gboolean arg_hdr_service_status_set;
    guint8 arg_hdr_service_status_service_status;
    guint8 arg_hdr_service_status_preferred_data_path;

    /* CDMA Service Status */
    gboolean arg_cdma_service_status_set;
    guint8 arg_cdma_service_status_service_status;
    guint8 arg_cdma_service_status_preferred_data_path;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_TRACKING_AREA_CODE 0x50
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_DCNR_RESTRICTION_INFO 0x4F
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_EUTRA_WITH_NR5G_AVAILABILITY 0x4E
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_SYSTEM_INFO 0x4B
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_SERVICE_STATUS_INFO 0x4A
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_CELL_ACCESS_STATUS 0x44
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_TRACE_ID 0x34
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_REGISTRATION_DOMAIN 0x31
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION 0x2F
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_RESOLVED_MCC 0x2E
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_ROUTING_AREA_CODE 0x2D
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_ROUTING_AREA_CODE 0x2C
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_REGISTRATION_ZONE_ID 0x2B
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_DOMAIN 0x2A
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_IMS_VOICE_SUPPORT 0x29
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO 0x27
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT 0x26
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SYSTEM_INFO_V2 0x25
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS 0x24
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN 0x23
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN 0x22
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT 0x21
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS 0x20
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS 0x1F
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO 0x1E
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO 0x1D
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO 0x1C
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO 0x1B
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO 0x1A
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO_V2 0x19
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO_V2 0x18
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO_V2 0x17
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO 0x16
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO 0x15
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS 0x14
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS 0x13
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS 0x12
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS 0x11
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS 0x10
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_get_system_info_output_get_nr5g_tracking_area_code (
    QmiMessageNasGetSystemInfoOutput *self,
    GArray **value_nr5g_tracking_area_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_nr5g_tracking_area_code_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'NR5G Tracking Area Code' was not found in the message");
        return FALSE;
    }

    if (value_nr5g_tracking_area_code)
        *value_nr5g_tracking_area_code = self->arg_nr5g_tracking_area_code;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_dcnr_restriction_info (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_dcnr_restriction_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_dcnr_restriction_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'DCNR restriction Info' was not found in the message");
        return FALSE;
    }

    if (value_dcnr_restriction_info)
        *value_dcnr_restriction_info = (gboolean)(self->arg_dcnr_restriction_info);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_eutra_with_nr5g_availability (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_eutra_with_nr5g_availability,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_eutra_with_nr5g_availability_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'EUTRA with NR5G availability' was not found in the message");
        return FALSE;
    }

    if (value_eutra_with_nr5g_availability)
        *value_eutra_with_nr5g_availability = (gboolean)(self->arg_eutra_with_nr5g_availability);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_nr5g_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_nr5g_system_info_domain_valid,
    QmiNasNetworkServiceDomain *value_nr5g_system_info_domain,
    gboolean *value_nr5g_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *value_nr5g_system_info_service_capability,
    gboolean *value_nr5g_system_info_roaming_status_valid,
    QmiNasRoamingStatus *value_nr5g_system_info_roaming_status,
    gboolean *value_nr5g_system_info_forbidden_valid,
    gboolean *value_nr5g_system_info_forbidden,
    gboolean *value_nr5g_system_info_lac_valid,
    guint16 *value_nr5g_system_info_lac,
    gboolean *value_nr5g_system_info_cid_valid,
    guint32 *value_nr5g_system_info_cid,
    gboolean *value_nr5g_system_info_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *value_nr5g_system_info_registration_reject_domain,
    guint8 *value_nr5g_system_info_registration_reject_cause,
    gboolean *value_nr5g_system_info_network_id_valid,
    const gchar **value_nr5g_system_info_mcc,
    const gchar **value_nr5g_system_info_mnc,
    gboolean *value_nr5g_system_info_tac_valid,
    guint16 *value_nr5g_system_info_tac,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_nr5g_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'NR5G System Info' was not found in the message");
        return FALSE;
    }

    if (value_nr5g_system_info_domain_valid)
        *value_nr5g_system_info_domain_valid = (gboolean)(self->arg_nr5g_system_info_domain_valid);
    if (value_nr5g_system_info_domain)
        *value_nr5g_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_nr5g_system_info_domain);
    if (value_nr5g_system_info_service_capability_valid)
        *value_nr5g_system_info_service_capability_valid = (gboolean)(self->arg_nr5g_system_info_service_capability_valid);
    if (value_nr5g_system_info_service_capability)
        *value_nr5g_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_nr5g_system_info_service_capability);
    if (value_nr5g_system_info_roaming_status_valid)
        *value_nr5g_system_info_roaming_status_valid = (gboolean)(self->arg_nr5g_system_info_roaming_status_valid);
    if (value_nr5g_system_info_roaming_status)
        *value_nr5g_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_nr5g_system_info_roaming_status);
    if (value_nr5g_system_info_forbidden_valid)
        *value_nr5g_system_info_forbidden_valid = (gboolean)(self->arg_nr5g_system_info_forbidden_valid);
    if (value_nr5g_system_info_forbidden)
        *value_nr5g_system_info_forbidden = (gboolean)(self->arg_nr5g_system_info_forbidden);
    if (value_nr5g_system_info_lac_valid)
        *value_nr5g_system_info_lac_valid = (gboolean)(self->arg_nr5g_system_info_lac_valid);
    if (value_nr5g_system_info_lac)
        *value_nr5g_system_info_lac = self->arg_nr5g_system_info_lac;
    if (value_nr5g_system_info_cid_valid)
        *value_nr5g_system_info_cid_valid = (gboolean)(self->arg_nr5g_system_info_cid_valid);
    if (value_nr5g_system_info_cid)
        *value_nr5g_system_info_cid = self->arg_nr5g_system_info_cid;
    if (value_nr5g_system_info_registration_reject_info_valid)
        *value_nr5g_system_info_registration_reject_info_valid = (gboolean)(self->arg_nr5g_system_info_registration_reject_info_valid);
    if (value_nr5g_system_info_registration_reject_domain)
        *value_nr5g_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_nr5g_system_info_registration_reject_domain);
    if (value_nr5g_system_info_registration_reject_cause)
        *value_nr5g_system_info_registration_reject_cause = self->arg_nr5g_system_info_registration_reject_cause;
    if (value_nr5g_system_info_network_id_valid)
        *value_nr5g_system_info_network_id_valid = (gboolean)(self->arg_nr5g_system_info_network_id_valid);
    if (value_nr5g_system_info_mcc)
        *value_nr5g_system_info_mcc = self->arg_nr5g_system_info_mcc;
    if (value_nr5g_system_info_mnc)
        *value_nr5g_system_info_mnc = self->arg_nr5g_system_info_mnc;
    if (value_nr5g_system_info_tac_valid)
        *value_nr5g_system_info_tac_valid = (gboolean)(self->arg_nr5g_system_info_tac_valid);
    if (value_nr5g_system_info_tac)
        *value_nr5g_system_info_tac = self->arg_nr5g_system_info_tac;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_nr5g_service_status_info (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *value_nr5g_service_status_info_service_status,
    QmiNasServiceStatus *value_nr5g_service_status_info_true_service_status,
    gboolean *value_nr5g_service_status_info_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_nr5g_service_status_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'NR5G Service Status Info' was not found in the message");
        return FALSE;
    }

    if (value_nr5g_service_status_info_service_status)
        *value_nr5g_service_status_info_service_status = (QmiNasServiceStatus)(self->arg_nr5g_service_status_info_service_status);
    if (value_nr5g_service_status_info_true_service_status)
        *value_nr5g_service_status_info_true_service_status = (QmiNasServiceStatus)(self->arg_nr5g_service_status_info_true_service_status);
    if (value_nr5g_service_status_info_preferred_data_path)
        *value_nr5g_service_status_info_preferred_data_path = (gboolean)(self->arg_nr5g_service_status_info_preferred_data_path);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_lte_cell_access_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasLteCellAccessStatus *value_lte_cell_access_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_cell_access_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Cell Access Status' was not found in the message");
        return FALSE;
    }

    if (value_lte_cell_access_status)
        *value_lte_cell_access_status = (QmiNasLteCellAccessStatus)(self->arg_lte_cell_access_status);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_lte_embms_coverage_info_trace_id (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *value_lte_embms_coverage_info_trace_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_embms_coverage_info_trace_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE eMBMS Coverage Info Trace ID' was not found in the message");
        return FALSE;
    }

    if (value_lte_embms_coverage_info_trace_id)
        *value_lte_embms_coverage_info_trace_id = self->arg_lte_embms_coverage_info_trace_id;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_lte_registration_domain (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasLteRegistrationDomain *value_lte_registration_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_registration_domain_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Registration Domain' was not found in the message");
        return FALSE;
    }

    if (value_lte_registration_domain)
        *value_lte_registration_domain = (QmiNasLteRegistrationDomain)(self->arg_lte_registration_domain);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_network_selection_registration_restriction (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasNetworkSelectionRegistrationRestriction *value_network_selection_registration_restriction,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_selection_registration_restriction_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Selection Registration Restriction' was not found in the message");
        return FALSE;
    }

    if (value_network_selection_registration_restriction)
        *value_network_selection_registration_restriction = (QmiNasNetworkSelectionRegistrationRestriction)(self->arg_network_selection_registration_restriction);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_cdma_resolved_mcc (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *value_cdma_resolved_mcc,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_resolved_mcc_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Resolved MCC' was not found in the message");
        return FALSE;
    }

    if (value_cdma_resolved_mcc)
        *value_cdma_resolved_mcc = self->arg_cdma_resolved_mcc;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_wcdma_routing_area_code (
    QmiMessageNasGetSystemInfoOutput *self,
    guint8 *value_wcdma_routing_area_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_routing_area_code_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Routing Area Code' was not found in the message");
        return FALSE;
    }

    if (value_wcdma_routing_area_code)
        *value_wcdma_routing_area_code = self->arg_wcdma_routing_area_code;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_gsm_routing_area_code (
    QmiMessageNasGetSystemInfoOutput *self,
    guint8 *value_gsm_routing_area_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_routing_area_code_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Routing Area Code' was not found in the message");
        return FALSE;
    }

    if (value_gsm_routing_area_code)
        *value_gsm_routing_area_code = self->arg_gsm_routing_area_code;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_cdma_registration_zone_id (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *value_cdma_registration_zone_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_registration_zone_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Registration Zone ID' was not found in the message");
        return FALSE;
    }

    if (value_cdma_registration_zone_id)
        *value_cdma_registration_zone_id = self->arg_cdma_registration_zone_id;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_lte_voice_domain (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasLteVoiceDomain *value_lte_voice_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_voice_domain_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Voice Domain' was not found in the message");
        return FALSE;
    }

    if (value_lte_voice_domain)
        *value_lte_voice_domain = (QmiNasLteVoiceDomain)(self->arg_lte_voice_domain);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_ims_voice_support (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_ims_voice_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ims_voice_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'IMS Voice Support' was not found in the message");
        return FALSE;
    }

    if (value_ims_voice_support)
        *value_ims_voice_support = (gboolean)(self->arg_ims_voice_support);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_sim_reject_info (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasSimRejectState *value_sim_reject_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sim_reject_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SIM Reject Info' was not found in the message");
        return FALSE;
    }

    if (value_sim_reject_info)
        *value_sim_reject_info = (QmiNasSimRejectState)(self->arg_sim_reject_info);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_lte_embms_coverage_info_support (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_lte_embms_coverage_info_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_embms_coverage_info_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE eMBMS Coverage Info Support' was not found in the message");
        return FALSE;
    }

    if (value_lte_embms_coverage_info_support)
        *value_lte_embms_coverage_info_support = (gboolean)(self->arg_lte_embms_coverage_info_support);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_td_scdma_system_info_v2 (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_td_scdma_system_info_v2_domain_valid,
    QmiNasNetworkServiceDomain *value_td_scdma_system_info_v2_domain,
    gboolean *value_td_scdma_system_info_v2_service_capability_valid,
    QmiNasNetworkServiceDomain *value_td_scdma_system_info_v2_service_capability,
    gboolean *value_td_scdma_system_info_v2_roaming_status_valid,
    QmiNasRoamingStatus *value_td_scdma_system_info_v2_roaming_status,
    gboolean *value_td_scdma_system_info_v2_forbidden_valid,
    gboolean *value_td_scdma_system_info_v2_forbidden,
    gboolean *value_td_scdma_system_info_v2_lac_valid,
    guint16 *value_td_scdma_system_info_v2_lac,
    gboolean *value_td_scdma_system_info_v2_cid_valid,
    guint32 *value_td_scdma_system_info_v2_cid,
    gboolean *value_td_scdma_system_info_v2_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *value_td_scdma_system_info_v2_registration_reject_domain,
    QmiNasRejectCause *value_td_scdma_system_info_v2_registration_reject_cause,
    gboolean *value_td_scdma_system_info_v2_network_id_valid,
    const gchar **value_td_scdma_system_info_v2_mcc,
    const gchar **value_td_scdma_system_info_v2_mnc,
    gboolean *value_td_scdma_system_info_v2_hs_call_status_valid,
    QmiNasWcdmaHsService *value_td_scdma_system_info_v2_hs_call_status,
    gboolean *value_td_scdma_system_info_v2_hs_service_valid,
    QmiNasWcdmaHsService *value_td_scdma_system_info_v2_hs_service,
    gboolean *value_td_scdma_system_info_v2_cell_parameter_id_valid,
    guint16 *value_td_scdma_system_info_v2_cell_parameter_id,
    gboolean *value_td_scdma_system_info_v2_cell_broadcast_support_valid,
    QmiNasCellBroadcastCapability *value_td_scdma_system_info_v2_cell_broadcast_support,
    gboolean *value_td_scdma_system_info_v2_cs_call_barring_status_valid,
    QmiNasCallBarringStatus *value_td_scdma_system_info_v2_cs_call_barring_status,
    gboolean *value_td_scdma_system_info_v2_ps_call_barring_status_valid,
    QmiNasCallBarringStatus *value_td_scdma_system_info_v2_ps_call_barring_status,
    gboolean *value_td_scdma_system_info_v2_cipher_domain_valid,
    QmiNasNetworkServiceDomain *value_td_scdma_system_info_v2_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scdma_system_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCDMA System Info v2' was not found in the message");
        return FALSE;
    }

    if (value_td_scdma_system_info_v2_domain_valid)
        *value_td_scdma_system_info_v2_domain_valid = (gboolean)(self->arg_td_scdma_system_info_v2_domain_valid);
    if (value_td_scdma_system_info_v2_domain)
        *value_td_scdma_system_info_v2_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scdma_system_info_v2_domain);
    if (value_td_scdma_system_info_v2_service_capability_valid)
        *value_td_scdma_system_info_v2_service_capability_valid = (gboolean)(self->arg_td_scdma_system_info_v2_service_capability_valid);
    if (value_td_scdma_system_info_v2_service_capability)
        *value_td_scdma_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)(self->arg_td_scdma_system_info_v2_service_capability);
    if (value_td_scdma_system_info_v2_roaming_status_valid)
        *value_td_scdma_system_info_v2_roaming_status_valid = (gboolean)(self->arg_td_scdma_system_info_v2_roaming_status_valid);
    if (value_td_scdma_system_info_v2_roaming_status)
        *value_td_scdma_system_info_v2_roaming_status = (QmiNasRoamingStatus)(self->arg_td_scdma_system_info_v2_roaming_status);
    if (value_td_scdma_system_info_v2_forbidden_valid)
        *value_td_scdma_system_info_v2_forbidden_valid = (gboolean)(self->arg_td_scdma_system_info_v2_forbidden_valid);
    if (value_td_scdma_system_info_v2_forbidden)
        *value_td_scdma_system_info_v2_forbidden = (gboolean)(self->arg_td_scdma_system_info_v2_forbidden);
    if (value_td_scdma_system_info_v2_lac_valid)
        *value_td_scdma_system_info_v2_lac_valid = (gboolean)(self->arg_td_scdma_system_info_v2_lac_valid);
    if (value_td_scdma_system_info_v2_lac)
        *value_td_scdma_system_info_v2_lac = self->arg_td_scdma_system_info_v2_lac;
    if (value_td_scdma_system_info_v2_cid_valid)
        *value_td_scdma_system_info_v2_cid_valid = (gboolean)(self->arg_td_scdma_system_info_v2_cid_valid);
    if (value_td_scdma_system_info_v2_cid)
        *value_td_scdma_system_info_v2_cid = self->arg_td_scdma_system_info_v2_cid;
    if (value_td_scdma_system_info_v2_registration_reject_info_valid)
        *value_td_scdma_system_info_v2_registration_reject_info_valid = (gboolean)(self->arg_td_scdma_system_info_v2_registration_reject_info_valid);
    if (value_td_scdma_system_info_v2_registration_reject_domain)
        *value_td_scdma_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scdma_system_info_v2_registration_reject_domain);
    if (value_td_scdma_system_info_v2_registration_reject_cause)
        *value_td_scdma_system_info_v2_registration_reject_cause = (QmiNasRejectCause)(self->arg_td_scdma_system_info_v2_registration_reject_cause);
    if (value_td_scdma_system_info_v2_network_id_valid)
        *value_td_scdma_system_info_v2_network_id_valid = (gboolean)(self->arg_td_scdma_system_info_v2_network_id_valid);
    if (value_td_scdma_system_info_v2_mcc)
        *value_td_scdma_system_info_v2_mcc = self->arg_td_scdma_system_info_v2_mcc;
    if (value_td_scdma_system_info_v2_mnc)
        *value_td_scdma_system_info_v2_mnc = self->arg_td_scdma_system_info_v2_mnc;
    if (value_td_scdma_system_info_v2_hs_call_status_valid)
        *value_td_scdma_system_info_v2_hs_call_status_valid = (gboolean)(self->arg_td_scdma_system_info_v2_hs_call_status_valid);
    if (value_td_scdma_system_info_v2_hs_call_status)
        *value_td_scdma_system_info_v2_hs_call_status = (QmiNasWcdmaHsService)(self->arg_td_scdma_system_info_v2_hs_call_status);
    if (value_td_scdma_system_info_v2_hs_service_valid)
        *value_td_scdma_system_info_v2_hs_service_valid = (gboolean)(self->arg_td_scdma_system_info_v2_hs_service_valid);
    if (value_td_scdma_system_info_v2_hs_service)
        *value_td_scdma_system_info_v2_hs_service = (QmiNasWcdmaHsService)(self->arg_td_scdma_system_info_v2_hs_service);
    if (value_td_scdma_system_info_v2_cell_parameter_id_valid)
        *value_td_scdma_system_info_v2_cell_parameter_id_valid = (gboolean)(self->arg_td_scdma_system_info_v2_cell_parameter_id_valid);
    if (value_td_scdma_system_info_v2_cell_parameter_id)
        *value_td_scdma_system_info_v2_cell_parameter_id = self->arg_td_scdma_system_info_v2_cell_parameter_id;
    if (value_td_scdma_system_info_v2_cell_broadcast_support_valid)
        *value_td_scdma_system_info_v2_cell_broadcast_support_valid = (gboolean)(self->arg_td_scdma_system_info_v2_cell_broadcast_support_valid);
    if (value_td_scdma_system_info_v2_cell_broadcast_support)
        *value_td_scdma_system_info_v2_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_td_scdma_system_info_v2_cell_broadcast_support);
    if (value_td_scdma_system_info_v2_cs_call_barring_status_valid)
        *value_td_scdma_system_info_v2_cs_call_barring_status_valid = (gboolean)(self->arg_td_scdma_system_info_v2_cs_call_barring_status_valid);
    if (value_td_scdma_system_info_v2_cs_call_barring_status)
        *value_td_scdma_system_info_v2_cs_call_barring_status = (QmiNasCallBarringStatus)(self->arg_td_scdma_system_info_v2_cs_call_barring_status);
    if (value_td_scdma_system_info_v2_ps_call_barring_status_valid)
        *value_td_scdma_system_info_v2_ps_call_barring_status_valid = (gboolean)(self->arg_td_scdma_system_info_v2_ps_call_barring_status_valid);
    if (value_td_scdma_system_info_v2_ps_call_barring_status)
        *value_td_scdma_system_info_v2_ps_call_barring_status = (QmiNasCallBarringStatus)(self->arg_td_scdma_system_info_v2_ps_call_barring_status);
    if (value_td_scdma_system_info_v2_cipher_domain_valid)
        *value_td_scdma_system_info_v2_cipher_domain_valid = (gboolean)(self->arg_td_scdma_system_info_v2_cipher_domain_valid);
    if (value_td_scdma_system_info_v2_cipher_domain)
        *value_td_scdma_system_info_v2_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scdma_system_info_v2_cipher_domain);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_td_scdma_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *value_td_scdma_service_status_service_status,
    QmiNasServiceStatus *value_td_scdma_service_status_true_service_status,
    gboolean *value_td_scdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (value_td_scdma_service_status_service_status)
        *value_td_scdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_td_scdma_service_status_service_status);
    if (value_td_scdma_service_status_true_service_status)
        *value_td_scdma_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_td_scdma_service_status_true_service_status);
    if (value_td_scdma_service_status_preferred_data_path)
        *value_td_scdma_service_status_preferred_data_path = (gboolean)(self->arg_td_scdma_service_status_preferred_data_path);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_wcdma_cipher_domain (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasNetworkServiceDomain *value_wcdma_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_cipher_domain_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Cipher Domain' was not found in the message");
        return FALSE;
    }

    if (value_wcdma_cipher_domain)
        *value_wcdma_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_cipher_domain);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_gsm_cipher_domain (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasNetworkServiceDomain *value_gsm_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_cipher_domain_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Cipher Domain' was not found in the message");
        return FALSE;
    }

    if (value_gsm_cipher_domain)
        *value_gsm_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_cipher_domain);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_lte_voice_support (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_lte_voice_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_voice_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Voice Support' was not found in the message");
        return FALSE;
    }

    if (value_lte_voice_support)
        *value_lte_voice_support = (gboolean)(self->arg_lte_voice_support);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_wcdma_call_barring_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasCallBarringStatus *value_wcdma_call_barring_status_cs_status,
    QmiNasCallBarringStatus *value_wcdma_call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (value_wcdma_call_barring_status_cs_status)
        *value_wcdma_call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_wcdma_call_barring_status_cs_status);
    if (value_wcdma_call_barring_status_ps_status)
        *value_wcdma_call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_wcdma_call_barring_status_ps_status);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_gsm_call_barring_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasCallBarringStatus *value_gsm_call_barring_status_cs_status,
    QmiNasCallBarringStatus *value_gsm_call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (value_gsm_call_barring_status_cs_status)
        *value_gsm_call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_gsm_call_barring_status_cs_status);
    if (value_gsm_call_barring_status_ps_status)
        *value_gsm_call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_gsm_call_barring_status_ps_status);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_additional_lte_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *value_additional_lte_system_info_geo_system_index,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_lte_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional LTE System Info' was not found in the message");
        return FALSE;
    }

    if (value_additional_lte_system_info_geo_system_index)
        *value_additional_lte_system_info_geo_system_index = self->arg_additional_lte_system_info_geo_system_index;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_additional_wcdma_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *value_additional_wcdma_system_info_geo_system_index,
    QmiNasCellBroadcastCapability *value_additional_wcdma_system_info_cell_broadcast_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_wcdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional WCDMA System Info' was not found in the message");
        return FALSE;
    }

    if (value_additional_wcdma_system_info_geo_system_index)
        *value_additional_wcdma_system_info_geo_system_index = self->arg_additional_wcdma_system_info_geo_system_index;
    if (value_additional_wcdma_system_info_cell_broadcast_support)
        *value_additional_wcdma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_additional_wcdma_system_info_cell_broadcast_support);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_additional_gsm_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *value_additional_gsm_system_info_geo_system_index,
    QmiNasCellBroadcastCapability *value_additional_gsm_system_info_cell_broadcast_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_gsm_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional GSM System Info' was not found in the message");
        return FALSE;
    }

    if (value_additional_gsm_system_info_geo_system_index)
        *value_additional_gsm_system_info_geo_system_index = self->arg_additional_gsm_system_info_geo_system_index;
    if (value_additional_gsm_system_info_cell_broadcast_support)
        *value_additional_gsm_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_additional_gsm_system_info_cell_broadcast_support);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_additional_hdr_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *value_additional_hdr_system_info_geo_system_index,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_hdr_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional HDR System Info' was not found in the message");
        return FALSE;
    }

    if (value_additional_hdr_system_info_geo_system_index)
        *value_additional_hdr_system_info_geo_system_index = self->arg_additional_hdr_system_info_geo_system_index;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_additional_cdma_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *value_additional_cdma_system_info_geo_system_index,
    guint16 *value_additional_cdma_system_info_registration_period,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (value_additional_cdma_system_info_geo_system_index)
        *value_additional_cdma_system_info_geo_system_index = self->arg_additional_cdma_system_info_geo_system_index;
    if (value_additional_cdma_system_info_registration_period)
        *value_additional_cdma_system_info_registration_period = self->arg_additional_cdma_system_info_registration_period;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_lte_system_info_v2 (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_lte_system_info_v2_domain_valid,
    QmiNasNetworkServiceDomain *value_lte_system_info_v2_domain,
    gboolean *value_lte_system_info_v2_service_capability_valid,
    QmiNasNetworkServiceDomain *value_lte_system_info_v2_service_capability,
    gboolean *value_lte_system_info_v2_roaming_status_valid,
    QmiNasRoamingStatus *value_lte_system_info_v2_roaming_status,
    gboolean *value_lte_system_info_v2_forbidden_valid,
    gboolean *value_lte_system_info_v2_forbidden,
    gboolean *value_lte_system_info_v2_lac_valid,
    guint16 *value_lte_system_info_v2_lac,
    gboolean *value_lte_system_info_v2_cid_valid,
    guint32 *value_lte_system_info_v2_cid,
    gboolean *value_lte_system_info_v2_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *value_lte_system_info_v2_registration_reject_domain,
    QmiNasRejectCause *value_lte_system_info_v2_registration_reject_cause,
    gboolean *value_lte_system_info_v2_network_id_valid,
    const gchar **value_lte_system_info_v2_mcc,
    const gchar **value_lte_system_info_v2_mnc,
    gboolean *value_lte_system_info_v2_tac_valid,
    guint16 *value_lte_system_info_v2_tac,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_system_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE System Info v2' was not found in the message");
        return FALSE;
    }

    if (value_lte_system_info_v2_domain_valid)
        *value_lte_system_info_v2_domain_valid = (gboolean)(self->arg_lte_system_info_v2_domain_valid);
    if (value_lte_system_info_v2_domain)
        *value_lte_system_info_v2_domain = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_v2_domain);
    if (value_lte_system_info_v2_service_capability_valid)
        *value_lte_system_info_v2_service_capability_valid = (gboolean)(self->arg_lte_system_info_v2_service_capability_valid);
    if (value_lte_system_info_v2_service_capability)
        *value_lte_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_v2_service_capability);
    if (value_lte_system_info_v2_roaming_status_valid)
        *value_lte_system_info_v2_roaming_status_valid = (gboolean)(self->arg_lte_system_info_v2_roaming_status_valid);
    if (value_lte_system_info_v2_roaming_status)
        *value_lte_system_info_v2_roaming_status = (QmiNasRoamingStatus)(self->arg_lte_system_info_v2_roaming_status);
    if (value_lte_system_info_v2_forbidden_valid)
        *value_lte_system_info_v2_forbidden_valid = (gboolean)(self->arg_lte_system_info_v2_forbidden_valid);
    if (value_lte_system_info_v2_forbidden)
        *value_lte_system_info_v2_forbidden = (gboolean)(self->arg_lte_system_info_v2_forbidden);
    if (value_lte_system_info_v2_lac_valid)
        *value_lte_system_info_v2_lac_valid = (gboolean)(self->arg_lte_system_info_v2_lac_valid);
    if (value_lte_system_info_v2_lac)
        *value_lte_system_info_v2_lac = self->arg_lte_system_info_v2_lac;
    if (value_lte_system_info_v2_cid_valid)
        *value_lte_system_info_v2_cid_valid = (gboolean)(self->arg_lte_system_info_v2_cid_valid);
    if (value_lte_system_info_v2_cid)
        *value_lte_system_info_v2_cid = self->arg_lte_system_info_v2_cid;
    if (value_lte_system_info_v2_registration_reject_info_valid)
        *value_lte_system_info_v2_registration_reject_info_valid = (gboolean)(self->arg_lte_system_info_v2_registration_reject_info_valid);
    if (value_lte_system_info_v2_registration_reject_domain)
        *value_lte_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_v2_registration_reject_domain);
    if (value_lte_system_info_v2_registration_reject_cause)
        *value_lte_system_info_v2_registration_reject_cause = (QmiNasRejectCause)(self->arg_lte_system_info_v2_registration_reject_cause);
    if (value_lte_system_info_v2_network_id_valid)
        *value_lte_system_info_v2_network_id_valid = (gboolean)(self->arg_lte_system_info_v2_network_id_valid);
    if (value_lte_system_info_v2_mcc)
        *value_lte_system_info_v2_mcc = self->arg_lte_system_info_v2_mcc;
    if (value_lte_system_info_v2_mnc)
        *value_lte_system_info_v2_mnc = self->arg_lte_system_info_v2_mnc;
    if (value_lte_system_info_v2_tac_valid)
        *value_lte_system_info_v2_tac_valid = (gboolean)(self->arg_lte_system_info_v2_tac_valid);
    if (value_lte_system_info_v2_tac)
        *value_lte_system_info_v2_tac = self->arg_lte_system_info_v2_tac;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_wcdma_system_info_v2 (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_wcdma_system_info_v2_domain_valid,
    QmiNasNetworkServiceDomain *value_wcdma_system_info_v2_domain,
    gboolean *value_wcdma_system_info_v2_service_capability_valid,
    QmiNasNetworkServiceDomain *value_wcdma_system_info_v2_service_capability,
    gboolean *value_wcdma_system_info_v2_roaming_status_valid,
    QmiNasRoamingStatus *value_wcdma_system_info_v2_roaming_status,
    gboolean *value_wcdma_system_info_v2_forbidden_valid,
    gboolean *value_wcdma_system_info_v2_forbidden,
    gboolean *value_wcdma_system_info_v2_lac_valid,
    guint16 *value_wcdma_system_info_v2_lac,
    gboolean *value_wcdma_system_info_v2_cid_valid,
    guint32 *value_wcdma_system_info_v2_cid,
    gboolean *value_wcdma_system_info_v2_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *value_wcdma_system_info_v2_registration_reject_domain,
    QmiNasRejectCause *value_wcdma_system_info_v2_registration_reject_cause,
    gboolean *value_wcdma_system_info_v2_network_id_valid,
    const gchar **value_wcdma_system_info_v2_mcc,
    const gchar **value_wcdma_system_info_v2_mnc,
    gboolean *value_wcdma_system_info_v2_hs_call_status_valid,
    QmiNasWcdmaHsService *value_wcdma_system_info_v2_hs_call_status,
    gboolean *value_wcdma_system_info_v2_hs_service_valid,
    QmiNasWcdmaHsService *value_wcdma_system_info_v2_hs_service,
    gboolean *value_wcdma_system_info_v2_primary_scrambling_code_valid,
    guint16 *value_wcdma_system_info_v2_primary_scrambling_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_system_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA System Info v2' was not found in the message");
        return FALSE;
    }

    if (value_wcdma_system_info_v2_domain_valid)
        *value_wcdma_system_info_v2_domain_valid = (gboolean)(self->arg_wcdma_system_info_v2_domain_valid);
    if (value_wcdma_system_info_v2_domain)
        *value_wcdma_system_info_v2_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_v2_domain);
    if (value_wcdma_system_info_v2_service_capability_valid)
        *value_wcdma_system_info_v2_service_capability_valid = (gboolean)(self->arg_wcdma_system_info_v2_service_capability_valid);
    if (value_wcdma_system_info_v2_service_capability)
        *value_wcdma_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_v2_service_capability);
    if (value_wcdma_system_info_v2_roaming_status_valid)
        *value_wcdma_system_info_v2_roaming_status_valid = (gboolean)(self->arg_wcdma_system_info_v2_roaming_status_valid);
    if (value_wcdma_system_info_v2_roaming_status)
        *value_wcdma_system_info_v2_roaming_status = (QmiNasRoamingStatus)(self->arg_wcdma_system_info_v2_roaming_status);
    if (value_wcdma_system_info_v2_forbidden_valid)
        *value_wcdma_system_info_v2_forbidden_valid = (gboolean)(self->arg_wcdma_system_info_v2_forbidden_valid);
    if (value_wcdma_system_info_v2_forbidden)
        *value_wcdma_system_info_v2_forbidden = (gboolean)(self->arg_wcdma_system_info_v2_forbidden);
    if (value_wcdma_system_info_v2_lac_valid)
        *value_wcdma_system_info_v2_lac_valid = (gboolean)(self->arg_wcdma_system_info_v2_lac_valid);
    if (value_wcdma_system_info_v2_lac)
        *value_wcdma_system_info_v2_lac = self->arg_wcdma_system_info_v2_lac;
    if (value_wcdma_system_info_v2_cid_valid)
        *value_wcdma_system_info_v2_cid_valid = (gboolean)(self->arg_wcdma_system_info_v2_cid_valid);
    if (value_wcdma_system_info_v2_cid)
        *value_wcdma_system_info_v2_cid = self->arg_wcdma_system_info_v2_cid;
    if (value_wcdma_system_info_v2_registration_reject_info_valid)
        *value_wcdma_system_info_v2_registration_reject_info_valid = (gboolean)(self->arg_wcdma_system_info_v2_registration_reject_info_valid);
    if (value_wcdma_system_info_v2_registration_reject_domain)
        *value_wcdma_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_v2_registration_reject_domain);
    if (value_wcdma_system_info_v2_registration_reject_cause)
        *value_wcdma_system_info_v2_registration_reject_cause = (QmiNasRejectCause)(self->arg_wcdma_system_info_v2_registration_reject_cause);
    if (value_wcdma_system_info_v2_network_id_valid)
        *value_wcdma_system_info_v2_network_id_valid = (gboolean)(self->arg_wcdma_system_info_v2_network_id_valid);
    if (value_wcdma_system_info_v2_mcc)
        *value_wcdma_system_info_v2_mcc = self->arg_wcdma_system_info_v2_mcc;
    if (value_wcdma_system_info_v2_mnc)
        *value_wcdma_system_info_v2_mnc = self->arg_wcdma_system_info_v2_mnc;
    if (value_wcdma_system_info_v2_hs_call_status_valid)
        *value_wcdma_system_info_v2_hs_call_status_valid = (gboolean)(self->arg_wcdma_system_info_v2_hs_call_status_valid);
    if (value_wcdma_system_info_v2_hs_call_status)
        *value_wcdma_system_info_v2_hs_call_status = (QmiNasWcdmaHsService)(self->arg_wcdma_system_info_v2_hs_call_status);
    if (value_wcdma_system_info_v2_hs_service_valid)
        *value_wcdma_system_info_v2_hs_service_valid = (gboolean)(self->arg_wcdma_system_info_v2_hs_service_valid);
    if (value_wcdma_system_info_v2_hs_service)
        *value_wcdma_system_info_v2_hs_service = (QmiNasWcdmaHsService)(self->arg_wcdma_system_info_v2_hs_service);
    if (value_wcdma_system_info_v2_primary_scrambling_code_valid)
        *value_wcdma_system_info_v2_primary_scrambling_code_valid = (gboolean)(self->arg_wcdma_system_info_v2_primary_scrambling_code_valid);
    if (value_wcdma_system_info_v2_primary_scrambling_code)
        *value_wcdma_system_info_v2_primary_scrambling_code = self->arg_wcdma_system_info_v2_primary_scrambling_code;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_gsm_system_info_v2 (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_gsm_system_info_v2_domain_valid,
    QmiNasNetworkServiceDomain *value_gsm_system_info_v2_domain,
    gboolean *value_gsm_system_info_v2_service_capability_valid,
    QmiNasNetworkServiceDomain *value_gsm_system_info_v2_service_capability,
    gboolean *value_gsm_system_info_v2_roaming_status_valid,
    QmiNasRoamingStatus *value_gsm_system_info_v2_roaming_status,
    gboolean *value_gsm_system_info_v2_forbidden_valid,
    gboolean *value_gsm_system_info_v2_forbidden,
    gboolean *value_gsm_system_info_v2_lac_valid,
    guint16 *value_gsm_system_info_v2_lac,
    gboolean *value_gsm_system_info_v2_cid_valid,
    guint32 *value_gsm_system_info_v2_cid,
    gboolean *value_gsm_system_info_v2_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *value_gsm_system_info_v2_registration_reject_domain,
    QmiNasRejectCause *value_gsm_system_info_v2_registration_reject_cause,
    gboolean *value_gsm_system_info_v2_network_id_valid,
    const gchar **value_gsm_system_info_v2_mcc,
    const gchar **value_gsm_system_info_v2_mnc,
    gboolean *value_gsm_system_info_v2_egprs_support_valid,
    gboolean *value_gsm_system_info_v2_egprs_support,
    gboolean *value_gsm_system_info_v2_dtm_support_valid,
    gboolean *value_gsm_system_info_v2_dtm_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_system_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM System Info v2' was not found in the message");
        return FALSE;
    }

    if (value_gsm_system_info_v2_domain_valid)
        *value_gsm_system_info_v2_domain_valid = (gboolean)(self->arg_gsm_system_info_v2_domain_valid);
    if (value_gsm_system_info_v2_domain)
        *value_gsm_system_info_v2_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_v2_domain);
    if (value_gsm_system_info_v2_service_capability_valid)
        *value_gsm_system_info_v2_service_capability_valid = (gboolean)(self->arg_gsm_system_info_v2_service_capability_valid);
    if (value_gsm_system_info_v2_service_capability)
        *value_gsm_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_v2_service_capability);
    if (value_gsm_system_info_v2_roaming_status_valid)
        *value_gsm_system_info_v2_roaming_status_valid = (gboolean)(self->arg_gsm_system_info_v2_roaming_status_valid);
    if (value_gsm_system_info_v2_roaming_status)
        *value_gsm_system_info_v2_roaming_status = (QmiNasRoamingStatus)(self->arg_gsm_system_info_v2_roaming_status);
    if (value_gsm_system_info_v2_forbidden_valid)
        *value_gsm_system_info_v2_forbidden_valid = (gboolean)(self->arg_gsm_system_info_v2_forbidden_valid);
    if (value_gsm_system_info_v2_forbidden)
        *value_gsm_system_info_v2_forbidden = (gboolean)(self->arg_gsm_system_info_v2_forbidden);
    if (value_gsm_system_info_v2_lac_valid)
        *value_gsm_system_info_v2_lac_valid = (gboolean)(self->arg_gsm_system_info_v2_lac_valid);
    if (value_gsm_system_info_v2_lac)
        *value_gsm_system_info_v2_lac = self->arg_gsm_system_info_v2_lac;
    if (value_gsm_system_info_v2_cid_valid)
        *value_gsm_system_info_v2_cid_valid = (gboolean)(self->arg_gsm_system_info_v2_cid_valid);
    if (value_gsm_system_info_v2_cid)
        *value_gsm_system_info_v2_cid = self->arg_gsm_system_info_v2_cid;
    if (value_gsm_system_info_v2_registration_reject_info_valid)
        *value_gsm_system_info_v2_registration_reject_info_valid = (gboolean)(self->arg_gsm_system_info_v2_registration_reject_info_valid);
    if (value_gsm_system_info_v2_registration_reject_domain)
        *value_gsm_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_v2_registration_reject_domain);
    if (value_gsm_system_info_v2_registration_reject_cause)
        *value_gsm_system_info_v2_registration_reject_cause = (QmiNasRejectCause)(self->arg_gsm_system_info_v2_registration_reject_cause);
    if (value_gsm_system_info_v2_network_id_valid)
        *value_gsm_system_info_v2_network_id_valid = (gboolean)(self->arg_gsm_system_info_v2_network_id_valid);
    if (value_gsm_system_info_v2_mcc)
        *value_gsm_system_info_v2_mcc = self->arg_gsm_system_info_v2_mcc;
    if (value_gsm_system_info_v2_mnc)
        *value_gsm_system_info_v2_mnc = self->arg_gsm_system_info_v2_mnc;
    if (value_gsm_system_info_v2_egprs_support_valid)
        *value_gsm_system_info_v2_egprs_support_valid = (gboolean)(self->arg_gsm_system_info_v2_egprs_support_valid);
    if (value_gsm_system_info_v2_egprs_support)
        *value_gsm_system_info_v2_egprs_support = (gboolean)(self->arg_gsm_system_info_v2_egprs_support);
    if (value_gsm_system_info_v2_dtm_support_valid)
        *value_gsm_system_info_v2_dtm_support_valid = (gboolean)(self->arg_gsm_system_info_v2_dtm_support_valid);
    if (value_gsm_system_info_v2_dtm_support)
        *value_gsm_system_info_v2_dtm_support = (gboolean)(self->arg_gsm_system_info_v2_dtm_support);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_hdr_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_hdr_system_info_domain_valid,
    QmiNasNetworkServiceDomain *value_hdr_system_info_domain,
    gboolean *value_hdr_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *value_hdr_system_info_service_capability,
    gboolean *value_hdr_system_info_roaming_status_valid,
    QmiNasRoamingStatus *value_hdr_system_info_roaming_status,
    gboolean *value_hdr_system_info_forbidden_valid,
    gboolean *value_hdr_system_info_forbidden,
    gboolean *value_hdr_system_info_prl_match_valid,
    gboolean *value_hdr_system_info_prl_match,
    gboolean *value_hdr_system_info_personality_valid,
    QmiNasHdrPersonality *value_hdr_system_info_personality,
    gboolean *value_hdr_system_info_protocol_revision_valid,
    QmiNasHdrProtocolRevision *value_hdr_system_info_protocol_revision,
    gboolean *value_hdr_system_info_is_856_system_id_valid,
    const gchar **value_hdr_system_info_is_856_system_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR System Info' was not found in the message");
        return FALSE;
    }

    if (value_hdr_system_info_domain_valid)
        *value_hdr_system_info_domain_valid = (gboolean)(self->arg_hdr_system_info_domain_valid);
    if (value_hdr_system_info_domain)
        *value_hdr_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_hdr_system_info_domain);
    if (value_hdr_system_info_service_capability_valid)
        *value_hdr_system_info_service_capability_valid = (gboolean)(self->arg_hdr_system_info_service_capability_valid);
    if (value_hdr_system_info_service_capability)
        *value_hdr_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_hdr_system_info_service_capability);
    if (value_hdr_system_info_roaming_status_valid)
        *value_hdr_system_info_roaming_status_valid = (gboolean)(self->arg_hdr_system_info_roaming_status_valid);
    if (value_hdr_system_info_roaming_status)
        *value_hdr_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_hdr_system_info_roaming_status);
    if (value_hdr_system_info_forbidden_valid)
        *value_hdr_system_info_forbidden_valid = (gboolean)(self->arg_hdr_system_info_forbidden_valid);
    if (value_hdr_system_info_forbidden)
        *value_hdr_system_info_forbidden = (gboolean)(self->arg_hdr_system_info_forbidden);
    if (value_hdr_system_info_prl_match_valid)
        *value_hdr_system_info_prl_match_valid = (gboolean)(self->arg_hdr_system_info_prl_match_valid);
    if (value_hdr_system_info_prl_match)
        *value_hdr_system_info_prl_match = (gboolean)(self->arg_hdr_system_info_prl_match);
    if (value_hdr_system_info_personality_valid)
        *value_hdr_system_info_personality_valid = (gboolean)(self->arg_hdr_system_info_personality_valid);
    if (value_hdr_system_info_personality)
        *value_hdr_system_info_personality = (QmiNasHdrPersonality)(self->arg_hdr_system_info_personality);
    if (value_hdr_system_info_protocol_revision_valid)
        *value_hdr_system_info_protocol_revision_valid = (gboolean)(self->arg_hdr_system_info_protocol_revision_valid);
    if (value_hdr_system_info_protocol_revision)
        *value_hdr_system_info_protocol_revision = (QmiNasHdrProtocolRevision)(self->arg_hdr_system_info_protocol_revision);
    if (value_hdr_system_info_is_856_system_id_valid)
        *value_hdr_system_info_is_856_system_id_valid = (gboolean)(self->arg_hdr_system_info_is_856_system_id_valid);
    if (value_hdr_system_info_is_856_system_id)
        *value_hdr_system_info_is_856_system_id = self->arg_hdr_system_info_is_856_system_id;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_cdma_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *value_cdma_system_info_domain_valid,
    QmiNasNetworkServiceDomain *value_cdma_system_info_domain,
    gboolean *value_cdma_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *value_cdma_system_info_service_capability,
    gboolean *value_cdma_system_info_roaming_status_valid,
    QmiNasRoamingStatus *value_cdma_system_info_roaming_status,
    gboolean *value_cdma_system_info_forbidden_valid,
    gboolean *value_cdma_system_info_forbidden,
    gboolean *value_cdma_system_info_prl_match_valid,
    gboolean *value_cdma_system_info_prl_match,
    gboolean *value_cdma_system_info_p_rev_valid,
    guint8 *value_cdma_system_info_p_rev,
    gboolean *value_cdma_system_info_base_station_p_rev_valid,
    guint8 *value_cdma_system_info_base_station_p_rev,
    gboolean *value_cdma_system_info_concurrent_service_support_valid,
    gboolean *value_cdma_system_info_concurrent_service_support,
    gboolean *value_cdma_system_info_cdma_system_id_valid,
    guint16 *value_cdma_system_info_sid,
    guint16 *value_cdma_system_info_nid,
    gboolean *value_cdma_system_info_base_station_info_valid,
    guint16 *value_cdma_system_info_base_station_id,
    gint32 *value_cdma_system_info_base_station_latitude,
    gint32 *value_cdma_system_info_base_station_longitude,
    gboolean *value_cdma_system_info_packet_zone_valid,
    guint16 *value_cdma_system_info_packet_zone,
    gboolean *value_cdma_system_info_network_id_valid,
    const gchar **value_cdma_system_info_mcc,
    const gchar **value_cdma_system_info_mnc,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (value_cdma_system_info_domain_valid)
        *value_cdma_system_info_domain_valid = (gboolean)(self->arg_cdma_system_info_domain_valid);
    if (value_cdma_system_info_domain)
        *value_cdma_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_cdma_system_info_domain);
    if (value_cdma_system_info_service_capability_valid)
        *value_cdma_system_info_service_capability_valid = (gboolean)(self->arg_cdma_system_info_service_capability_valid);
    if (value_cdma_system_info_service_capability)
        *value_cdma_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_cdma_system_info_service_capability);
    if (value_cdma_system_info_roaming_status_valid)
        *value_cdma_system_info_roaming_status_valid = (gboolean)(self->arg_cdma_system_info_roaming_status_valid);
    if (value_cdma_system_info_roaming_status)
        *value_cdma_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_cdma_system_info_roaming_status);
    if (value_cdma_system_info_forbidden_valid)
        *value_cdma_system_info_forbidden_valid = (gboolean)(self->arg_cdma_system_info_forbidden_valid);
    if (value_cdma_system_info_forbidden)
        *value_cdma_system_info_forbidden = (gboolean)(self->arg_cdma_system_info_forbidden);
    if (value_cdma_system_info_prl_match_valid)
        *value_cdma_system_info_prl_match_valid = (gboolean)(self->arg_cdma_system_info_prl_match_valid);
    if (value_cdma_system_info_prl_match)
        *value_cdma_system_info_prl_match = (gboolean)(self->arg_cdma_system_info_prl_match);
    if (value_cdma_system_info_p_rev_valid)
        *value_cdma_system_info_p_rev_valid = (gboolean)(self->arg_cdma_system_info_p_rev_valid);
    if (value_cdma_system_info_p_rev)
        *value_cdma_system_info_p_rev = self->arg_cdma_system_info_p_rev;
    if (value_cdma_system_info_base_station_p_rev_valid)
        *value_cdma_system_info_base_station_p_rev_valid = (gboolean)(self->arg_cdma_system_info_base_station_p_rev_valid);
    if (value_cdma_system_info_base_station_p_rev)
        *value_cdma_system_info_base_station_p_rev = self->arg_cdma_system_info_base_station_p_rev;
    if (value_cdma_system_info_concurrent_service_support_valid)
        *value_cdma_system_info_concurrent_service_support_valid = (gboolean)(self->arg_cdma_system_info_concurrent_service_support_valid);
    if (value_cdma_system_info_concurrent_service_support)
        *value_cdma_system_info_concurrent_service_support = (gboolean)(self->arg_cdma_system_info_concurrent_service_support);
    if (value_cdma_system_info_cdma_system_id_valid)
        *value_cdma_system_info_cdma_system_id_valid = (gboolean)(self->arg_cdma_system_info_cdma_system_id_valid);
    if (value_cdma_system_info_sid)
        *value_cdma_system_info_sid = self->arg_cdma_system_info_sid;
    if (value_cdma_system_info_nid)
        *value_cdma_system_info_nid = self->arg_cdma_system_info_nid;
    if (value_cdma_system_info_base_station_info_valid)
        *value_cdma_system_info_base_station_info_valid = (gboolean)(self->arg_cdma_system_info_base_station_info_valid);
    if (value_cdma_system_info_base_station_id)
        *value_cdma_system_info_base_station_id = self->arg_cdma_system_info_base_station_id;
    if (value_cdma_system_info_base_station_latitude)
        *value_cdma_system_info_base_station_latitude = self->arg_cdma_system_info_base_station_latitude;
    if (value_cdma_system_info_base_station_longitude)
        *value_cdma_system_info_base_station_longitude = self->arg_cdma_system_info_base_station_longitude;
    if (value_cdma_system_info_packet_zone_valid)
        *value_cdma_system_info_packet_zone_valid = (gboolean)(self->arg_cdma_system_info_packet_zone_valid);
    if (value_cdma_system_info_packet_zone)
        *value_cdma_system_info_packet_zone = self->arg_cdma_system_info_packet_zone;
    if (value_cdma_system_info_network_id_valid)
        *value_cdma_system_info_network_id_valid = (gboolean)(self->arg_cdma_system_info_network_id_valid);
    if (value_cdma_system_info_mcc)
        *value_cdma_system_info_mcc = self->arg_cdma_system_info_mcc;
    if (value_cdma_system_info_mnc)
        *value_cdma_system_info_mnc = self->arg_cdma_system_info_mnc;

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_lte_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *value_lte_service_status_service_status,
    QmiNasServiceStatus *value_lte_service_status_true_service_status,
    gboolean *value_lte_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Service Status' was not found in the message");
        return FALSE;
    }

    if (value_lte_service_status_service_status)
        *value_lte_service_status_service_status = (QmiNasServiceStatus)(self->arg_lte_service_status_service_status);
    if (value_lte_service_status_true_service_status)
        *value_lte_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_lte_service_status_true_service_status);
    if (value_lte_service_status_preferred_data_path)
        *value_lte_service_status_preferred_data_path = (gboolean)(self->arg_lte_service_status_preferred_data_path);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_wcdma_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *value_wcdma_service_status_service_status,
    QmiNasServiceStatus *value_wcdma_service_status_true_service_status,
    gboolean *value_wcdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (value_wcdma_service_status_service_status)
        *value_wcdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_wcdma_service_status_service_status);
    if (value_wcdma_service_status_true_service_status)
        *value_wcdma_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_wcdma_service_status_true_service_status);
    if (value_wcdma_service_status_preferred_data_path)
        *value_wcdma_service_status_preferred_data_path = (gboolean)(self->arg_wcdma_service_status_preferred_data_path);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_gsm_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *value_gsm_service_status_service_status,
    QmiNasServiceStatus *value_gsm_service_status_true_service_status,
    gboolean *value_gsm_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Service Status' was not found in the message");
        return FALSE;
    }

    if (value_gsm_service_status_service_status)
        *value_gsm_service_status_service_status = (QmiNasServiceStatus)(self->arg_gsm_service_status_service_status);
    if (value_gsm_service_status_true_service_status)
        *value_gsm_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_gsm_service_status_true_service_status);
    if (value_gsm_service_status_preferred_data_path)
        *value_gsm_service_status_preferred_data_path = (gboolean)(self->arg_gsm_service_status_preferred_data_path);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_hdr_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *value_hdr_service_status_service_status,
    gboolean *value_hdr_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Service Status' was not found in the message");
        return FALSE;
    }

    if (value_hdr_service_status_service_status)
        *value_hdr_service_status_service_status = (QmiNasServiceStatus)(self->arg_hdr_service_status_service_status);
    if (value_hdr_service_status_preferred_data_path)
        *value_hdr_service_status_preferred_data_path = (gboolean)(self->arg_hdr_service_status_preferred_data_path);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_cdma_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *value_cdma_service_status_service_status,
    gboolean *value_cdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (value_cdma_service_status_service_status)
        *value_cdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_cdma_service_status_service_status);
    if (value_cdma_service_status_preferred_data_path)
        *value_cdma_service_status_preferred_data_path = (gboolean)(self->arg_cdma_service_status_preferred_data_path);

    return TRUE;
}

gboolean
qmi_message_nas_get_system_info_output_get_result (
    QmiMessageNasGetSystemInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_get_system_info_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetSystemInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_system_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_system_info_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetSystemInfoOutput *
qmi_message_nas_get_system_info_output_ref (QmiMessageNasGetSystemInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_system_info_output_unref (QmiMessageNasGetSystemInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_nr5g_tracking_area_code)
            g_array_unref (self->arg_nr5g_tracking_area_code);
        g_slice_free (QmiMessageNasGetSystemInfoOutput, self);
    }
}

static gchar *
qmi_message_nas_get_system_info_output_nr5g_tracking_area_code_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_TRACKING_AREA_CODE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint nr5g_tracking_area_code_i;
        guint16 nr5g_tracking_area_code_n_items = 3;


        g_string_append (printable, "{");

        for (nr5g_tracking_area_code_i = 0; nr5g_tracking_area_code_i < nr5g_tracking_area_code_n_items; nr5g_tracking_area_code_i++) {
            g_string_append_printf (printable, " [%u] = '", nr5g_tracking_area_code_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_dcnr_restriction_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_DCNR_RESTRICTION_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_eutra_with_nr5g_availability_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_EUTRA_WITH_NR5G_AVAILABILITY, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_nr5g_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_cause = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " tac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " tac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_nr5g_service_status_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_SERVICE_STATUS_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " true_service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_lte_cell_access_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_CELL_ACCESS_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_LTE_CELL_ACCESS_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_lte_cell_access_status_get_string ((QmiNasLteCellAccessStatus)tmp));
#elif defined  __QMI_NAS_LTE_CELL_ACCESS_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_lte_cell_access_status_build_string_from_mask ((QmiNasLteCellAccessStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasLteCellAccessStatus
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_lte_embms_coverage_info_trace_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_TRACE_ID, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_lte_registration_domain_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_REGISTRATION_DOMAIN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_LTE_REGISTRATION_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_lte_registration_domain_get_string ((QmiNasLteRegistrationDomain)tmp));
#elif defined  __QMI_NAS_LTE_REGISTRATION_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_lte_registration_domain_build_string_from_mask ((QmiNasLteRegistrationDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasLteRegistrationDomain
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_network_selection_registration_restriction_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_selection_registration_restriction_get_string ((QmiNasNetworkSelectionRegistrationRestriction)tmp));
#elif defined  __QMI_NAS_NETWORK_SELECTION_REGISTRATION_RESTRICTION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_selection_registration_restriction_build_string_from_mask ((QmiNasNetworkSelectionRegistrationRestriction)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkSelectionRegistrationRestriction
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_cdma_resolved_mcc_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_RESOLVED_MCC, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_wcdma_routing_area_code_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_ROUTING_AREA_CODE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_gsm_routing_area_code_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_ROUTING_AREA_CODE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_cdma_registration_zone_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_REGISTRATION_ZONE_ID, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_lte_voice_domain_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_DOMAIN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_LTE_VOICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_lte_voice_domain_get_string ((QmiNasLteVoiceDomain)tmp));
#elif defined  __QMI_NAS_LTE_VOICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_lte_voice_domain_build_string_from_mask ((QmiNasLteVoiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasLteVoiceDomain
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_ims_voice_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_IMS_VOICE_SUPPORT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_sim_reject_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SIM_REJECT_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_sim_reject_state_get_string ((QmiNasSimRejectState)tmp));
#elif defined  __QMI_NAS_SIM_REJECT_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_sim_reject_state_build_string_from_mask ((QmiNasSimRejectState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasSimRejectState
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_lte_embms_coverage_info_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SYSTEM_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_cause = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_REJECT_CAUSE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_reject_cause_get_string ((QmiNasRejectCause)tmp));
#elif defined  __QMI_NAS_REJECT_CAUSE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_reject_cause_build_string_from_mask ((QmiNasRejectCause)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRejectCause
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_call_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_call_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_service_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_service = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_parameter_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_parameter_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_broadcast_support_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_broadcast_support = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cs_call_barring_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cs_call_barring_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_call_barring_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_call_barring_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cipher_domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cipher_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_td_scdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " true_service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_wcdma_cipher_domain_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_gsm_cipher_domain_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_lte_voice_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_wcdma_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " cs_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_gsm_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " cs_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ps_status = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_additional_lte_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " geo_system_index = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_additional_wcdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " geo_system_index = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_broadcast_support = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_additional_gsm_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " geo_system_index = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cell_broadcast_support = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_additional_hdr_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " geo_system_index = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_additional_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " geo_system_index = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_period = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_lte_system_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_cause = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_REJECT_CAUSE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_reject_cause_get_string ((QmiNasRejectCause)tmp));
#elif defined  __QMI_NAS_REJECT_CAUSE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_reject_cause_build_string_from_mask ((QmiNasRejectCause)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRejectCause
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " tac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " tac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_wcdma_system_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_cause = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_REJECT_CAUSE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_reject_cause_get_string ((QmiNasRejectCause)tmp));
#elif defined  __QMI_NAS_REJECT_CAUSE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_reject_cause_build_string_from_mask ((QmiNasRejectCause)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRejectCause
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_call_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_call_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_service_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " hs_service = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " primary_scrambling_code_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " primary_scrambling_code = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_gsm_system_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lac = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cid = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " registration_reject_cause = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_REJECT_CAUSE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_reject_cause_get_string ((QmiNasRejectCause)tmp));
#elif defined  __QMI_NAS_REJECT_CAUSE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_reject_cause_build_string_from_mask ((QmiNasRejectCause)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRejectCause
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " egprs_support_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " egprs_support = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " dtm_support_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " dtm_support = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_hdr_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " prl_match_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " prl_match = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " personality_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " personality = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_HDR_PERSONALITY_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_hdr_personality_get_string ((QmiNasHdrPersonality)tmp));
#elif defined  __QMI_NAS_HDR_PERSONALITY_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_hdr_personality_build_string_from_mask ((QmiNasHdrPersonality)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasHdrPersonality
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " protocol_revision_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " protocol_revision = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_HDR_PROTOCOL_REVISION_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_hdr_protocol_revision_get_string ((QmiNasHdrProtocolRevision)tmp));
#elif defined  __QMI_NAS_HDR_PROTOCOL_REVISION_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_hdr_protocol_revision_build_string_from_mask ((QmiNasHdrProtocolRevision)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasHdrProtocolRevision
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " is_856_system_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " is_856_system_id = '");

    {
        gchar tmp[17];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 16, &tmp[0], &error))
            goto out;
        tmp[16] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " domain_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " domain = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " service_capability = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " roaming_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " forbidden = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " prl_match_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " prl_match = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " p_rev_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " p_rev = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_p_rev_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_p_rev = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " concurrent_service_support_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " concurrent_service_support = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " cdma_system_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " sid = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " nid = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_info_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_latitude = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " base_station_longitude = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " packet_zone_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " packet_zone = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " network_id_valid = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mcc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " mnc = '");

    {
        gchar tmp[4];

        if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &tmp[0], &error))
            goto out;
        tmp[3] = '\0';
        g_string_append (printable, tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_lte_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " true_service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_wcdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " true_service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_gsm_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " true_service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_hdr_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_system_info_output_cdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " service_status = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " preferred_data_path = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_system_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_system_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_system_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_TRACKING_AREA_CODE:
            tlv_type_str = "NR5G Tracking Area Code";
            translated_value = qmi_message_nas_get_system_info_output_nr5g_tracking_area_code_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_DCNR_RESTRICTION_INFO:
            tlv_type_str = "DCNR restriction Info";
            translated_value = qmi_message_nas_get_system_info_output_dcnr_restriction_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_EUTRA_WITH_NR5G_AVAILABILITY:
            tlv_type_str = "EUTRA with NR5G availability";
            translated_value = qmi_message_nas_get_system_info_output_eutra_with_nr5g_availability_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_SYSTEM_INFO:
            tlv_type_str = "NR5G System Info";
            translated_value = qmi_message_nas_get_system_info_output_nr5g_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_SERVICE_STATUS_INFO:
            tlv_type_str = "NR5G Service Status Info";
            translated_value = qmi_message_nas_get_system_info_output_nr5g_service_status_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_CELL_ACCESS_STATUS:
            tlv_type_str = "LTE Cell Access Status";
            translated_value = qmi_message_nas_get_system_info_output_lte_cell_access_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_TRACE_ID:
            tlv_type_str = "LTE eMBMS Coverage Info Trace ID";
            translated_value = qmi_message_nas_get_system_info_output_lte_embms_coverage_info_trace_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_REGISTRATION_DOMAIN:
            tlv_type_str = "LTE Registration Domain";
            translated_value = qmi_message_nas_get_system_info_output_lte_registration_domain_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION:
            tlv_type_str = "Network Selection Registration Restriction";
            translated_value = qmi_message_nas_get_system_info_output_network_selection_registration_restriction_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_RESOLVED_MCC:
            tlv_type_str = "CDMA Resolved MCC";
            translated_value = qmi_message_nas_get_system_info_output_cdma_resolved_mcc_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_ROUTING_AREA_CODE:
            tlv_type_str = "WCDMA Routing Area Code";
            translated_value = qmi_message_nas_get_system_info_output_wcdma_routing_area_code_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_ROUTING_AREA_CODE:
            tlv_type_str = "GSM Routing Area Code";
            translated_value = qmi_message_nas_get_system_info_output_gsm_routing_area_code_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_REGISTRATION_ZONE_ID:
            tlv_type_str = "CDMA Registration Zone ID";
            translated_value = qmi_message_nas_get_system_info_output_cdma_registration_zone_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_DOMAIN:
            tlv_type_str = "LTE Voice Domain";
            translated_value = qmi_message_nas_get_system_info_output_lte_voice_domain_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_IMS_VOICE_SUPPORT:
            tlv_type_str = "IMS Voice Support";
            translated_value = qmi_message_nas_get_system_info_output_ims_voice_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO:
            tlv_type_str = "SIM Reject Info";
            translated_value = qmi_message_nas_get_system_info_output_sim_reject_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT:
            tlv_type_str = "LTE eMBMS Coverage Info Support";
            translated_value = qmi_message_nas_get_system_info_output_lte_embms_coverage_info_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SYSTEM_INFO_V2:
            tlv_type_str = "TD SCDMA System Info v2";
            translated_value = qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS:
            tlv_type_str = "TD SCDMA Service Status";
            translated_value = qmi_message_nas_get_system_info_output_td_scdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN:
            tlv_type_str = "WCDMA Cipher Domain";
            translated_value = qmi_message_nas_get_system_info_output_wcdma_cipher_domain_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN:
            tlv_type_str = "GSM Cipher Domain";
            translated_value = qmi_message_nas_get_system_info_output_gsm_cipher_domain_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT:
            tlv_type_str = "LTE Voice Support";
            translated_value = qmi_message_nas_get_system_info_output_lte_voice_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS:
            tlv_type_str = "WCDMA Call Barring Status";
            translated_value = qmi_message_nas_get_system_info_output_wcdma_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS:
            tlv_type_str = "GSM Call Barring Status";
            translated_value = qmi_message_nas_get_system_info_output_gsm_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO:
            tlv_type_str = "Additional LTE System Info";
            translated_value = qmi_message_nas_get_system_info_output_additional_lte_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO:
            tlv_type_str = "Additional WCDMA System Info";
            translated_value = qmi_message_nas_get_system_info_output_additional_wcdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO:
            tlv_type_str = "Additional GSM System Info";
            translated_value = qmi_message_nas_get_system_info_output_additional_gsm_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO:
            tlv_type_str = "Additional HDR System Info";
            translated_value = qmi_message_nas_get_system_info_output_additional_hdr_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO:
            tlv_type_str = "Additional CDMA System Info";
            translated_value = qmi_message_nas_get_system_info_output_additional_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO_V2:
            tlv_type_str = "LTE System Info v2";
            translated_value = qmi_message_nas_get_system_info_output_lte_system_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO_V2:
            tlv_type_str = "WCDMA System Info v2";
            translated_value = qmi_message_nas_get_system_info_output_wcdma_system_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO_V2:
            tlv_type_str = "GSM System Info v2";
            translated_value = qmi_message_nas_get_system_info_output_gsm_system_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO:
            tlv_type_str = "HDR System Info";
            translated_value = qmi_message_nas_get_system_info_output_hdr_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO:
            tlv_type_str = "CDMA System Info";
            translated_value = qmi_message_nas_get_system_info_output_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS:
            tlv_type_str = "LTE Service Status";
            translated_value = qmi_message_nas_get_system_info_output_lte_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS:
            tlv_type_str = "WCDMA Service Status";
            translated_value = qmi_message_nas_get_system_info_output_wcdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS:
            tlv_type_str = "GSM Service Status";
            translated_value = qmi_message_nas_get_system_info_output_gsm_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS:
            tlv_type_str = "HDR Service Status";
            translated_value = qmi_message_nas_get_system_info_output_hdr_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS:
            tlv_type_str = "CDMA Service Status";
            translated_value = qmi_message_nas_get_system_info_output_cdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_system_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get System Info\" (0x004D)\n",
                            line_prefix);

    {
        struct message_get_system_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_system_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetSystemInfoOutput *
__qmi_message_nas_get_system_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetSystemInfoOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_SYSTEM_INFO);

    self = g_slice_new0 (QmiMessageNasGetSystemInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_TRACKING_AREA_CODE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_nr5g_tracking_area_code_out;
            }
            {
                guint nr5g_tracking_area_code_i;
                guint16 nr5g_tracking_area_code_n_items = 3;


                self->arg_nr5g_tracking_area_code = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (guint8),
                    (guint)nr5g_tracking_area_code_n_items);

                for (nr5g_tracking_area_code_i = 0; nr5g_tracking_area_code_i < nr5g_tracking_area_code_n_items; nr5g_tracking_area_code_i++) {
                    guint8 nr5g_tracking_area_code_aux;

                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(nr5g_tracking_area_code_aux), NULL))
                        goto qmi_message_nas_get_system_info_output_nr5g_tracking_area_code_out;
                    g_array_insert_val (self->arg_nr5g_tracking_area_code, nr5g_tracking_area_code_i, nr5g_tracking_area_code_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'NR5G Tracking Area Code' TLV", offset);
            }

            self->arg_nr5g_tracking_area_code_set = TRUE;

qmi_message_nas_get_system_info_output_nr5g_tracking_area_code_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_DCNR_RESTRICTION_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_dcnr_restriction_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_dcnr_restriction_info_out;
                self->arg_dcnr_restriction_info = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'DCNR restriction Info' TLV", offset);
            }

            self->arg_dcnr_restriction_info_set = TRUE;

qmi_message_nas_get_system_info_output_dcnr_restriction_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_EUTRA_WITH_NR5G_AVAILABILITY, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_eutra_with_nr5g_availability_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_eutra_with_nr5g_availability_out;
                self->arg_eutra_with_nr5g_availability = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'EUTRA with NR5G availability' TLV", offset);
            }

            self->arg_eutra_with_nr5g_availability_set = TRUE;

qmi_message_nas_get_system_info_output_eutra_with_nr5g_availability_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_lac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_system_info_lac), NULL))
                goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_cid_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_system_info_cid), NULL))
                goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_registration_reject_info_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_nr5g_system_info_registration_reject_cause), NULL))
                goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_nr5g_system_info_mcc[0], NULL))
                goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
            self->arg_nr5g_system_info_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_nr5g_system_info_mnc[0], NULL))
                goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
            self->arg_nr5g_system_info_mnc[3] = '\0';
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;
                self->arg_nr5g_system_info_tac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_nr5g_system_info_tac), NULL))
                goto qmi_message_nas_get_system_info_output_nr5g_system_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'NR5G System Info' TLV", offset);
            }

            self->arg_nr5g_system_info_set = TRUE;

qmi_message_nas_get_system_info_output_nr5g_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NR5G_SERVICE_STATUS_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_nr5g_service_status_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_service_status_info_out;
                self->arg_nr5g_service_status_info_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_service_status_info_out;
                self->arg_nr5g_service_status_info_true_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_nr5g_service_status_info_out;
                self->arg_nr5g_service_status_info_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'NR5G Service Status Info' TLV", offset);
            }

            self->arg_nr5g_service_status_info_set = TRUE;

qmi_message_nas_get_system_info_output_nr5g_service_status_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_CELL_ACCESS_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_lte_cell_access_status_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_cell_access_status_out;
                self->arg_lte_cell_access_status = (QmiNasLteCellAccessStatus)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Cell Access Status' TLV", offset);
            }

            self->arg_lte_cell_access_status_set = TRUE;

qmi_message_nas_get_system_info_output_lte_cell_access_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_TRACE_ID, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_lte_embms_coverage_info_trace_id_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_embms_coverage_info_trace_id), NULL))
                goto qmi_message_nas_get_system_info_output_lte_embms_coverage_info_trace_id_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE eMBMS Coverage Info Trace ID' TLV", offset);
            }

            self->arg_lte_embms_coverage_info_trace_id_set = TRUE;

qmi_message_nas_get_system_info_output_lte_embms_coverage_info_trace_id_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_REGISTRATION_DOMAIN, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_lte_registration_domain_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_registration_domain_out;
                self->arg_lte_registration_domain = (QmiNasLteRegistrationDomain)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Registration Domain' TLV", offset);
            }

            self->arg_lte_registration_domain_set = TRUE;

qmi_message_nas_get_system_info_output_lte_registration_domain_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_NETWORK_SELECTION_REGISTRATION_RESTRICTION, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_network_selection_registration_restriction_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_network_selection_registration_restriction_out;
                self->arg_network_selection_registration_restriction = (QmiNasNetworkSelectionRegistrationRestriction)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Network Selection Registration Restriction' TLV", offset);
            }

            self->arg_network_selection_registration_restriction_set = TRUE;

qmi_message_nas_get_system_info_output_network_selection_registration_restriction_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_RESOLVED_MCC, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_cdma_resolved_mcc_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_resolved_mcc), NULL))
                goto qmi_message_nas_get_system_info_output_cdma_resolved_mcc_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA Resolved MCC' TLV", offset);
            }

            self->arg_cdma_resolved_mcc_set = TRUE;

qmi_message_nas_get_system_info_output_cdma_resolved_mcc_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_ROUTING_AREA_CODE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_wcdma_routing_area_code_out;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_wcdma_routing_area_code), NULL))
                goto qmi_message_nas_get_system_info_output_wcdma_routing_area_code_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'WCDMA Routing Area Code' TLV", offset);
            }

            self->arg_wcdma_routing_area_code_set = TRUE;

qmi_message_nas_get_system_info_output_wcdma_routing_area_code_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_ROUTING_AREA_CODE, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_gsm_routing_area_code_out;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_gsm_routing_area_code), NULL))
                goto qmi_message_nas_get_system_info_output_gsm_routing_area_code_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM Routing Area Code' TLV", offset);
            }

            self->arg_gsm_routing_area_code_set = TRUE;

qmi_message_nas_get_system_info_output_gsm_routing_area_code_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_REGISTRATION_ZONE_ID, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_cdma_registration_zone_id_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_registration_zone_id), NULL))
                goto qmi_message_nas_get_system_info_output_cdma_registration_zone_id_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA Registration Zone ID' TLV", offset);
            }

            self->arg_cdma_registration_zone_id_set = TRUE;

qmi_message_nas_get_system_info_output_cdma_registration_zone_id_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_DOMAIN, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_lte_voice_domain_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_voice_domain_out;
                self->arg_lte_voice_domain = (QmiNasLteVoiceDomain)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Voice Domain' TLV", offset);
            }

            self->arg_lte_voice_domain_set = TRUE;

qmi_message_nas_get_system_info_output_lte_voice_domain_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_IMS_VOICE_SUPPORT, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_ims_voice_support_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_ims_voice_support_out;
                self->arg_ims_voice_support = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'IMS Voice Support' TLV", offset);
            }

            self->arg_ims_voice_support_set = TRUE;

qmi_message_nas_get_system_info_output_ims_voice_support_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_sim_reject_info_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_sim_reject_info_out;
                self->arg_sim_reject_info = (QmiNasSimRejectState)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'SIM Reject Info' TLV", offset);
            }

            self->arg_sim_reject_info_set = TRUE;

qmi_message_nas_get_system_info_output_sim_reject_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_lte_embms_coverage_info_support_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_embms_coverage_info_support_out;
                self->arg_lte_embms_coverage_info_support = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE eMBMS Coverage Info Support' TLV", offset);
            }

            self->arg_lte_embms_coverage_info_support_set = TRUE;

qmi_message_nas_get_system_info_output_lte_embms_coverage_info_support_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SYSTEM_INFO_V2, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_lac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_td_scdma_system_info_v2_lac), NULL))
                goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_cid_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_td_scdma_system_info_v2_cid), NULL))
                goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_registration_reject_info_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_registration_reject_cause = (QmiNasRejectCause)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_td_scdma_system_info_v2_mcc[0], NULL))
                goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
            self->arg_td_scdma_system_info_v2_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_td_scdma_system_info_v2_mnc[0], NULL))
                goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
            self->arg_td_scdma_system_info_v2_mnc[3] = '\0';
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_hs_call_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_hs_call_status = (QmiNasWcdmaHsService)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_hs_service_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_hs_service = (QmiNasWcdmaHsService)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_cell_parameter_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_td_scdma_system_info_v2_cell_parameter_id), NULL))
                goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_cell_broadcast_support_valid = (gboolean)tmp;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_cs_call_barring_status_valid = (gboolean)tmp;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_cs_call_barring_status = (QmiNasCallBarringStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_ps_call_barring_status_valid = (gboolean)tmp;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_ps_call_barring_status = (QmiNasCallBarringStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_cipher_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out;
                self->arg_td_scdma_system_info_v2_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'TD SCDMA System Info v2' TLV", offset);
            }

            self->arg_td_scdma_system_info_v2_set = TRUE;

qmi_message_nas_get_system_info_output_td_scdma_system_info_v2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_td_scdma_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_service_status_out;
                self->arg_td_scdma_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_service_status_out;
                self->arg_td_scdma_service_status_true_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_td_scdma_service_status_out;
                self->arg_td_scdma_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'TD SCDMA Service Status' TLV", offset);
            }

            self->arg_td_scdma_service_status_set = TRUE;

qmi_message_nas_get_system_info_output_td_scdma_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_wcdma_cipher_domain_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_cipher_domain_out;
                self->arg_wcdma_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'WCDMA Cipher Domain' TLV", offset);
            }

            self->arg_wcdma_cipher_domain_set = TRUE;

qmi_message_nas_get_system_info_output_wcdma_cipher_domain_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_gsm_cipher_domain_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_cipher_domain_out;
                self->arg_gsm_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM Cipher Domain' TLV", offset);
            }

            self->arg_gsm_cipher_domain_set = TRUE;

qmi_message_nas_get_system_info_output_gsm_cipher_domain_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_lte_voice_support_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_voice_support_out;
                self->arg_lte_voice_support = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Voice Support' TLV", offset);
            }

            self->arg_lte_voice_support_set = TRUE;

qmi_message_nas_get_system_info_output_lte_voice_support_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_wcdma_call_barring_status_out;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_call_barring_status_out;
                self->arg_wcdma_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_call_barring_status_out;
                self->arg_wcdma_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'WCDMA Call Barring Status' TLV", offset);
            }

            self->arg_wcdma_call_barring_status_set = TRUE;

qmi_message_nas_get_system_info_output_wcdma_call_barring_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_gsm_call_barring_status_out;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_call_barring_status_out;
                self->arg_gsm_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
            }
            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_call_barring_status_out;
                self->arg_gsm_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM Call Barring Status' TLV", offset);
            }

            self->arg_gsm_call_barring_status_set = TRUE;

qmi_message_nas_get_system_info_output_gsm_call_barring_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_additional_lte_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_lte_system_info_geo_system_index), NULL))
                goto qmi_message_nas_get_system_info_output_additional_lte_system_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Additional LTE System Info' TLV", offset);
            }

            self->arg_additional_lte_system_info_set = TRUE;

qmi_message_nas_get_system_info_output_additional_lte_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_additional_wcdma_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_wcdma_system_info_geo_system_index), NULL))
                goto qmi_message_nas_get_system_info_output_additional_wcdma_system_info_out;
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_additional_wcdma_system_info_out;
                self->arg_additional_wcdma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Additional WCDMA System Info' TLV", offset);
            }

            self->arg_additional_wcdma_system_info_set = TRUE;

qmi_message_nas_get_system_info_output_additional_wcdma_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_additional_gsm_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_gsm_system_info_geo_system_index), NULL))
                goto qmi_message_nas_get_system_info_output_additional_gsm_system_info_out;
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_additional_gsm_system_info_out;
                self->arg_additional_gsm_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Additional GSM System Info' TLV", offset);
            }

            self->arg_additional_gsm_system_info_set = TRUE;

qmi_message_nas_get_system_info_output_additional_gsm_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_additional_hdr_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_hdr_system_info_geo_system_index), NULL))
                goto qmi_message_nas_get_system_info_output_additional_hdr_system_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Additional HDR System Info' TLV", offset);
            }

            self->arg_additional_hdr_system_info_set = TRUE;

qmi_message_nas_get_system_info_output_additional_hdr_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_additional_cdma_system_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_cdma_system_info_geo_system_index), NULL))
                goto qmi_message_nas_get_system_info_output_additional_cdma_system_info_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_additional_cdma_system_info_registration_period), NULL))
                goto qmi_message_nas_get_system_info_output_additional_cdma_system_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Additional CDMA System Info' TLV", offset);
            }

            self->arg_additional_cdma_system_info_set = TRUE;

qmi_message_nas_get_system_info_output_additional_cdma_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO_V2, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_lac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_system_info_v2_lac), NULL))
                goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_cid_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_system_info_v2_cid), NULL))
                goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_registration_reject_info_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_registration_reject_cause = (QmiNasRejectCause)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_lte_system_info_v2_mcc[0], NULL))
                goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
            self->arg_lte_system_info_v2_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_lte_system_info_v2_mnc[0], NULL))
                goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
            self->arg_lte_system_info_v2_mnc[3] = '\0';
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;
                self->arg_lte_system_info_v2_tac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_system_info_v2_tac), NULL))
                goto qmi_message_nas_get_system_info_output_lte_system_info_v2_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE System Info v2' TLV", offset);
            }

            self->arg_lte_system_info_v2_set = TRUE;

qmi_message_nas_get_system_info_output_lte_system_info_v2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO_V2, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_lac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_wcdma_system_info_v2_lac), NULL))
                goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_cid_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_wcdma_system_info_v2_cid), NULL))
                goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_registration_reject_info_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_registration_reject_cause = (QmiNasRejectCause)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_wcdma_system_info_v2_mcc[0], NULL))
                goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
            self->arg_wcdma_system_info_v2_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_wcdma_system_info_v2_mnc[0], NULL))
                goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
            self->arg_wcdma_system_info_v2_mnc[3] = '\0';
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_hs_call_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_hs_call_status = (QmiNasWcdmaHsService)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_hs_service_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_hs_service = (QmiNasWcdmaHsService)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;
                self->arg_wcdma_system_info_v2_primary_scrambling_code_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_wcdma_system_info_v2_primary_scrambling_code), NULL))
                goto qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'WCDMA System Info v2' TLV", offset);
            }

            self->arg_wcdma_system_info_v2_set = TRUE;

qmi_message_nas_get_system_info_output_wcdma_system_info_v2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO_V2, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_lac_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_gsm_system_info_v2_lac), NULL))
                goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_cid_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_gsm_system_info_v2_cid), NULL))
                goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_registration_reject_info_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_registration_reject_cause = (QmiNasRejectCause)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_gsm_system_info_v2_mcc[0], NULL))
                goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
            self->arg_gsm_system_info_v2_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_gsm_system_info_v2_mnc[0], NULL))
                goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
            self->arg_gsm_system_info_v2_mnc[3] = '\0';
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_egprs_support_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_egprs_support = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_dtm_support_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_system_info_v2_out;
                self->arg_gsm_system_info_v2_dtm_support = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM System Info v2' TLV", offset);
            }

            self->arg_gsm_system_info_v2_set = TRUE;

qmi_message_nas_get_system_info_output_gsm_system_info_v2_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_prl_match_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_prl_match = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_personality_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_personality = (QmiNasHdrPersonality)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_protocol_revision_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_protocol_revision = (QmiNasHdrProtocolRevision)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
                self->arg_hdr_system_info_is_856_system_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 16, &self->arg_hdr_system_info_is_856_system_id[0], NULL))
                goto qmi_message_nas_get_system_info_output_hdr_system_info_out;
            self->arg_hdr_system_info_is_856_system_id[16] = '\0';

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'HDR System Info' TLV", offset);
            }

            self->arg_hdr_system_info_set = TRUE;

qmi_message_nas_get_system_info_output_hdr_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_domain_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_service_capability_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_roaming_status_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_forbidden_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_forbidden = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_prl_match_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_prl_match = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_p_rev_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_cdma_system_info_p_rev), NULL))
                goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_base_station_p_rev_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_cdma_system_info_base_station_p_rev), NULL))
                goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_concurrent_service_support_valid = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_concurrent_service_support = (gboolean)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_cdma_system_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_sid), NULL))
                goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_nid), NULL))
                goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_base_station_info_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_base_station_id), NULL))
                goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_base_station_latitude), NULL))
                goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_base_station_longitude), NULL))
                goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_packet_zone_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_system_info_packet_zone), NULL))
                goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
                self->arg_cdma_system_info_network_id_valid = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_cdma_system_info_mcc[0], NULL))
                goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
            self->arg_cdma_system_info_mcc[3] = '\0';
            if (!qmi_message_tlv_read_fixed_size_string (message, init_offset, &offset, 3, &self->arg_cdma_system_info_mnc[0], NULL))
                goto qmi_message_nas_get_system_info_output_cdma_system_info_out;
            self->arg_cdma_system_info_mnc[3] = '\0';

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA System Info' TLV", offset);
            }

            self->arg_cdma_system_info_set = TRUE;

qmi_message_nas_get_system_info_output_cdma_system_info_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_lte_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_service_status_out;
                self->arg_lte_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_service_status_out;
                self->arg_lte_service_status_true_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_lte_service_status_out;
                self->arg_lte_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Service Status' TLV", offset);
            }

            self->arg_lte_service_status_set = TRUE;

qmi_message_nas_get_system_info_output_lte_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_wcdma_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_service_status_out;
                self->arg_wcdma_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_service_status_out;
                self->arg_wcdma_service_status_true_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_wcdma_service_status_out;
                self->arg_wcdma_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'WCDMA Service Status' TLV", offset);
            }

            self->arg_wcdma_service_status_set = TRUE;

qmi_message_nas_get_system_info_output_wcdma_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_gsm_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_service_status_out;
                self->arg_gsm_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_service_status_out;
                self->arg_gsm_service_status_true_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_gsm_service_status_out;
                self->arg_gsm_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM Service Status' TLV", offset);
            }

            self->arg_gsm_service_status_set = TRUE;

qmi_message_nas_get_system_info_output_gsm_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_hdr_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_service_status_out;
                self->arg_hdr_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_hdr_service_status_out;
                self->arg_hdr_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'HDR Service Status' TLV", offset);
            }

            self->arg_hdr_service_status_set = TRUE;

qmi_message_nas_get_system_info_output_hdr_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_system_info_output_cdma_service_status_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_service_status_out;
                self->arg_cdma_service_status_service_status = (QmiNasServiceStatus)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_system_info_output_cdma_service_status_out;
                self->arg_cdma_service_status_preferred_data_path = (gboolean)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA Service Status' TLV", offset);
            }

            self->arg_cdma_service_status_set = TRUE;

qmi_message_nas_get_system_info_output_cdma_service_status_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_system_info_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_system_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Signal Info */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_signal_info_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_SIGNAL_INFO);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetSignalInfoOutput {
    volatile gint ref_count;

    /* 5G Signal Strength Extended */
    gboolean arg_5g_signal_strength_extended_set;
    gint16 arg_5g_signal_strength_extended;

    /* 5G Signal Strength */
    gboolean arg_5g_signal_strength_set;
    gint16 arg_5g_signal_strength_rsrp;
    gint16 arg_5g_signal_strength_snr;

    /* TDMA Signal Strength Extended */
    gboolean arg_tdma_signal_strength_extended_set;
    gint32 arg_tdma_signal_strength_extended_rssi;
    gint32 arg_tdma_signal_strength_extended_rscp;
    gint32 arg_tdma_signal_strength_extended_ecio;
    gint32 arg_tdma_signal_strength_extended_sinr;

    /* TDMA Signal Strength */
    gboolean arg_tdma_signal_strength_set;
    gint8 arg_tdma_signal_strength;

    /* LTE Signal Strength */
    gboolean arg_lte_signal_strength_set;
    gint8 arg_lte_signal_strength_rssi;
    gint8 arg_lte_signal_strength_rsrq;
    gint16 arg_lte_signal_strength_rsrp;
    gint16 arg_lte_signal_strength_snr;

    /* WCDMA Signal Strength */
    gboolean arg_wcdma_signal_strength_set;
    gint8 arg_wcdma_signal_strength_rssi;
    gint16 arg_wcdma_signal_strength_ecio;

    /* GSM Signal Strength */
    gboolean arg_gsm_signal_strength_set;
    gint8 arg_gsm_signal_strength;

    /* HDR Signal Strength */
    gboolean arg_hdr_signal_strength_set;
    gint8 arg_hdr_signal_strength_rssi;
    gint16 arg_hdr_signal_strength_ecio;
    guint8 arg_hdr_signal_strength_sinr;
    gint32 arg_hdr_signal_strength_io;

    /* CDMA Signal Strength */
    gboolean arg_cdma_signal_strength_set;
    gint8 arg_cdma_signal_strength_rssi;
    gint16 arg_cdma_signal_strength_ecio;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_5G_SIGNAL_STRENGTH_EXTENDED 0x18
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_5G_SIGNAL_STRENGTH 0x17
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH_EXTENDED 0x16
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH 0x15
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH 0x14
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH 0x13
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH 0x12
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH 0x11
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH 0x10
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_get_signal_info_output_get_5g_signal_strength_extended (
    QmiMessageNasGetSignalInfoOutput *self,
    gint16 *value_5g_signal_strength_extended,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_5g_signal_strength_extended_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field '5G Signal Strength Extended' was not found in the message");
        return FALSE;
    }

    if (value_5g_signal_strength_extended)
        *value_5g_signal_strength_extended = self->arg_5g_signal_strength_extended;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_info_output_get_5g_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint16 *value_5g_signal_strength_rsrp,
    gint16 *value_5g_signal_strength_snr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_5g_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field '5G Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_5g_signal_strength_rsrp)
        *value_5g_signal_strength_rsrp = self->arg_5g_signal_strength_rsrp;
    if (value_5g_signal_strength_snr)
        *value_5g_signal_strength_snr = self->arg_5g_signal_strength_snr;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_info_output_get_tdma_signal_strength_extended (
    QmiMessageNasGetSignalInfoOutput *self,
    gint32 *value_tdma_signal_strength_extended_rssi,
    gint32 *value_tdma_signal_strength_extended_rscp,
    gint32 *value_tdma_signal_strength_extended_ecio,
    gint32 *value_tdma_signal_strength_extended_sinr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_tdma_signal_strength_extended_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TDMA Signal Strength Extended' was not found in the message");
        return FALSE;
    }

    if (value_tdma_signal_strength_extended_rssi)
        *value_tdma_signal_strength_extended_rssi = self->arg_tdma_signal_strength_extended_rssi;
    if (value_tdma_signal_strength_extended_rscp)
        *value_tdma_signal_strength_extended_rscp = self->arg_tdma_signal_strength_extended_rscp;
    if (value_tdma_signal_strength_extended_ecio)
        *value_tdma_signal_strength_extended_ecio = self->arg_tdma_signal_strength_extended_ecio;
    if (value_tdma_signal_strength_extended_sinr)
        *value_tdma_signal_strength_extended_sinr = self->arg_tdma_signal_strength_extended_sinr;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_info_output_get_tdma_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *value_tdma_signal_strength,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_tdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_tdma_signal_strength)
        *value_tdma_signal_strength = self->arg_tdma_signal_strength;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_info_output_get_lte_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *value_lte_signal_strength_rssi,
    gint8 *value_lte_signal_strength_rsrq,
    gint16 *value_lte_signal_strength_rsrp,
    gint16 *value_lte_signal_strength_snr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_lte_signal_strength_rssi)
        *value_lte_signal_strength_rssi = self->arg_lte_signal_strength_rssi;
    if (value_lte_signal_strength_rsrq)
        *value_lte_signal_strength_rsrq = self->arg_lte_signal_strength_rsrq;
    if (value_lte_signal_strength_rsrp)
        *value_lte_signal_strength_rsrp = self->arg_lte_signal_strength_rsrp;
    if (value_lte_signal_strength_snr)
        *value_lte_signal_strength_snr = self->arg_lte_signal_strength_snr;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_info_output_get_wcdma_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *value_wcdma_signal_strength_rssi,
    gint16 *value_wcdma_signal_strength_ecio,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_wcdma_signal_strength_rssi)
        *value_wcdma_signal_strength_rssi = self->arg_wcdma_signal_strength_rssi;
    if (value_wcdma_signal_strength_ecio)
        *value_wcdma_signal_strength_ecio = self->arg_wcdma_signal_strength_ecio;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_info_output_get_gsm_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *value_gsm_signal_strength,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_gsm_signal_strength)
        *value_gsm_signal_strength = self->arg_gsm_signal_strength;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_info_output_get_hdr_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *value_hdr_signal_strength_rssi,
    gint16 *value_hdr_signal_strength_ecio,
    QmiNasEvdoSinrLevel *value_hdr_signal_strength_sinr,
    gint32 *value_hdr_signal_strength_io,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_hdr_signal_strength_rssi)
        *value_hdr_signal_strength_rssi = self->arg_hdr_signal_strength_rssi;
    if (value_hdr_signal_strength_ecio)
        *value_hdr_signal_strength_ecio = self->arg_hdr_signal_strength_ecio;
    if (value_hdr_signal_strength_sinr)
        *value_hdr_signal_strength_sinr = (QmiNasEvdoSinrLevel)(self->arg_hdr_signal_strength_sinr);
    if (value_hdr_signal_strength_io)
        *value_hdr_signal_strength_io = self->arg_hdr_signal_strength_io;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_info_output_get_cdma_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *value_cdma_signal_strength_rssi,
    gint16 *value_cdma_signal_strength_ecio,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (value_cdma_signal_strength_rssi)
        *value_cdma_signal_strength_rssi = self->arg_cdma_signal_strength_rssi;
    if (value_cdma_signal_strength_ecio)
        *value_cdma_signal_strength_ecio = self->arg_cdma_signal_strength_ecio;

    return TRUE;
}

gboolean
qmi_message_nas_get_signal_info_output_get_result (
    QmiMessageNasGetSignalInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_get_signal_info_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetSignalInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_signal_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_signal_info_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetSignalInfoOutput *
qmi_message_nas_get_signal_info_output_ref (QmiMessageNasGetSignalInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_signal_info_output_unref (QmiMessageNasGetSignalInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetSignalInfoOutput, self);
    }
}

static gchar *
qmi_message_nas_get_signal_info_output_5g_signal_strength_extended_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_5G_SIGNAL_STRENGTH_EXTENDED, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_info_output_5g_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_5G_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rsrp = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " snr = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_info_output_tdma_signal_strength_extended_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH_EXTENDED, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rssi = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rscp = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " sinr = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_info_output_tdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_info_output_lte_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rssi = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rsrq = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rsrp = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " snr = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_info_output_wcdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rssi = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_info_output_gsm_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_info_output_hdr_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rssi = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " sinr = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_evdo_sinr_level_get_string ((QmiNasEvdoSinrLevel)tmp));
#elif defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_evdo_sinr_level_build_string_from_mask ((QmiNasEvdoSinrLevel)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasEvdoSinrLevel
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " io = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_signal_info_output_cdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rssi = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint16 tmp;

        if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_signal_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_signal_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_signal_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_5G_SIGNAL_STRENGTH_EXTENDED:
            tlv_type_str = "5G Signal Strength Extended";
            translated_value = qmi_message_nas_get_signal_info_output_5g_signal_strength_extended_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_5G_SIGNAL_STRENGTH:
            tlv_type_str = "5G Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_5g_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH_EXTENDED:
            tlv_type_str = "TDMA Signal Strength Extended";
            translated_value = qmi_message_nas_get_signal_info_output_tdma_signal_strength_extended_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH:
            tlv_type_str = "TDMA Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_tdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH:
            tlv_type_str = "LTE Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_lte_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH:
            tlv_type_str = "WCDMA Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_wcdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH:
            tlv_type_str = "GSM Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_gsm_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH:
            tlv_type_str = "HDR Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_hdr_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH:
            tlv_type_str = "CDMA Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_cdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_signal_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Signal Info\" (0x004F)\n",
                            line_prefix);

    {
        struct message_get_signal_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_signal_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetSignalInfoOutput *
__qmi_message_nas_get_signal_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetSignalInfoOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_SIGNAL_INFO);

    self = g_slice_new0 (QmiMessageNasGetSignalInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_5G_SIGNAL_STRENGTH_EXTENDED, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_info_output_5g_signal_strength_extended_out;
            }
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_5g_signal_strength_extended), NULL))
                goto qmi_message_nas_get_signal_info_output_5g_signal_strength_extended_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the '5G Signal Strength Extended' TLV", offset);
            }

            self->arg_5g_signal_strength_extended_set = TRUE;

qmi_message_nas_get_signal_info_output_5g_signal_strength_extended_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_5G_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_info_output_5g_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_5g_signal_strength_rsrp), NULL))
                goto qmi_message_nas_get_signal_info_output_5g_signal_strength_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_5g_signal_strength_snr), NULL))
                goto qmi_message_nas_get_signal_info_output_5g_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the '5G Signal Strength' TLV", offset);
            }

            self->arg_5g_signal_strength_set = TRUE;

qmi_message_nas_get_signal_info_output_5g_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH_EXTENDED, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_info_output_tdma_signal_strength_extended_out;
            }
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_tdma_signal_strength_extended_rssi), NULL))
                goto qmi_message_nas_get_signal_info_output_tdma_signal_strength_extended_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_tdma_signal_strength_extended_rscp), NULL))
                goto qmi_message_nas_get_signal_info_output_tdma_signal_strength_extended_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_tdma_signal_strength_extended_ecio), NULL))
                goto qmi_message_nas_get_signal_info_output_tdma_signal_strength_extended_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_tdma_signal_strength_extended_sinr), NULL))
                goto qmi_message_nas_get_signal_info_output_tdma_signal_strength_extended_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'TDMA Signal Strength Extended' TLV", offset);
            }

            self->arg_tdma_signal_strength_extended_set = TRUE;

qmi_message_nas_get_signal_info_output_tdma_signal_strength_extended_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_info_output_tdma_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_tdma_signal_strength), NULL))
                goto qmi_message_nas_get_signal_info_output_tdma_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'TDMA Signal Strength' TLV", offset);
            }

            self->arg_tdma_signal_strength_set = TRUE;

qmi_message_nas_get_signal_info_output_tdma_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_info_output_lte_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_lte_signal_strength_rssi), NULL))
                goto qmi_message_nas_get_signal_info_output_lte_signal_strength_out;
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_lte_signal_strength_rsrq), NULL))
                goto qmi_message_nas_get_signal_info_output_lte_signal_strength_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_signal_strength_rsrp), NULL))
                goto qmi_message_nas_get_signal_info_output_lte_signal_strength_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_signal_strength_snr), NULL))
                goto qmi_message_nas_get_signal_info_output_lte_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Signal Strength' TLV", offset);
            }

            self->arg_lte_signal_strength_set = TRUE;

qmi_message_nas_get_signal_info_output_lte_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_info_output_wcdma_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_wcdma_signal_strength_rssi), NULL))
                goto qmi_message_nas_get_signal_info_output_wcdma_signal_strength_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_wcdma_signal_strength_ecio), NULL))
                goto qmi_message_nas_get_signal_info_output_wcdma_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'WCDMA Signal Strength' TLV", offset);
            }

            self->arg_wcdma_signal_strength_set = TRUE;

qmi_message_nas_get_signal_info_output_wcdma_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_info_output_gsm_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_gsm_signal_strength), NULL))
                goto qmi_message_nas_get_signal_info_output_gsm_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'GSM Signal Strength' TLV", offset);
            }

            self->arg_gsm_signal_strength_set = TRUE;

qmi_message_nas_get_signal_info_output_gsm_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_info_output_hdr_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_hdr_signal_strength_rssi), NULL))
                goto qmi_message_nas_get_signal_info_output_hdr_signal_strength_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_hdr_signal_strength_ecio), NULL))
                goto qmi_message_nas_get_signal_info_output_hdr_signal_strength_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_signal_info_output_hdr_signal_strength_out;
                self->arg_hdr_signal_strength_sinr = (QmiNasEvdoSinrLevel)tmp;
            }
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_hdr_signal_strength_io), NULL))
                goto qmi_message_nas_get_signal_info_output_hdr_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'HDR Signal Strength' TLV", offset);
            }

            self->arg_hdr_signal_strength_set = TRUE;

qmi_message_nas_get_signal_info_output_hdr_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_signal_info_output_cdma_signal_strength_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_cdma_signal_strength_rssi), NULL))
                goto qmi_message_nas_get_signal_info_output_cdma_signal_strength_out;
            if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_cdma_signal_strength_ecio), NULL))
                goto qmi_message_nas_get_signal_info_output_cdma_signal_strength_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA Signal Strength' TLV", offset);
            }

            self->arg_cdma_signal_strength_set = TRUE;

qmi_message_nas_get_signal_info_output_cdma_signal_strength_out:
            ;

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_signal_info_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_signal_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Config Signal Info */


/* --- Input -- */

struct _QmiMessageNasConfigSignalInfoInput {
    volatile gint ref_count;

    /* RSCP Threshold */
    gboolean arg_rscp_threshold_set;
    GArray *arg_rscp_threshold;

    /* LTE Report */
    gboolean arg_lte_report_set;
    guint8 arg_lte_report_rate;
    guint8 arg_lte_report_average_period;

    /* RSRP Threshold */
    gboolean arg_rsrp_threshold_set;
    GArray *arg_rsrp_threshold;

    /* RSRQ Threshold */
    gboolean arg_rsrq_threshold_set;
    GArray *arg_rsrq_threshold;

    /* IO Threshold */
    gboolean arg_io_threshold_set;
    GArray *arg_io_threshold;

    /* LTE SNR Threshold */
    gboolean arg_lte_snr_threshold_set;
    GArray *arg_lte_snr_threshold;

    /* SINR Threshold */
    gboolean arg_sinr_threshold_set;
    GArray *arg_sinr_threshold;

    /* ECIO Threshold */
    gboolean arg_ecio_threshold_set;
    GArray *arg_ecio_threshold;

    /* RSSI Threshold */
    gboolean arg_rssi_threshold_set;
    GArray *arg_rssi_threshold;
};

#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSCP_THRESHOLD 0x18
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_REPORT 0x17
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRP_THRESHOLD 0x16
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRQ_THRESHOLD 0x15
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_IO_THRESHOLD 0x14
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_SNR_THRESHOLD 0x13
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_SINR_THRESHOLD 0x12
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_ECIO_THRESHOLD 0x11
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSSI_THRESHOLD 0x10

gboolean
qmi_message_nas_config_signal_info_input_get_rscp_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **value_rscp_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rscp_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSCP Threshold' was not found in the message");
        return FALSE;
    }

    if (value_rscp_threshold)
        *value_rscp_threshold = self->arg_rscp_threshold;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_set_rscp_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *value_rscp_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_rscp_threshold)
        g_array_unref (self->arg_rscp_threshold);
    self->arg_rscp_threshold = g_array_ref (value_rscp_threshold);
    self->arg_rscp_threshold_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_get_lte_report (
    QmiMessageNasConfigSignalInfoInput *self,
    guint8 *value_lte_report_rate,
    guint8 *value_lte_report_average_period,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_report_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Report' was not found in the message");
        return FALSE;
    }

    if (value_lte_report_rate)
        *value_lte_report_rate = self->arg_lte_report_rate;
    if (value_lte_report_average_period)
        *value_lte_report_average_period = self->arg_lte_report_average_period;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_set_lte_report (
    QmiMessageNasConfigSignalInfoInput *self,
    guint8 value_lte_report_rate,
    guint8 value_lte_report_average_period,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_lte_report_rate = value_lte_report_rate;
    self->arg_lte_report_average_period = value_lte_report_average_period;
    self->arg_lte_report_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_get_rsrp_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **value_rsrp_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rsrp_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSRP Threshold' was not found in the message");
        return FALSE;
    }

    if (value_rsrp_threshold)
        *value_rsrp_threshold = self->arg_rsrp_threshold;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_set_rsrp_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *value_rsrp_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_rsrp_threshold)
        g_array_unref (self->arg_rsrp_threshold);
    self->arg_rsrp_threshold = g_array_ref (value_rsrp_threshold);
    self->arg_rsrp_threshold_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_get_rsrq_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **value_rsrq_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rsrq_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSRQ Threshold' was not found in the message");
        return FALSE;
    }

    if (value_rsrq_threshold)
        *value_rsrq_threshold = self->arg_rsrq_threshold;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_set_rsrq_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *value_rsrq_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_rsrq_threshold)
        g_array_unref (self->arg_rsrq_threshold);
    self->arg_rsrq_threshold = g_array_ref (value_rsrq_threshold);
    self->arg_rsrq_threshold_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_get_io_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **value_io_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_io_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'IO Threshold' was not found in the message");
        return FALSE;
    }

    if (value_io_threshold)
        *value_io_threshold = self->arg_io_threshold;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_set_io_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *value_io_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_io_threshold)
        g_array_unref (self->arg_io_threshold);
    self->arg_io_threshold = g_array_ref (value_io_threshold);
    self->arg_io_threshold_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_get_lte_snr_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **value_lte_snr_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_snr_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE SNR Threshold' was not found in the message");
        return FALSE;
    }

    if (value_lte_snr_threshold)
        *value_lte_snr_threshold = self->arg_lte_snr_threshold;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_set_lte_snr_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *value_lte_snr_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_lte_snr_threshold)
        g_array_unref (self->arg_lte_snr_threshold);
    self->arg_lte_snr_threshold = g_array_ref (value_lte_snr_threshold);
    self->arg_lte_snr_threshold_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_get_sinr_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **value_sinr_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sinr_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SINR Threshold' was not found in the message");
        return FALSE;
    }

    if (value_sinr_threshold)
        *value_sinr_threshold = self->arg_sinr_threshold;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_set_sinr_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *value_sinr_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_sinr_threshold)
        g_array_unref (self->arg_sinr_threshold);
    self->arg_sinr_threshold = g_array_ref (value_sinr_threshold);
    self->arg_sinr_threshold_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_get_ecio_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **value_ecio_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ecio_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ECIO Threshold' was not found in the message");
        return FALSE;
    }

    if (value_ecio_threshold)
        *value_ecio_threshold = self->arg_ecio_threshold;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_set_ecio_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *value_ecio_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_ecio_threshold)
        g_array_unref (self->arg_ecio_threshold);
    self->arg_ecio_threshold = g_array_ref (value_ecio_threshold);
    self->arg_ecio_threshold_set = TRUE;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_get_rssi_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **value_rssi_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rssi_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSSI Threshold' was not found in the message");
        return FALSE;
    }

    if (value_rssi_threshold)
        *value_rssi_threshold = self->arg_rssi_threshold;

    return TRUE;
}

gboolean
qmi_message_nas_config_signal_info_input_set_rssi_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *value_rssi_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_rssi_threshold)
        g_array_unref (self->arg_rssi_threshold);
    self->arg_rssi_threshold = g_array_ref (value_rssi_threshold);
    self->arg_rssi_threshold_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_config_signal_info_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasConfigSignalInfoInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_config_signal_info_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_config_signal_info_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasConfigSignalInfoInput *
qmi_message_nas_config_signal_info_input_ref (QmiMessageNasConfigSignalInfoInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_config_signal_info_input_unref (QmiMessageNasConfigSignalInfoInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_rscp_threshold)
            g_array_unref (self->arg_rscp_threshold);
        if (self->arg_rsrp_threshold)
            g_array_unref (self->arg_rsrp_threshold);
        if (self->arg_rsrq_threshold)
            g_array_unref (self->arg_rsrq_threshold);
        if (self->arg_io_threshold)
            g_array_unref (self->arg_io_threshold);
        if (self->arg_lte_snr_threshold)
            g_array_unref (self->arg_lte_snr_threshold);
        if (self->arg_sinr_threshold)
            g_array_unref (self->arg_sinr_threshold);
        if (self->arg_ecio_threshold)
            g_array_unref (self->arg_ecio_threshold);
        if (self->arg_rssi_threshold)
            g_array_unref (self->arg_rssi_threshold);
        g_slice_free (QmiMessageNasConfigSignalInfoInput, self);
    }
}

QmiMessageNasConfigSignalInfoInput *
qmi_message_nas_config_signal_info_input_new (void)
{
    QmiMessageNasConfigSignalInfoInput *self;

    self = g_slice_new0 (QmiMessageNasConfigSignalInfoInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_config_signal_info_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasConfigSignalInfoInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return g_steal_pointer (&self);

    /* Try to add the 'RSCP Threshold' TLV */
    if (input->arg_rscp_threshold_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSCP_THRESHOLD, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'RSCP Threshold': ");
            return NULL;
        }

        {
            guint rscp_threshold_i;
            guint8 rscp_threshold_n_items;

            /* Write the number of items in the array first */
            rscp_threshold_n_items = (guint8) input->arg_rscp_threshold->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, rscp_threshold_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'RSCP Threshold': ");
                return NULL;
            }

            for (rscp_threshold_i = 0; rscp_threshold_i < input->arg_rscp_threshold->len; rscp_threshold_i++) {
                /* Write the gint8 variable to the buffer */
                if (!qmi_message_tlv_write_gint8 (self, g_array_index (input->arg_rscp_threshold, gint8,rscp_threshold_i), error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'RSCP Threshold': ");
                    return NULL;
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'RSCP Threshold': ");
            return NULL;
        }
    }

    /* Try to add the 'LTE Report' TLV */
    if (input->arg_lte_report_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_REPORT, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'LTE Report': ");
            return NULL;
        }

        /* Write the guint8 variable to the buffer */
        if (!qmi_message_tlv_write_guint8 (self, input->arg_lte_report_rate, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'LTE Report': ");
            return NULL;
        }
        /* Write the guint8 variable to the buffer */
        if (!qmi_message_tlv_write_guint8 (self, input->arg_lte_report_average_period, error)) {
            g_prefix_error (error, "Cannot write integer in TLV 'LTE Report': ");
            return NULL;
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'LTE Report': ");
            return NULL;
        }
    }

    /* Try to add the 'RSRP Threshold' TLV */
    if (input->arg_rsrp_threshold_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRP_THRESHOLD, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'RSRP Threshold': ");
            return NULL;
        }

        {
            guint rsrp_threshold_i;
            guint8 rsrp_threshold_n_items;

            /* Write the number of items in the array first */
            rsrp_threshold_n_items = (guint8) input->arg_rsrp_threshold->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, rsrp_threshold_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'RSRP Threshold': ");
                return NULL;
            }

            for (rsrp_threshold_i = 0; rsrp_threshold_i < input->arg_rsrp_threshold->len; rsrp_threshold_i++) {
                /* Write the gint16 variable to the buffer */
                if (!qmi_message_tlv_write_gint16 (self, QMI_ENDIAN_LITTLE, g_array_index (input->arg_rsrp_threshold, gint16,rsrp_threshold_i), error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'RSRP Threshold': ");
                    return NULL;
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'RSRP Threshold': ");
            return NULL;
        }
    }

    /* Try to add the 'RSRQ Threshold' TLV */
    if (input->arg_rsrq_threshold_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRQ_THRESHOLD, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'RSRQ Threshold': ");
            return NULL;
        }

        {
            guint rsrq_threshold_i;
            guint8 rsrq_threshold_n_items;

            /* Write the number of items in the array first */
            rsrq_threshold_n_items = (guint8) input->arg_rsrq_threshold->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, rsrq_threshold_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'RSRQ Threshold': ");
                return NULL;
            }

            for (rsrq_threshold_i = 0; rsrq_threshold_i < input->arg_rsrq_threshold->len; rsrq_threshold_i++) {
                /* Write the gint8 variable to the buffer */
                if (!qmi_message_tlv_write_gint8 (self, g_array_index (input->arg_rsrq_threshold, gint8,rsrq_threshold_i), error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'RSRQ Threshold': ");
                    return NULL;
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'RSRQ Threshold': ");
            return NULL;
        }
    }

    /* Try to add the 'IO Threshold' TLV */
    if (input->arg_io_threshold_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_IO_THRESHOLD, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'IO Threshold': ");
            return NULL;
        }

        {
            guint io_threshold_i;
            guint8 io_threshold_n_items;

            /* Write the number of items in the array first */
            io_threshold_n_items = (guint8) input->arg_io_threshold->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, io_threshold_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'IO Threshold': ");
                return NULL;
            }

            for (io_threshold_i = 0; io_threshold_i < input->arg_io_threshold->len; io_threshold_i++) {
                /* Write the gint32 variable to the buffer */
                if (!qmi_message_tlv_write_gint32 (self, QMI_ENDIAN_LITTLE, g_array_index (input->arg_io_threshold, gint32,io_threshold_i), error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'IO Threshold': ");
                    return NULL;
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'IO Threshold': ");
            return NULL;
        }
    }

    /* Try to add the 'LTE SNR Threshold' TLV */
    if (input->arg_lte_snr_threshold_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_SNR_THRESHOLD, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'LTE SNR Threshold': ");
            return NULL;
        }

        {
            guint lte_snr_threshold_i;
            guint8 lte_snr_threshold_n_items;

            /* Write the number of items in the array first */
            lte_snr_threshold_n_items = (guint8) input->arg_lte_snr_threshold->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, lte_snr_threshold_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'LTE SNR Threshold': ");
                return NULL;
            }

            for (lte_snr_threshold_i = 0; lte_snr_threshold_i < input->arg_lte_snr_threshold->len; lte_snr_threshold_i++) {
                /* Write the gint16 variable to the buffer */
                if (!qmi_message_tlv_write_gint16 (self, QMI_ENDIAN_LITTLE, g_array_index (input->arg_lte_snr_threshold, gint16,lte_snr_threshold_i), error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'LTE SNR Threshold': ");
                    return NULL;
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'LTE SNR Threshold': ");
            return NULL;
        }
    }

    /* Try to add the 'SINR Threshold' TLV */
    if (input->arg_sinr_threshold_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_SINR_THRESHOLD, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'SINR Threshold': ");
            return NULL;
        }

        {
            guint sinr_threshold_i;
            guint8 sinr_threshold_n_items;

            /* Write the number of items in the array first */
            sinr_threshold_n_items = (guint8) input->arg_sinr_threshold->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, sinr_threshold_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'SINR Threshold': ");
                return NULL;
            }

            for (sinr_threshold_i = 0; sinr_threshold_i < input->arg_sinr_threshold->len; sinr_threshold_i++) {
                /* Write the guint8 variable to the buffer */
                if (!qmi_message_tlv_write_guint8 (self, g_array_index (input->arg_sinr_threshold, guint8,sinr_threshold_i), error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'SINR Threshold': ");
                    return NULL;
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'SINR Threshold': ");
            return NULL;
        }
    }

    /* Try to add the 'ECIO Threshold' TLV */
    if (input->arg_ecio_threshold_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_ECIO_THRESHOLD, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'ECIO Threshold': ");
            return NULL;
        }

        {
            guint ecio_threshold_i;
            guint8 ecio_threshold_n_items;

            /* Write the number of items in the array first */
            ecio_threshold_n_items = (guint8) input->arg_ecio_threshold->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, ecio_threshold_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'ECIO Threshold': ");
                return NULL;
            }

            for (ecio_threshold_i = 0; ecio_threshold_i < input->arg_ecio_threshold->len; ecio_threshold_i++) {
                /* Write the gint16 variable to the buffer */
                if (!qmi_message_tlv_write_gint16 (self, QMI_ENDIAN_LITTLE, g_array_index (input->arg_ecio_threshold, gint16,ecio_threshold_i), error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'ECIO Threshold': ");
                    return NULL;
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'ECIO Threshold': ");
            return NULL;
        }
    }

    /* Try to add the 'RSSI Threshold' TLV */
    if (input->arg_rssi_threshold_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSSI_THRESHOLD, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'RSSI Threshold': ");
            return NULL;
        }

        {
            guint rssi_threshold_i;
            guint8 rssi_threshold_n_items;

            /* Write the number of items in the array first */
            rssi_threshold_n_items = (guint8) input->arg_rssi_threshold->len;
            /* Write the guint8 variable to the buffer */
            if (!qmi_message_tlv_write_guint8 (self, rssi_threshold_n_items, error)) {
                g_prefix_error (error, "Cannot write integer in TLV 'RSSI Threshold': ");
                return NULL;
            }

            for (rssi_threshold_i = 0; rssi_threshold_i < input->arg_rssi_threshold->len; rssi_threshold_i++) {
                /* Write the gint8 variable to the buffer */
                if (!qmi_message_tlv_write_gint8 (self, g_array_index (input->arg_rssi_threshold, gint8,rssi_threshold_i), error)) {
                    g_prefix_error (error, "Cannot write integer in TLV 'RSSI Threshold': ");
                    return NULL;
                }
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'RSSI Threshold': ");
            return NULL;
        }
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasConfigSignalInfoOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_config_signal_info_output_get_result (
    QmiMessageNasConfigSignalInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_config_signal_info_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasConfigSignalInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_config_signal_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_config_signal_info_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasConfigSignalInfoOutput *
qmi_message_nas_config_signal_info_output_ref (QmiMessageNasConfigSignalInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_config_signal_info_output_unref (QmiMessageNasConfigSignalInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasConfigSignalInfoOutput, self);
    }
}

static gchar *
qmi_message_nas_config_signal_info_input_rscp_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSCP_THRESHOLD, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint rscp_threshold_i;
        guint8 rscp_threshold_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(rscp_threshold_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (rscp_threshold_i = 0; rscp_threshold_i < rscp_threshold_n_items; rscp_threshold_i++) {
            g_string_append_printf (printable, " [%u] = '", rscp_threshold_i);

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%d", (gint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_config_signal_info_input_lte_report_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_REPORT, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " rate = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " average_period = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_config_signal_info_input_rsrp_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRP_THRESHOLD, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint rsrp_threshold_i;
        guint8 rsrp_threshold_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(rsrp_threshold_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (rsrp_threshold_i = 0; rsrp_threshold_i < rsrp_threshold_n_items; rsrp_threshold_i++) {
            g_string_append_printf (printable, " [%u] = '", rsrp_threshold_i);

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_config_signal_info_input_rsrq_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRQ_THRESHOLD, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint rsrq_threshold_i;
        guint8 rsrq_threshold_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(rsrq_threshold_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (rsrq_threshold_i = 0; rsrq_threshold_i < rsrq_threshold_n_items; rsrq_threshold_i++) {
            g_string_append_printf (printable, " [%u] = '", rsrq_threshold_i);

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%d", (gint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_config_signal_info_input_io_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_IO_THRESHOLD, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint io_threshold_i;
        guint8 io_threshold_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(io_threshold_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (io_threshold_i = 0; io_threshold_i < io_threshold_n_items; io_threshold_i++) {
            g_string_append_printf (printable, " [%u] = '", io_threshold_i);

            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_config_signal_info_input_lte_snr_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_SNR_THRESHOLD, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint lte_snr_threshold_i;
        guint8 lte_snr_threshold_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(lte_snr_threshold_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (lte_snr_threshold_i = 0; lte_snr_threshold_i < lte_snr_threshold_n_items; lte_snr_threshold_i++) {
            g_string_append_printf (printable, " [%u] = '", lte_snr_threshold_i);

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_config_signal_info_input_sinr_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_SINR_THRESHOLD, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint sinr_threshold_i;
        guint8 sinr_threshold_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(sinr_threshold_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (sinr_threshold_i = 0; sinr_threshold_i < sinr_threshold_n_items; sinr_threshold_i++) {
            g_string_append_printf (printable, " [%u] = '", sinr_threshold_i);

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_config_signal_info_input_ecio_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_ECIO_THRESHOLD, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint ecio_threshold_i;
        guint8 ecio_threshold_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(ecio_threshold_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (ecio_threshold_i = 0; ecio_threshold_i < ecio_threshold_n_items; ecio_threshold_i++) {
            g_string_append_printf (printable, " [%u] = '", ecio_threshold_i);

            {
                gint16 tmp;

                if (!qmi_message_tlv_read_gint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_config_signal_info_input_rssi_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSSI_THRESHOLD, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint rssi_threshold_i;
        guint8 rssi_threshold_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(rssi_threshold_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (rssi_threshold_i = 0; rssi_threshold_i < rssi_threshold_n_items; rssi_threshold_i++) {
            g_string_append_printf (printable, " [%u] = '", rssi_threshold_i);

            {
                gint8 tmp;

                if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%d", (gint)tmp);
            }
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_config_signal_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_config_signal_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_config_signal_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSCP_THRESHOLD:
            tlv_type_str = "RSCP Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_rscp_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_REPORT:
            tlv_type_str = "LTE Report";
            translated_value = qmi_message_nas_config_signal_info_input_lte_report_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRP_THRESHOLD:
            tlv_type_str = "RSRP Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_rsrp_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRQ_THRESHOLD:
            tlv_type_str = "RSRQ Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_rsrq_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_IO_THRESHOLD:
            tlv_type_str = "IO Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_io_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_SNR_THRESHOLD:
            tlv_type_str = "LTE SNR Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_lte_snr_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_SINR_THRESHOLD:
            tlv_type_str = "SINR Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_sinr_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_ECIO_THRESHOLD:
            tlv_type_str = "ECIO Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_ecio_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSSI_THRESHOLD:
            tlv_type_str = "RSSI Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_rssi_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_config_signal_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Config Signal Info\" (0x0050)\n",
                            line_prefix);

    {
        struct message_config_signal_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_config_signal_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasConfigSignalInfoOutput *
__qmi_message_nas_config_signal_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasConfigSignalInfoOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO);

    self = g_slice_new0 (QmiMessageNasConfigSignalInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_config_signal_info_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_config_signal_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Tx Rx Info */


/* --- Input -- */

struct _QmiMessageNasGetTxRxInfoInput {
    volatile gint ref_count;

    /* Radio Interface */
    gboolean arg_radio_interface_set;
    gint8 arg_radio_interface;
};

#define QMI_MESSAGE_NAS_GET_TX_RX_INFO_INPUT_TLV_RADIO_INTERFACE 0x01

gboolean
qmi_message_nas_get_tx_rx_info_input_get_radio_interface (
    QmiMessageNasGetTxRxInfoInput *self,
    QmiNasRadioInterface *value_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_radio_interface_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Radio Interface' was not found in the message");
        return FALSE;
    }

    if (value_radio_interface)
        *value_radio_interface = (QmiNasRadioInterface)(self->arg_radio_interface);

    return TRUE;
}

gboolean
qmi_message_nas_get_tx_rx_info_input_set_radio_interface (
    QmiMessageNasGetTxRxInfoInput *self,
    QmiNasRadioInterface value_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_radio_interface = (gint8)(value_radio_interface);
    self->arg_radio_interface_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_get_tx_rx_info_input_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetTxRxInfoInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_tx_rx_info_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_tx_rx_info_input_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetTxRxInfoInput *
qmi_message_nas_get_tx_rx_info_input_ref (QmiMessageNasGetTxRxInfoInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_tx_rx_info_input_unref (QmiMessageNasGetTxRxInfoInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetTxRxInfoInput, self);
    }
}

QmiMessageNasGetTxRxInfoInput *
qmi_message_nas_get_tx_rx_info_input_new (void)
{
    QmiMessageNasGetTxRxInfoInput *self;

    self = g_slice_new0 (QmiMessageNasGetTxRxInfoInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_get_tx_rx_info_request_create (
    guint16 transaction_id,
    guint8 cid,
    QmiMessageNasGetTxRxInfoInput *input,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_TX_RX_INFO);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Get Tx Rx Info' has mandatory TLVs");
        return NULL;
    }

    /* Try to add the 'Radio Interface' TLV */
    if (input->arg_radio_interface_set) {
        gsize tlv_offset;

        if (!(tlv_offset = qmi_message_tlv_write_init (self, (guint8)QMI_MESSAGE_NAS_GET_TX_RX_INFO_INPUT_TLV_RADIO_INTERFACE, error))) {
            g_prefix_error (error, "Cannot initialize TLV 'Radio Interface': ");
            return NULL;
        }

        {
            gint8 tmp;

            tmp = (gint8) input->arg_radio_interface;
            /* Write the gint8 variable to the buffer */
            if (!qmi_message_tlv_write_gint8 (self, tmp, error)) {
                g_prefix_error (error, "Cannot write enum in TLV 'Radio Interface': ");
                return NULL;
            }
        }

        if (!qmi_message_tlv_write_complete (self, tlv_offset, error)) {
            g_prefix_error (error, "Cannot complete TLV 'Radio Interface': ");
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Radio Interface' in message 'Get Tx Rx Info'");
        return NULL;
    }

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetTxRxInfoOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Rx Chain 0 Info */
    gboolean arg_rx_chain_0_info_set;
    guint8 arg_rx_chain_0_info_is_radio_tuned;
    gint32 arg_rx_chain_0_info_rx_power;
    gint32 arg_rx_chain_0_info_ecio;
    gint32 arg_rx_chain_0_info_rscp;
    gint32 arg_rx_chain_0_info_rsrp;
    guint32 arg_rx_chain_0_info_phase;

    /* Rx Chain 1 Info */
    gboolean arg_rx_chain_1_info_set;
    guint8 arg_rx_chain_1_info_is_radio_tuned;
    gint32 arg_rx_chain_1_info_rx_power;
    gint32 arg_rx_chain_1_info_ecio;
    gint32 arg_rx_chain_1_info_rscp;
    gint32 arg_rx_chain_1_info_rsrp;
    guint32 arg_rx_chain_1_info_phase;

    /* Tx Info */
    gboolean arg_tx_info_set;
    guint8 arg_tx_info_is_in_traffic;
    gint32 arg_tx_info_tx_power;

    /* Rx Chain 2 Info */
    gboolean arg_rx_chain_2_info_set;
    guint8 arg_rx_chain_2_info_is_radio_tuned;
    gint32 arg_rx_chain_2_info_rx_power;
    gint32 arg_rx_chain_2_info_ecio;
    gint32 arg_rx_chain_2_info_rscp;
    gint32 arg_rx_chain_2_info_rsrp;
    guint32 arg_rx_chain_2_info_phase;

    /* Rx Chain 3 Info */
    gboolean arg_rx_chain_3_info_set;
    guint8 arg_rx_chain_3_info_is_radio_tuned;
    gint32 arg_rx_chain_3_info_rx_power;
    gint32 arg_rx_chain_3_info_ecio;
    gint32 arg_rx_chain_3_info_rscp;
    gint32 arg_rx_chain_3_info_rsrp;
    guint32 arg_rx_chain_3_info_phase;
};

#define QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_0_INFO 0x10
#define QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_1_INFO 0x11
#define QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_TX_INFO 0x12
#define QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_2_INFO 0x15
#define QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_3_INFO 0x16

gboolean
qmi_message_nas_get_tx_rx_info_output_get_result (
    QmiMessageNasGetTxRxInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_get_tx_rx_info_output_get_rx_chain_0_info (
    QmiMessageNasGetTxRxInfoOutput *self,
    gboolean *value_rx_chain_0_info_is_radio_tuned,
    gint32 *value_rx_chain_0_info_rx_power,
    gint32 *value_rx_chain_0_info_ecio,
    gint32 *value_rx_chain_0_info_rscp,
    gint32 *value_rx_chain_0_info_rsrp,
    guint32 *value_rx_chain_0_info_phase,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rx_chain_0_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Rx Chain 0 Info' was not found in the message");
        return FALSE;
    }

    if (value_rx_chain_0_info_is_radio_tuned)
        *value_rx_chain_0_info_is_radio_tuned = (gboolean)(self->arg_rx_chain_0_info_is_radio_tuned);
    if (value_rx_chain_0_info_rx_power)
        *value_rx_chain_0_info_rx_power = self->arg_rx_chain_0_info_rx_power;
    if (value_rx_chain_0_info_ecio)
        *value_rx_chain_0_info_ecio = self->arg_rx_chain_0_info_ecio;
    if (value_rx_chain_0_info_rscp)
        *value_rx_chain_0_info_rscp = self->arg_rx_chain_0_info_rscp;
    if (value_rx_chain_0_info_rsrp)
        *value_rx_chain_0_info_rsrp = self->arg_rx_chain_0_info_rsrp;
    if (value_rx_chain_0_info_phase)
        *value_rx_chain_0_info_phase = self->arg_rx_chain_0_info_phase;

    return TRUE;
}

gboolean
qmi_message_nas_get_tx_rx_info_output_get_rx_chain_1_info (
    QmiMessageNasGetTxRxInfoOutput *self,
    gboolean *value_rx_chain_1_info_is_radio_tuned,
    gint32 *value_rx_chain_1_info_rx_power,
    gint32 *value_rx_chain_1_info_ecio,
    gint32 *value_rx_chain_1_info_rscp,
    gint32 *value_rx_chain_1_info_rsrp,
    guint32 *value_rx_chain_1_info_phase,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rx_chain_1_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Rx Chain 1 Info' was not found in the message");
        return FALSE;
    }

    if (value_rx_chain_1_info_is_radio_tuned)
        *value_rx_chain_1_info_is_radio_tuned = (gboolean)(self->arg_rx_chain_1_info_is_radio_tuned);
    if (value_rx_chain_1_info_rx_power)
        *value_rx_chain_1_info_rx_power = self->arg_rx_chain_1_info_rx_power;
    if (value_rx_chain_1_info_ecio)
        *value_rx_chain_1_info_ecio = self->arg_rx_chain_1_info_ecio;
    if (value_rx_chain_1_info_rscp)
        *value_rx_chain_1_info_rscp = self->arg_rx_chain_1_info_rscp;
    if (value_rx_chain_1_info_rsrp)
        *value_rx_chain_1_info_rsrp = self->arg_rx_chain_1_info_rsrp;
    if (value_rx_chain_1_info_phase)
        *value_rx_chain_1_info_phase = self->arg_rx_chain_1_info_phase;

    return TRUE;
}

gboolean
qmi_message_nas_get_tx_rx_info_output_get_tx_info (
    QmiMessageNasGetTxRxInfoOutput *self,
    gboolean *value_tx_info_is_in_traffic,
    gint32 *value_tx_info_tx_power,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_tx_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Tx Info' was not found in the message");
        return FALSE;
    }

    if (value_tx_info_is_in_traffic)
        *value_tx_info_is_in_traffic = (gboolean)(self->arg_tx_info_is_in_traffic);
    if (value_tx_info_tx_power)
        *value_tx_info_tx_power = self->arg_tx_info_tx_power;

    return TRUE;
}

gboolean
qmi_message_nas_get_tx_rx_info_output_get_rx_chain_2_info (
    QmiMessageNasGetTxRxInfoOutput *self,
    gboolean *value_rx_chain_2_info_is_radio_tuned,
    gint32 *value_rx_chain_2_info_rx_power,
    gint32 *value_rx_chain_2_info_ecio,
    gint32 *value_rx_chain_2_info_rscp,
    gint32 *value_rx_chain_2_info_rsrp,
    guint32 *value_rx_chain_2_info_phase,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rx_chain_2_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Rx Chain 2 Info' was not found in the message");
        return FALSE;
    }

    if (value_rx_chain_2_info_is_radio_tuned)
        *value_rx_chain_2_info_is_radio_tuned = (gboolean)(self->arg_rx_chain_2_info_is_radio_tuned);
    if (value_rx_chain_2_info_rx_power)
        *value_rx_chain_2_info_rx_power = self->arg_rx_chain_2_info_rx_power;
    if (value_rx_chain_2_info_ecio)
        *value_rx_chain_2_info_ecio = self->arg_rx_chain_2_info_ecio;
    if (value_rx_chain_2_info_rscp)
        *value_rx_chain_2_info_rscp = self->arg_rx_chain_2_info_rscp;
    if (value_rx_chain_2_info_rsrp)
        *value_rx_chain_2_info_rsrp = self->arg_rx_chain_2_info_rsrp;
    if (value_rx_chain_2_info_phase)
        *value_rx_chain_2_info_phase = self->arg_rx_chain_2_info_phase;

    return TRUE;
}

gboolean
qmi_message_nas_get_tx_rx_info_output_get_rx_chain_3_info (
    QmiMessageNasGetTxRxInfoOutput *self,
    gboolean *value_rx_chain_3_info_is_radio_tuned,
    gint32 *value_rx_chain_3_info_rx_power,
    gint32 *value_rx_chain_3_info_ecio,
    gint32 *value_rx_chain_3_info_rscp,
    gint32 *value_rx_chain_3_info_rsrp,
    guint32 *value_rx_chain_3_info_phase,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rx_chain_3_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Rx Chain 3 Info' was not found in the message");
        return FALSE;
    }

    if (value_rx_chain_3_info_is_radio_tuned)
        *value_rx_chain_3_info_is_radio_tuned = (gboolean)(self->arg_rx_chain_3_info_is_radio_tuned);
    if (value_rx_chain_3_info_rx_power)
        *value_rx_chain_3_info_rx_power = self->arg_rx_chain_3_info_rx_power;
    if (value_rx_chain_3_info_ecio)
        *value_rx_chain_3_info_ecio = self->arg_rx_chain_3_info_ecio;
    if (value_rx_chain_3_info_rscp)
        *value_rx_chain_3_info_rscp = self->arg_rx_chain_3_info_rscp;
    if (value_rx_chain_3_info_rsrp)
        *value_rx_chain_3_info_rsrp = self->arg_rx_chain_3_info_rsrp;
    if (value_rx_chain_3_info_phase)
        *value_rx_chain_3_info_phase = self->arg_rx_chain_3_info_phase;

    return TRUE;
}

GType
qmi_message_nas_get_tx_rx_info_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetTxRxInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_tx_rx_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_tx_rx_info_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetTxRxInfoOutput *
qmi_message_nas_get_tx_rx_info_output_ref (QmiMessageNasGetTxRxInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_tx_rx_info_output_unref (QmiMessageNasGetTxRxInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetTxRxInfoOutput, self);
    }
}

static gchar *
qmi_message_nas_get_tx_rx_info_input_radio_interface_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_INPUT_TLV_RADIO_INTERFACE, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_tx_rx_info_output_rx_chain_0_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_0_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " is_radio_tuned = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rx_power = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rscp = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rsrp = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " phase = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_tx_rx_info_output_rx_chain_1_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_1_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " is_radio_tuned = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rx_power = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rscp = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rsrp = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " phase = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_tx_rx_info_output_tx_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_TX_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " is_in_traffic = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " tx_power = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_tx_rx_info_output_rx_chain_2_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_2_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " is_radio_tuned = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rx_power = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rscp = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rsrp = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " phase = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_tx_rx_info_output_rx_chain_3_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_3_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " is_radio_tuned = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rx_power = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ecio = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rscp = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rsrp = '");

    {
        gint32 tmp;

        if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " phase = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_tx_rx_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_tx_rx_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_tx_rx_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_TX_RX_INFO_INPUT_TLV_RADIO_INTERFACE:
            tlv_type_str = "Radio Interface";
            translated_value = qmi_message_nas_get_tx_rx_info_input_radio_interface_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_0_INFO:
            tlv_type_str = "Rx Chain 0 Info";
            translated_value = qmi_message_nas_get_tx_rx_info_output_rx_chain_0_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_1_INFO:
            tlv_type_str = "Rx Chain 1 Info";
            translated_value = qmi_message_nas_get_tx_rx_info_output_rx_chain_1_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_TX_INFO:
            tlv_type_str = "Tx Info";
            translated_value = qmi_message_nas_get_tx_rx_info_output_tx_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_2_INFO:
            tlv_type_str = "Rx Chain 2 Info";
            translated_value = qmi_message_nas_get_tx_rx_info_output_rx_chain_2_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_3_INFO:
            tlv_type_str = "Rx Chain 3 Info";
            translated_value = qmi_message_nas_get_tx_rx_info_output_rx_chain_3_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_tx_rx_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Tx Rx Info\" (0x005A)\n",
                            line_prefix);

    {
        struct message_get_tx_rx_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_tx_rx_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetTxRxInfoOutput *
__qmi_message_nas_get_tx_rx_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetTxRxInfoOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_TX_RX_INFO);

    self = g_slice_new0 (QmiMessageNasGetTxRxInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_tx_rx_info_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_tx_rx_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_0_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_0_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_tx_rx_info_output_rx_chain_0_info_out;
                self->arg_rx_chain_0_info_is_radio_tuned = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_0_info_rx_power), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_0_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_0_info_ecio), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_0_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_0_info_rscp), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_0_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_0_info_rsrp), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_0_info_out;
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_0_info_phase), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_0_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Rx Chain 0 Info' TLV", offset);
            }

            self->arg_rx_chain_0_info_set = TRUE;

qmi_message_nas_get_tx_rx_info_output_rx_chain_0_info_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_1_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_1_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_tx_rx_info_output_rx_chain_1_info_out;
                self->arg_rx_chain_1_info_is_radio_tuned = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_1_info_rx_power), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_1_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_1_info_ecio), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_1_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_1_info_rscp), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_1_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_1_info_rsrp), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_1_info_out;
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_1_info_phase), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_1_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Rx Chain 1 Info' TLV", offset);
            }

            self->arg_rx_chain_1_info_set = TRUE;

qmi_message_nas_get_tx_rx_info_output_rx_chain_1_info_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_TX_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_tx_rx_info_output_tx_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_tx_rx_info_output_tx_info_out;
                self->arg_tx_info_is_in_traffic = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_tx_info_tx_power), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_tx_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Tx Info' TLV", offset);
            }

            self->arg_tx_info_set = TRUE;

qmi_message_nas_get_tx_rx_info_output_tx_info_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_2_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_2_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_tx_rx_info_output_rx_chain_2_info_out;
                self->arg_rx_chain_2_info_is_radio_tuned = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_2_info_rx_power), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_2_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_2_info_ecio), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_2_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_2_info_rscp), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_2_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_2_info_rsrp), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_2_info_out;
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_2_info_phase), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_2_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Rx Chain 2 Info' TLV", offset);
            }

            self->arg_rx_chain_2_info_set = TRUE;

qmi_message_nas_get_tx_rx_info_output_rx_chain_2_info_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_TX_RX_INFO_OUTPUT_TLV_RX_CHAIN_3_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_3_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_get_tx_rx_info_output_rx_chain_3_info_out;
                self->arg_rx_chain_3_info_is_radio_tuned = (gboolean)tmp;
            }
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_3_info_rx_power), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_3_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_3_info_ecio), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_3_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_3_info_rscp), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_3_info_out;
            if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_3_info_rsrp), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_3_info_out;
            if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_rx_chain_3_info_phase), NULL))
                goto qmi_message_nas_get_tx_rx_info_output_rx_chain_3_info_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Rx Chain 3 Info' TLV", offset);
            }

            self->arg_rx_chain_3_info_set = TRUE;

qmi_message_nas_get_tx_rx_info_output_rx_chain_3_info_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get CDMA Position Info */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_cdma_position_info_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetCdmaPositionInfoOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* CDMA Position Info */
    gboolean arg_cdma_position_info_set;
    gint8 arg_cdma_position_info_ui_in_idle_mode;
    GArray *arg_cdma_position_info_basestations;
};

#define QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_CDMA_POSITION_INFO 0x10

gboolean
qmi_message_nas_get_cdma_position_info_output_get_result (
    QmiMessageNasGetCdmaPositionInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_get_cdma_position_info_output_get_cdma_position_info (
    QmiMessageNasGetCdmaPositionInfoOutput *self,
    gint8 *value_cdma_position_info_ui_in_idle_mode,
    GArray **value_cdma_position_info_basestations,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_position_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Position Info' was not found in the message");
        return FALSE;
    }

    if (value_cdma_position_info_ui_in_idle_mode)
        *value_cdma_position_info_ui_in_idle_mode = self->arg_cdma_position_info_ui_in_idle_mode;
    if (value_cdma_position_info_basestations)
        *value_cdma_position_info_basestations = self->arg_cdma_position_info_basestations;

    return TRUE;
}

GType
qmi_message_nas_get_cdma_position_info_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetCdmaPositionInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_cdma_position_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_cdma_position_info_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetCdmaPositionInfoOutput *
qmi_message_nas_get_cdma_position_info_output_ref (QmiMessageNasGetCdmaPositionInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_cdma_position_info_output_unref (QmiMessageNasGetCdmaPositionInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_cdma_position_info_basestations)
            g_array_unref (self->arg_cdma_position_info_basestations);
        g_slice_free (QmiMessageNasGetCdmaPositionInfoOutput, self);
    }
}

static gchar *
qmi_message_nas_get_cdma_position_info_output_cdma_position_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_CDMA_POSITION_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " ui_in_idle_mode = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " basestations = '");
    {
        guint basestations_i;
        guint8 basestations_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(basestations_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (basestations_i = 0; basestations_i < basestations_n_items; basestations_i++) {
            g_string_append_printf (printable, " [%u] = '", basestations_i);
            g_string_append (printable, "[");
            g_string_append (printable, " pilot_type = '");

            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_CDMA_PILOT_TYPE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_cdma_pilot_type_get_string ((QmiNasCdmaPilotType)tmp));
#elif defined  __QMI_NAS_CDMA_PILOT_TYPE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_cdma_pilot_type_build_string_from_mask ((QmiNasCdmaPilotType)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasCdmaPilotType
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " system_id = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " network_id = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " base_station_id = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " pilot_pn = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " pilot_strength = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " latitude = '");

            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " longitude = '");

            {
                gint32 tmp;

                if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " gps_time_in_milliseconds = '");

            {
                guint64 tmp;

                if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_cdma_position_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_cdma_position_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_cdma_position_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_CDMA_POSITION_INFO:
            tlv_type_str = "CDMA Position Info";
            translated_value = qmi_message_nas_get_cdma_position_info_output_cdma_position_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_cdma_position_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get CDMA Position Info\" (0x0065)\n",
                            line_prefix);

    {
        struct message_get_cdma_position_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_cdma_position_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetCdmaPositionInfoOutput *
__qmi_message_nas_get_cdma_position_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetCdmaPositionInfoOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO);

    self = g_slice_new0 (QmiMessageNasGetCdmaPositionInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_cdma_position_info_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_cdma_position_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_CDMA_POSITION_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_cdma_position_info_ui_in_idle_mode), NULL))
                goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;
            {
                guint basestations_i;
                guint8 basestations_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(basestations_n_items), NULL))
                    goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;

                self->arg_cdma_position_info_basestations = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation),
                    (guint)basestations_n_items);

                for (basestations_i = 0; basestations_i < basestations_n_items; basestations_i++) {
                    QmiMessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation basestations_aux;

                    {
                        guint32 tmp;

                        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                            goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;
                        basestations_aux.pilot_type = (QmiNasCdmaPilotType)tmp;
                    }
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(basestations_aux.system_id), NULL))
                        goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(basestations_aux.network_id), NULL))
                        goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(basestations_aux.base_station_id), NULL))
                        goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(basestations_aux.pilot_pn), NULL))
                        goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(basestations_aux.pilot_strength), NULL))
                        goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;
                    if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(basestations_aux.latitude), NULL))
                        goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;
                    if (!qmi_message_tlv_read_gint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(basestations_aux.longitude), NULL))
                        goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;
                    if (!qmi_message_tlv_read_guint64 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(basestations_aux.gps_time_in_milliseconds), NULL))
                        goto qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out;
                    g_array_insert_val (self->arg_cdma_position_info_basestations, basestations_i, basestations_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'CDMA Position Info' TLV", offset);
            }

            self->arg_cdma_position_info_set = TRUE;

qmi_message_nas_get_cdma_position_info_output_cdma_position_info_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Force Network Search */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_force_network_search_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_FORCE_NETWORK_SEARCH);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasForceNetworkSearchOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_FORCE_NETWORK_SEARCH_OUTPUT_TLV_RESULT 0x02

gboolean
qmi_message_nas_force_network_search_output_get_result (
    QmiMessageNasForceNetworkSearchOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_force_network_search_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasForceNetworkSearchOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_force_network_search_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_force_network_search_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasForceNetworkSearchOutput *
qmi_message_nas_force_network_search_output_ref (QmiMessageNasForceNetworkSearchOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_force_network_search_output_unref (QmiMessageNasForceNetworkSearchOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasForceNetworkSearchOutput, self);
    }
}

struct message_force_network_search_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_force_network_search_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_force_network_search_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_FORCE_NETWORK_SEARCH_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_force_network_search_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Force Network Search\" (0x0067)\n",
                            line_prefix);

    {
        struct message_force_network_search_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_force_network_search_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasForceNetworkSearchOutput *
__qmi_message_nas_force_network_search_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasForceNetworkSearchOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_FORCE_NETWORK_SEARCH);

    self = g_slice_new0 (QmiMessageNasForceNetworkSearchOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_FORCE_NETWORK_SEARCH_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_force_network_search_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_force_network_search_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get DRX */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_drx_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_DRX);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetDrxOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Info */
    gboolean arg_info_set;
    guint32 arg_info;
};

#define QMI_MESSAGE_NAS_GET_DRX_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_DRX_OUTPUT_TLV_INFO 0x10

gboolean
qmi_message_nas_get_drx_output_get_result (
    QmiMessageNasGetDrxOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_get_drx_output_get_info (
    QmiMessageNasGetDrxOutput *self,
    QmiNasDrx *value_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Info' was not found in the message");
        return FALSE;
    }

    if (value_info)
        *value_info = (QmiNasDrx)(self->arg_info);

    return TRUE;
}

GType
qmi_message_nas_get_drx_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetDrxOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_drx_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_drx_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetDrxOutput *
qmi_message_nas_get_drx_output_ref (QmiMessageNasGetDrxOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_drx_output_unref (QmiMessageNasGetDrxOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetDrxOutput, self);
    }
}

static gchar *
qmi_message_nas_get_drx_output_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_DRX_OUTPUT_TLV_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_DRX_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_drx_get_string ((QmiNasDrx)tmp));
#elif defined  __QMI_NAS_DRX_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_drx_build_string_from_mask ((QmiNasDrx)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasDrx
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_drx_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_drx_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_drx_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_DRX_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_DRX_OUTPUT_TLV_INFO:
            tlv_type_str = "Info";
            translated_value = qmi_message_nas_get_drx_output_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_drx_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get DRX\" (0x0089)\n",
                            line_prefix);

    {
        struct message_get_drx_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_drx_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetDrxOutput *
__qmi_message_nas_get_drx_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetDrxOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_DRX);

    self = g_slice_new0 (QmiMessageNasGetDrxOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_DRX_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_drx_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_drx_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_DRX_OUTPUT_TLV_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_drx_output_info_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_drx_output_info_out;
                self->arg_info = (QmiNasDrx)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Info' TLV", offset);
            }

            self->arg_info_set = TRUE;

qmi_message_nas_get_drx_output_info_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get LTE Cphy CA Info */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_lte_cphy_ca_info_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasGetLteCphyCaInfoOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* DL Bandwidth */
    gboolean arg_dl_bandwidth_set;
    guint32 arg_dl_bandwidth;

    /* Phy CA Agg SCell Info */
    gboolean arg_phy_ca_agg_scell_info_set;
    guint16 arg_phy_ca_agg_scell_info_physical_cell_id;
    guint16 arg_phy_ca_agg_scell_info_rx_channel;
    guint32 arg_phy_ca_agg_scell_info_dl_bandwidth;
    guint16 arg_phy_ca_agg_scell_info_lte_band;
    guint32 arg_phy_ca_agg_scell_info_state;

    /* Phy CA Agg PCell Info */
    gboolean arg_phy_ca_agg_pcell_info_set;
    guint16 arg_phy_ca_agg_pcell_info_physical_cell_id;
    guint16 arg_phy_ca_agg_pcell_info_rx_channel;
    guint32 arg_phy_ca_agg_pcell_info_dl_bandwidth;
    guint16 arg_phy_ca_agg_pcell_info_lte_band;

    /* SCell index */
    gboolean arg_scell_index_set;
    guint8 arg_scell_index;

    /* Phy CA Agg Secondary Cells */
    gboolean arg_phy_ca_agg_secondary_cells_set;
    GArray *arg_phy_ca_agg_secondary_cells;
};

#define QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_DL_BANDWIDTH 0x11
#define QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_SCELL_INFO 0x12
#define QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_PCELL_INFO 0x13
#define QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_SCELL_INDEX 0x14
#define QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_SECONDARY_CELLS 0x15

gboolean
qmi_message_nas_get_lte_cphy_ca_info_output_get_result (
    QmiMessageNasGetLteCphyCaInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_get_lte_cphy_ca_info_output_get_dl_bandwidth (
    QmiMessageNasGetLteCphyCaInfoOutput *self,
    QmiNasDLBandwidth *value_dl_bandwidth,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_dl_bandwidth_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'DL Bandwidth' was not found in the message");
        return FALSE;
    }

    if (value_dl_bandwidth)
        *value_dl_bandwidth = (QmiNasDLBandwidth)(self->arg_dl_bandwidth);

    return TRUE;
}

gboolean
qmi_message_nas_get_lte_cphy_ca_info_output_get_phy_ca_agg_scell_info (
    QmiMessageNasGetLteCphyCaInfoOutput *self,
    guint16 *value_phy_ca_agg_scell_info_physical_cell_id,
    guint16 *value_phy_ca_agg_scell_info_rx_channel,
    QmiNasDLBandwidth *value_phy_ca_agg_scell_info_dl_bandwidth,
    QmiNasActiveBand *value_phy_ca_agg_scell_info_lte_band,
    QmiNasScellState *value_phy_ca_agg_scell_info_state,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_phy_ca_agg_scell_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Phy CA Agg SCell Info' was not found in the message");
        return FALSE;
    }

    if (value_phy_ca_agg_scell_info_physical_cell_id)
        *value_phy_ca_agg_scell_info_physical_cell_id = self->arg_phy_ca_agg_scell_info_physical_cell_id;
    if (value_phy_ca_agg_scell_info_rx_channel)
        *value_phy_ca_agg_scell_info_rx_channel = self->arg_phy_ca_agg_scell_info_rx_channel;
    if (value_phy_ca_agg_scell_info_dl_bandwidth)
        *value_phy_ca_agg_scell_info_dl_bandwidth = (QmiNasDLBandwidth)(self->arg_phy_ca_agg_scell_info_dl_bandwidth);
    if (value_phy_ca_agg_scell_info_lte_band)
        *value_phy_ca_agg_scell_info_lte_band = (QmiNasActiveBand)(self->arg_phy_ca_agg_scell_info_lte_band);
    if (value_phy_ca_agg_scell_info_state)
        *value_phy_ca_agg_scell_info_state = (QmiNasScellState)(self->arg_phy_ca_agg_scell_info_state);

    return TRUE;
}

gboolean
qmi_message_nas_get_lte_cphy_ca_info_output_get_phy_ca_agg_pcell_info (
    QmiMessageNasGetLteCphyCaInfoOutput *self,
    guint16 *value_phy_ca_agg_pcell_info_physical_cell_id,
    guint16 *value_phy_ca_agg_pcell_info_rx_channel,
    QmiNasDLBandwidth *value_phy_ca_agg_pcell_info_dl_bandwidth,
    QmiNasActiveBand *value_phy_ca_agg_pcell_info_lte_band,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_phy_ca_agg_pcell_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Phy CA Agg PCell Info' was not found in the message");
        return FALSE;
    }

    if (value_phy_ca_agg_pcell_info_physical_cell_id)
        *value_phy_ca_agg_pcell_info_physical_cell_id = self->arg_phy_ca_agg_pcell_info_physical_cell_id;
    if (value_phy_ca_agg_pcell_info_rx_channel)
        *value_phy_ca_agg_pcell_info_rx_channel = self->arg_phy_ca_agg_pcell_info_rx_channel;
    if (value_phy_ca_agg_pcell_info_dl_bandwidth)
        *value_phy_ca_agg_pcell_info_dl_bandwidth = (QmiNasDLBandwidth)(self->arg_phy_ca_agg_pcell_info_dl_bandwidth);
    if (value_phy_ca_agg_pcell_info_lte_band)
        *value_phy_ca_agg_pcell_info_lte_band = (QmiNasActiveBand)(self->arg_phy_ca_agg_pcell_info_lte_band);

    return TRUE;
}

gboolean
qmi_message_nas_get_lte_cphy_ca_info_output_get_scell_index (
    QmiMessageNasGetLteCphyCaInfoOutput *self,
    guint8 *value_scell_index,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_scell_index_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SCell index' was not found in the message");
        return FALSE;
    }

    if (value_scell_index)
        *value_scell_index = self->arg_scell_index;

    return TRUE;
}

gboolean
qmi_message_nas_get_lte_cphy_ca_info_output_get_phy_ca_agg_secondary_cells (
    QmiMessageNasGetLteCphyCaInfoOutput *self,
    GArray **value_phy_ca_agg_secondary_cells,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_phy_ca_agg_secondary_cells_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Phy CA Agg Secondary Cells' was not found in the message");
        return FALSE;
    }

    if (value_phy_ca_agg_secondary_cells)
        *value_phy_ca_agg_secondary_cells = self->arg_phy_ca_agg_secondary_cells;

    return TRUE;
}

GType
qmi_message_nas_get_lte_cphy_ca_info_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetLteCphyCaInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_lte_cphy_ca_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_lte_cphy_ca_info_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasGetLteCphyCaInfoOutput *
qmi_message_nas_get_lte_cphy_ca_info_output_ref (QmiMessageNasGetLteCphyCaInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_get_lte_cphy_ca_info_output_unref (QmiMessageNasGetLteCphyCaInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_phy_ca_agg_secondary_cells)
            g_array_unref (self->arg_phy_ca_agg_secondary_cells);
        g_slice_free (QmiMessageNasGetLteCphyCaInfoOutput, self);
    }
}

static gchar *
qmi_message_nas_get_lte_cphy_ca_info_output_dl_bandwidth_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_DL_BANDWIDTH, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_DL_BANDWIDTH_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_dl_bandwidth_get_string ((QmiNasDLBandwidth)tmp));
#elif defined  __QMI_NAS_DL_BANDWIDTH_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_dl_bandwidth_build_string_from_mask ((QmiNasDLBandwidth)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasDLBandwidth
#endif
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_scell_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_SCELL_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " physical_cell_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rx_channel = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " dl_bandwidth = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_DL_BANDWIDTH_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_dl_bandwidth_get_string ((QmiNasDLBandwidth)tmp));
#elif defined  __QMI_NAS_DL_BANDWIDTH_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_dl_bandwidth_build_string_from_mask ((QmiNasDLBandwidth)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasDLBandwidth
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lte_band = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ACTIVE_BAND_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_active_band_get_string ((QmiNasActiveBand)tmp));
#elif defined  __QMI_NAS_ACTIVE_BAND_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_active_band_build_string_from_mask ((QmiNasActiveBand)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasActiveBand
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " state = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SCELL_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_scell_state_get_string ((QmiNasScellState)tmp));
#elif defined  __QMI_NAS_SCELL_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_scell_state_build_string_from_mask ((QmiNasScellState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasScellState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_pcell_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_PCELL_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " physical_cell_id = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rx_channel = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " dl_bandwidth = '");

    {
        guint32 tmp;

        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_DL_BANDWIDTH_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_dl_bandwidth_get_string ((QmiNasDLBandwidth)tmp));
#elif defined  __QMI_NAS_DL_BANDWIDTH_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_dl_bandwidth_build_string_from_mask ((QmiNasDLBandwidth)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasDLBandwidth
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " lte_band = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ACTIVE_BAND_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_active_band_get_string ((QmiNasActiveBand)tmp));
#elif defined  __QMI_NAS_ACTIVE_BAND_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_active_band_build_string_from_mask ((QmiNasActiveBand)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasActiveBand
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_lte_cphy_ca_info_output_scell_index_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_SCELL_INDEX, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_secondary_cells_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_SECONDARY_CELLS, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    {
        guint phy_ca_agg_secondary_cells_i;
        guint8 phy_ca_agg_secondary_cells_n_items;

        /* Read number of items in the array */
        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(phy_ca_agg_secondary_cells_n_items), &error))
            goto out;

        g_string_append (printable, "{");

        for (phy_ca_agg_secondary_cells_i = 0; phy_ca_agg_secondary_cells_i < phy_ca_agg_secondary_cells_n_items; phy_ca_agg_secondary_cells_i++) {
            g_string_append_printf (printable, " [%u] = '", phy_ca_agg_secondary_cells_i);
            g_string_append (printable, "[");
            g_string_append (printable, " physical_cell_id = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " rx_channel = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " dl_bandwidth = '");

            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_DL_BANDWIDTH_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_dl_bandwidth_get_string ((QmiNasDLBandwidth)tmp));
#elif defined  __QMI_NAS_DL_BANDWIDTH_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_dl_bandwidth_build_string_from_mask ((QmiNasDLBandwidth)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasDLBandwidth
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " lte_band = '");

            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_ACTIVE_BAND_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_active_band_get_string ((QmiNasActiveBand)tmp));
#elif defined  __QMI_NAS_ACTIVE_BAND_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_active_band_build_string_from_mask ((QmiNasActiveBand)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasActiveBand
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " state = '");

            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
                    goto out;
#if defined  __QMI_NAS_SCELL_STATE_IS_ENUM__
                g_string_append_printf (printable, "%s", qmi_nas_scell_state_get_string ((QmiNasScellState)tmp));
#elif defined  __QMI_NAS_SCELL_STATE_IS_FLAGS__
                {
                    g_autofree gchar *flags_str = NULL;

                    flags_str = qmi_nas_scell_state_build_string_from_mask ((QmiNasScellState)tmp);
                    g_string_append_printf (printable, "%s", flags_str);
                }
#else
# error unexpected public format: QmiNasScellState
#endif
            }
            g_string_append (printable, "'");
            g_string_append (printable, " cell_index = '");

            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
                    goto out;
                g_string_append_printf (printable, "%u", (guint)tmp);
            }
            g_string_append (printable, "'");
            g_string_append (printable, " ]");
            g_string_append (printable, " '");
        }

        g_string_append (printable, "}");
    }
    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_get_lte_cphy_ca_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_lte_cphy_ca_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_lte_cphy_ca_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_DL_BANDWIDTH:
            tlv_type_str = "DL Bandwidth";
            translated_value = qmi_message_nas_get_lte_cphy_ca_info_output_dl_bandwidth_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_SCELL_INFO:
            tlv_type_str = "Phy CA Agg SCell Info";
            translated_value = qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_scell_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_PCELL_INFO:
            tlv_type_str = "Phy CA Agg PCell Info";
            translated_value = qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_pcell_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_SCELL_INDEX:
            tlv_type_str = "SCell index";
            translated_value = qmi_message_nas_get_lte_cphy_ca_info_output_scell_index_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_SECONDARY_CELLS:
            tlv_type_str = "Phy CA Agg Secondary Cells";
            translated_value = qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_secondary_cells_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_get_lte_cphy_ca_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get LTE Cphy CA Info\" (0x00AC)\n",
                            line_prefix);

    {
        struct message_get_lte_cphy_ca_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_lte_cphy_ca_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetLteCphyCaInfoOutput *
__qmi_message_nas_get_lte_cphy_ca_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetLteCphyCaInfoOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO);

    self = g_slice_new0 (QmiMessageNasGetLteCphyCaInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_get_lte_cphy_ca_info_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_get_lte_cphy_ca_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_DL_BANDWIDTH, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_lte_cphy_ca_info_output_dl_bandwidth_out;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_lte_cphy_ca_info_output_dl_bandwidth_out;
                self->arg_dl_bandwidth = (QmiNasDLBandwidth)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'DL Bandwidth' TLV", offset);
            }

            self->arg_dl_bandwidth_set = TRUE;

qmi_message_nas_get_lte_cphy_ca_info_output_dl_bandwidth_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_SCELL_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_scell_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_phy_ca_agg_scell_info_physical_cell_id), NULL))
                goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_scell_info_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_phy_ca_agg_scell_info_rx_channel), NULL))
                goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_scell_info_out;
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_scell_info_out;
                self->arg_phy_ca_agg_scell_info_dl_bandwidth = (QmiNasDLBandwidth)tmp;
            }
            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_scell_info_out;
                self->arg_phy_ca_agg_scell_info_lte_band = (QmiNasActiveBand)tmp;
            }
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_scell_info_out;
                self->arg_phy_ca_agg_scell_info_state = (QmiNasScellState)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Phy CA Agg SCell Info' TLV", offset);
            }

            self->arg_phy_ca_agg_scell_info_set = TRUE;

qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_scell_info_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_PCELL_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_pcell_info_out;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_phy_ca_agg_pcell_info_physical_cell_id), NULL))
                goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_pcell_info_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_phy_ca_agg_pcell_info_rx_channel), NULL))
                goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_pcell_info_out;
            {
                guint32 tmp;

                if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_pcell_info_out;
                self->arg_phy_ca_agg_pcell_info_dl_bandwidth = (QmiNasDLBandwidth)tmp;
            }
            {
                guint16 tmp;

                if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                    goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_pcell_info_out;
                self->arg_phy_ca_agg_pcell_info_lte_band = (QmiNasActiveBand)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Phy CA Agg PCell Info' TLV", offset);
            }

            self->arg_phy_ca_agg_pcell_info_set = TRUE;

qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_pcell_info_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_SCELL_INDEX, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_lte_cphy_ca_info_output_scell_index_out;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_scell_index), NULL))
                goto qmi_message_nas_get_lte_cphy_ca_info_output_scell_index_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'SCell index' TLV", offset);
            }

            self->arg_scell_index_set = TRUE;

qmi_message_nas_get_lte_cphy_ca_info_output_scell_index_out:
            ;

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO_OUTPUT_TLV_PHY_CA_AGG_SECONDARY_CELLS, NULL, NULL)) == 0) {
                goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_secondary_cells_out;
            }
            {
                guint phy_ca_agg_secondary_cells_i;
                guint8 phy_ca_agg_secondary_cells_n_items;

                /* Read number of items in the array */
                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(phy_ca_agg_secondary_cells_n_items), NULL))
                    goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_secondary_cells_out;

                self->arg_phy_ca_agg_secondary_cells = g_array_sized_new (
                    FALSE,
                    FALSE,
                    sizeof (QmiMessageNasGetLteCphyCaInfoOutputPhyCaAggSecondaryCellsSsc),
                    (guint)phy_ca_agg_secondary_cells_n_items);

                for (phy_ca_agg_secondary_cells_i = 0; phy_ca_agg_secondary_cells_i < phy_ca_agg_secondary_cells_n_items; phy_ca_agg_secondary_cells_i++) {
                    QmiMessageNasGetLteCphyCaInfoOutputPhyCaAggSecondaryCellsSsc phy_ca_agg_secondary_cells_aux;

                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(phy_ca_agg_secondary_cells_aux.physical_cell_id), NULL))
                        goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_secondary_cells_out;
                    if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(phy_ca_agg_secondary_cells_aux.rx_channel), NULL))
                        goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_secondary_cells_out;
                    {
                        guint32 tmp;

                        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                            goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_secondary_cells_out;
                        phy_ca_agg_secondary_cells_aux.dl_bandwidth = (QmiNasDLBandwidth)tmp;
                    }
                    {
                        guint16 tmp;

                        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                            goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_secondary_cells_out;
                        phy_ca_agg_secondary_cells_aux.lte_band = (QmiNasActiveBand)tmp;
                    }
                    {
                        guint32 tmp;

                        if (!qmi_message_tlv_read_guint32 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, NULL))
                            goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_secondary_cells_out;
                        phy_ca_agg_secondary_cells_aux.state = (QmiNasScellState)tmp;
                    }
                    if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(phy_ca_agg_secondary_cells_aux.cell_index), NULL))
                        goto qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_secondary_cells_out;
                    g_array_insert_val (self->arg_phy_ca_agg_secondary_cells, phy_ca_agg_secondary_cells_i, phy_ca_agg_secondary_cells_aux);
                }
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Phy CA Agg Secondary Cells' TLV", offset);
            }

            self->arg_phy_ca_agg_secondary_cells_set = TRUE;

qmi_message_nas_get_lte_cphy_ca_info_output_phy_ca_agg_secondary_cells_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Swi Get Status */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_swi_get_status_request_create (
    guint16 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    g_autoptr(QmiMessage) self = NULL;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_SWI_GET_STATUS);

    return g_steal_pointer (&self);
}

/* --- Output -- */

struct _QmiMessageNasSwiGetStatusOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Common Info v2 */
    gboolean arg_common_info_v2_set;
    gint8 arg_common_info_v2_temperature;
    guint8 arg_common_info_v2_modem_mode;
    guint8 arg_common_info_v2_system_mode;
    guint8 arg_common_info_v2_ims_registration_state;
    guint8 arg_common_info_v2_packet_service_state;

    /* LTE Info */
    gboolean arg_lte_info_set;
    guint8 arg_lte_info_band;
    guint8 arg_lte_info_bandwidth;
    guint16 arg_lte_info_rx_channel;
    guint16 arg_lte_info_tx_channel;
    guint8 arg_lte_info_emm_state;
    guint8 arg_lte_info_emm_sub_state;
    guint8 arg_lte_info_emm_connection_state;
};

#define QMI_MESSAGE_NAS_SWI_GET_STATUS_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_SWI_GET_STATUS_OUTPUT_TLV_COMMON_INFO_V2 0x01
#define QMI_MESSAGE_NAS_SWI_GET_STATUS_OUTPUT_TLV_LTE_INFO 0x10

gboolean
qmi_message_nas_swi_get_status_output_get_result (
    QmiMessageNasSwiGetStatusOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

gboolean
qmi_message_nas_swi_get_status_output_get_common_info_v2 (
    QmiMessageNasSwiGetStatusOutput *self,
    gint8 *value_common_info_v2_temperature,
    QmiNasSwiModemMode *value_common_info_v2_modem_mode,
    QmiNasSwiSystemMode *value_common_info_v2_system_mode,
    QmiNasSwiImsRegState *value_common_info_v2_ims_registration_state,
    QmiNasSwiPsState *value_common_info_v2_packet_service_state,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_common_info_v2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Common Info v2' was not found in the message");
        return FALSE;
    }

    if (value_common_info_v2_temperature)
        *value_common_info_v2_temperature = self->arg_common_info_v2_temperature;
    if (value_common_info_v2_modem_mode)
        *value_common_info_v2_modem_mode = (QmiNasSwiModemMode)(self->arg_common_info_v2_modem_mode);
    if (value_common_info_v2_system_mode)
        *value_common_info_v2_system_mode = (QmiNasSwiSystemMode)(self->arg_common_info_v2_system_mode);
    if (value_common_info_v2_ims_registration_state)
        *value_common_info_v2_ims_registration_state = (QmiNasSwiImsRegState)(self->arg_common_info_v2_ims_registration_state);
    if (value_common_info_v2_packet_service_state)
        *value_common_info_v2_packet_service_state = (QmiNasSwiPsState)(self->arg_common_info_v2_packet_service_state);

    return TRUE;
}

gboolean
qmi_message_nas_swi_get_status_output_get_lte_info (
    QmiMessageNasSwiGetStatusOutput *self,
    QmiNasActiveBand *value_lte_info_band,
    QmiNasDLBandwidth *value_lte_info_bandwidth,
    guint16 *value_lte_info_rx_channel,
    guint16 *value_lte_info_tx_channel,
    QmiNasSwiEmmState *value_lte_info_emm_state,
    guint8 *value_lte_info_emm_sub_state,
    QmiNasSwiEmmConnectionState *value_lte_info_emm_connection_state,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Info' was not found in the message");
        return FALSE;
    }

    if (value_lte_info_band)
        *value_lte_info_band = (QmiNasActiveBand)(self->arg_lte_info_band);
    if (value_lte_info_bandwidth)
        *value_lte_info_bandwidth = (QmiNasDLBandwidth)(self->arg_lte_info_bandwidth);
    if (value_lte_info_rx_channel)
        *value_lte_info_rx_channel = self->arg_lte_info_rx_channel;
    if (value_lte_info_tx_channel)
        *value_lte_info_tx_channel = self->arg_lte_info_tx_channel;
    if (value_lte_info_emm_state)
        *value_lte_info_emm_state = (QmiNasSwiEmmState)(self->arg_lte_info_emm_state);
    if (value_lte_info_emm_sub_state)
        *value_lte_info_emm_sub_state = self->arg_lte_info_emm_sub_state;
    if (value_lte_info_emm_connection_state)
        *value_lte_info_emm_connection_state = (QmiNasSwiEmmConnectionState)(self->arg_lte_info_emm_connection_state);

    return TRUE;
}

GType
qmi_message_nas_swi_get_status_output_get_type (void)
{
    static gsize g_define_type_id_initialized = 0;

    if (g_once_init_enter (&g_define_type_id_initialized)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSwiGetStatusOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_swi_get_status_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_swi_get_status_output_unref);

        g_once_init_leave (&g_define_type_id_initialized, g_define_type_id);
    }

    return g_define_type_id_initialized;
}

QmiMessageNasSwiGetStatusOutput *
qmi_message_nas_swi_get_status_output_ref (QmiMessageNasSwiGetStatusOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

void
qmi_message_nas_swi_get_status_output_unref (QmiMessageNasSwiGetStatusOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasSwiGetStatusOutput, self);
    }
}

static gchar *
qmi_message_nas_swi_get_status_output_common_info_v2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SWI_GET_STATUS_OUTPUT_TLV_COMMON_INFO_V2, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " temperature = '");

    {
        gint8 tmp;

        if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%d", (gint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " modem_mode = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SWI_MODEM_MODE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_swi_modem_mode_get_string ((QmiNasSwiModemMode)tmp));
#elif defined  __QMI_NAS_SWI_MODEM_MODE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_swi_modem_mode_build_string_from_mask ((QmiNasSwiModemMode)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasSwiModemMode
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " system_mode = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SWI_SYSTEM_MODE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_swi_system_mode_get_string ((QmiNasSwiSystemMode)tmp));
#elif defined  __QMI_NAS_SWI_SYSTEM_MODE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_swi_system_mode_build_string_from_mask ((QmiNasSwiSystemMode)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasSwiSystemMode
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ims_registration_state = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SWI_IMS_REG_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_swi_ims_reg_state_get_string ((QmiNasSwiImsRegState)tmp));
#elif defined  __QMI_NAS_SWI_IMS_REG_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_swi_ims_reg_state_build_string_from_mask ((QmiNasSwiImsRegState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasSwiImsRegState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " packet_service_state = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SWI_PS_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_swi_ps_state_get_string ((QmiNasSwiPsState)tmp));
#elif defined  __QMI_NAS_SWI_PS_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_swi_ps_state_build_string_from_mask ((QmiNasSwiPsState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasSwiPsState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

static gchar *
qmi_message_nas_swi_get_status_output_lte_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    gsize offset = 0;
    gsize init_offset;
    GString *printable;
    GError *error = NULL;

    if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SWI_GET_STATUS_OUTPUT_TLV_LTE_INFO, NULL, NULL)) == 0)
        return NULL;

    printable = g_string_new ("");
    g_string_append (printable, "[");
    g_string_append (printable, " band = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_ACTIVE_BAND_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_active_band_get_string ((QmiNasActiveBand)tmp));
#elif defined  __QMI_NAS_ACTIVE_BAND_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_active_band_build_string_from_mask ((QmiNasActiveBand)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasActiveBand
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " bandwidth = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_DL_BANDWIDTH_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_dl_bandwidth_get_string ((QmiNasDLBandwidth)tmp));
#elif defined  __QMI_NAS_DL_BANDWIDTH_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_dl_bandwidth_build_string_from_mask ((QmiNasDLBandwidth)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasDLBandwidth
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " rx_channel = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " tx_channel = '");

    {
        guint16 tmp;

        if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " emm_state = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SWI_EMM_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_swi_emm_state_get_string ((QmiNasSwiEmmState)tmp));
#elif defined  __QMI_NAS_SWI_EMM_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_swi_emm_state_build_string_from_mask ((QmiNasSwiEmmState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasSwiEmmState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " emm_sub_state = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
        g_string_append_printf (printable, "%u", (guint)tmp);
    }
    g_string_append (printable, "'");
    g_string_append (printable, " emm_connection_state = '");

    {
        guint8 tmp;

        if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, &error))
            goto out;
#if defined  __QMI_NAS_SWI_EMM_CONNECTION_STATE_IS_ENUM__
        g_string_append_printf (printable, "%s", qmi_nas_swi_emm_connection_state_get_string ((QmiNasSwiEmmConnectionState)tmp));
#elif defined  __QMI_NAS_SWI_EMM_CONNECTION_STATE_IS_FLAGS__
        {
            g_autofree gchar *flags_str = NULL;

            flags_str = qmi_nas_swi_emm_connection_state_build_string_from_mask ((QmiNasSwiEmmConnectionState)tmp);
            g_string_append_printf (printable, "%s", flags_str);
        }
#else
# error unexpected public format: QmiNasSwiEmmConnectionState
#endif
    }
    g_string_append (printable, "'");
    g_string_append (printable, " ]");

    if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0)
        g_string_append_printf (printable, "Additional unexpected '%" G_GSIZE_FORMAT "' bytes", offset);

out:
    if (error) {
        g_string_append_printf (printable, " ERROR: %s", error->message);
        g_error_free (error);
    }
    return g_string_free (printable, FALSE);
}

struct message_swi_get_status_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_swi_get_status_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_swi_get_status_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    g_autofree gchar *translated_value = NULL;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_SWI_GET_STATUS_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SWI_GET_STATUS_OUTPUT_TLV_COMMON_INFO_V2:
            tlv_type_str = "Common Info v2";
            translated_value = qmi_message_nas_swi_get_status_output_common_info_v2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SWI_GET_STATUS_OUTPUT_TLV_LTE_INFO:
            tlv_type_str = "LTE Info";
            translated_value = qmi_message_nas_swi_get_status_output_lte_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        g_autofree gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
    } else {
        g_autofree gchar *value_hex = NULL;

        value_hex = qmi_helpers_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
    }
}

static gchar *
message_swi_get_status_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Swi Get Status\" (0x5556)\n",
                            line_prefix);

    {
        struct message_swi_get_status_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_swi_get_status_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasSwiGetStatusOutput *
__qmi_message_nas_swi_get_status_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasSwiGetStatusOutput *self;

    g_assert_cmphex (qmi_message_get_message_id (message), ==, QMI_MESSAGE_NAS_SWI_GET_STATUS);

    self = g_slice_new0 (QmiMessageNasSwiGetStatusOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SWI_GET_STATUS_OUTPUT_TLV_RESULT, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Result TLV: ");
                qmi_message_nas_swi_get_status_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_status), error))
                goto qmi_message_result_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_result.error_code), error))
                goto qmi_message_result_out;

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Result' TLV", offset);
            }

            self->arg_result_set = TRUE;

qmi_message_result_out:
            if (!self->arg_result_set) {
                qmi_message_nas_swi_get_status_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SWI_GET_STATUS_OUTPUT_TLV_COMMON_INFO_V2, NULL, error)) == 0) {
                g_prefix_error (error, "Couldn't get the mandatory Common Info v2 TLV: ");
                qmi_message_nas_swi_get_status_output_unref (self);
                return NULL;
            }
            if (!qmi_message_tlv_read_gint8 (message, init_offset, &offset, &(self->arg_common_info_v2_temperature), error))
                goto qmi_message_nas_swi_get_status_output_common_info_v2_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_message_nas_swi_get_status_output_common_info_v2_out;
                self->arg_common_info_v2_modem_mode = (QmiNasSwiModemMode)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_message_nas_swi_get_status_output_common_info_v2_out;
                self->arg_common_info_v2_system_mode = (QmiNasSwiSystemMode)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_message_nas_swi_get_status_output_common_info_v2_out;
                self->arg_common_info_v2_ims_registration_state = (QmiNasSwiImsRegState)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, error))
                    goto qmi_message_nas_swi_get_status_output_common_info_v2_out;
                self->arg_common_info_v2_packet_service_state = (QmiNasSwiPsState)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'Common Info v2' TLV", offset);
            }

            self->arg_common_info_v2_set = TRUE;

qmi_message_nas_swi_get_status_output_common_info_v2_out:
            if (!self->arg_common_info_v2_set) {
                qmi_message_nas_swi_get_status_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            gsize offset = 0;
            gsize init_offset;

            if ((init_offset = qmi_message_tlv_read_init (message, QMI_MESSAGE_NAS_SWI_GET_STATUS_OUTPUT_TLV_LTE_INFO, NULL, NULL)) == 0) {
                goto qmi_message_nas_swi_get_status_output_lte_info_out;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_swi_get_status_output_lte_info_out;
                self->arg_lte_info_band = (QmiNasActiveBand)tmp;
            }
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_swi_get_status_output_lte_info_out;
                self->arg_lte_info_bandwidth = (QmiNasDLBandwidth)tmp;
            }
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_info_rx_channel), NULL))
                goto qmi_message_nas_swi_get_status_output_lte_info_out;
            if (!qmi_message_tlv_read_guint16 (message, init_offset, &offset, QMI_ENDIAN_LITTLE, &(self->arg_lte_info_tx_channel), NULL))
                goto qmi_message_nas_swi_get_status_output_lte_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_swi_get_status_output_lte_info_out;
                self->arg_lte_info_emm_state = (QmiNasSwiEmmState)tmp;
            }
            if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &(self->arg_lte_info_emm_sub_state), NULL))
                goto qmi_message_nas_swi_get_status_output_lte_info_out;
            {
                guint8 tmp;

                if (!qmi_message_tlv_read_guint8 (message, init_offset, &offset, &tmp, NULL))
                    goto qmi_message_nas_swi_get_status_output_lte_info_out;
                self->arg_lte_info_emm_connection_state = (QmiNasSwiEmmConnectionState)tmp;
            }

            /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
            if ((offset = qmi_message_tlv_read_remaining_size (message, init_offset, offset)) > 0) {
                g_warning ("Left '%" G_GSIZE_FORMAT "' bytes unread when getting the 'LTE Info' TLV", offset);
            }

            self->arg_lte_info_set = TRUE;

qmi_message_nas_swi_get_status_output_lte_info_out:
            ;

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* Service-specific utils: NAS */


gchar *
__qmi_message_nas_get_printable (
    QmiMessage *self,
    QmiMessageContext *context,
    const gchar *line_prefix)
{
    if (qmi_message_is_indication (self)) {
        switch (qmi_message_get_message_id (self)) {
        case QMI_INDICATION_NAS_EVENT_REPORT:
            return indication_event_report_get_printable (self, line_prefix);
        case QMI_INDICATION_NAS_SERVING_SYSTEM:
            return indication_serving_system_get_printable (self, line_prefix);
        case QMI_INDICATION_NAS_OPERATOR_NAME:
            return indication_operator_name_get_printable (self, line_prefix);
        case QMI_INDICATION_NAS_NETWORK_TIME:
            return indication_network_time_get_printable (self, line_prefix);
        case QMI_INDICATION_NAS_SYSTEM_INFO:
            return indication_system_info_get_printable (self, line_prefix);
        case QMI_INDICATION_NAS_SIGNAL_INFO:
            return indication_signal_info_get_printable (self, line_prefix);
        case QMI_INDICATION_NAS_NETWORK_REJECT:
            return indication_network_reject_get_printable (self, line_prefix);
        default:
             return NULL;
        }
    } else {
        guint16 vendor_id;

        vendor_id = (context ? qmi_message_context_get_vendor_id (context) : QMI_MESSAGE_VENDOR_GENERIC);
        if (vendor_id == QMI_MESSAGE_VENDOR_GENERIC) {
            switch (qmi_message_get_message_id (self)) {
            case QMI_MESSAGE_NAS_RESET:
                return message_reset_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_ABORT:
                return message_abort_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_SET_EVENT_REPORT:
                return message_set_event_report_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_REGISTER_INDICATIONS:
                return message_register_indications_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_SUPPORTED_MESSAGES:
                return message_get_supported_messages_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH:
                return message_get_signal_strength_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_NETWORK_SCAN:
                return message_network_scan_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER:
                return message_initiate_network_register_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_ATTACH_DETACH:
                return message_attach_detach_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM:
                return message_get_serving_system_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_HOME_NETWORK:
                return message_get_home_network_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_PREFERRED_NETWORKS:
                return message_get_preferred_networks_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_SET_PREFERRED_NETWORKS:
                return message_set_preferred_networks_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE:
                return message_set_technology_preference_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE:
                return message_get_technology_preference_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION:
                return message_get_rf_band_information_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE:
                return message_set_system_selection_preference_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE:
                return message_get_system_selection_preference_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_OPERATOR_NAME:
                return message_get_operator_name_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_CELL_LOCATION_INFO:
                return message_get_cell_location_info_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_PLMN_NAME:
                return message_get_plmn_name_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_SYSTEM_INFO:
                return message_get_system_info_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_SIGNAL_INFO:
                return message_get_signal_info_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO:
                return message_config_signal_info_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_TX_RX_INFO:
                return message_get_tx_rx_info_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO:
                return message_get_cdma_position_info_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_FORCE_NETWORK_SEARCH:
                return message_force_network_search_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_DRX:
                return message_get_drx_get_printable (self, line_prefix);
            case QMI_MESSAGE_NAS_GET_LTE_CPHY_CA_INFO:
                return message_get_lte_cphy_ca_info_get_printable (self, line_prefix);
             default:
                 return NULL;
            }
        } else {
            if (vendor_id == 0x1199 && (qmi_message_get_message_id (self) == QMI_MESSAGE_NAS_SWI_GET_STATUS))
                return message_swi_get_status_get_printable (self, line_prefix);
            return NULL;
        }
    }
}

gboolean
__qmi_message_nas_is_abortable (
    QmiMessage *self,
    QmiMessageContext *context)
{
    guint16 vendor_id;

    vendor_id = (context ? qmi_message_context_get_vendor_id (context) : QMI_MESSAGE_VENDOR_GENERIC);
    if (vendor_id == QMI_MESSAGE_VENDOR_GENERIC) {
        switch (qmi_message_get_message_id (self)) {
        case QMI_MESSAGE_NAS_NETWORK_SCAN:
            return TRUE;
        default:
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

/*****************************************************************************/
/* CLIENT: QMI Client NAS */


/**
 * SECTION: qmi-client-nas
 * @title: QmiClientNas
 * @short_description: #QmiClient for the NAS service.
 *
 * #QmiClient which handles operations in the NAS service.
 */

G_DEFINE_TYPE (QmiClientNas, qmi_client_nas, QMI_TYPE_CLIENT)

enum {
    SIGNAL_EVENT_REPORT,
    SIGNAL_SERVING_SYSTEM,
    SIGNAL_OPERATOR_NAME,
    SIGNAL_NETWORK_TIME,
    SIGNAL_SYSTEM_INFO,
    SIGNAL_SIGNAL_INFO,
    SIGNAL_NETWORK_REJECT,
    SIGNAL_LAST
};

static guint signals[SIGNAL_LAST] = { 0 };

static void
process_indication (QmiClient *self,
                    QmiMessage *message)
{
    switch (qmi_message_get_message_id (message)) {
        case QMI_INDICATION_NAS_EVENT_REPORT: {
            QmiIndicationNasEventReportOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_event_report_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'Event Report' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_EVENT_REPORT], 0, output);
                qmi_indication_nas_event_report_output_unref (output);
            }
            break;
        }
        case QMI_INDICATION_NAS_SERVING_SYSTEM: {
            QmiIndicationNasServingSystemOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_serving_system_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'Serving System' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_SERVING_SYSTEM], 0, output);
                qmi_indication_nas_serving_system_output_unref (output);
            }
            break;
        }
        case QMI_INDICATION_NAS_OPERATOR_NAME: {
            QmiIndicationNasOperatorNameOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_operator_name_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'Operator Name' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_OPERATOR_NAME], 0, output);
                qmi_indication_nas_operator_name_output_unref (output);
            }
            break;
        }
        case QMI_INDICATION_NAS_NETWORK_TIME: {
            QmiIndicationNasNetworkTimeOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_network_time_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'Network Time' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_NETWORK_TIME], 0, output);
                qmi_indication_nas_network_time_output_unref (output);
            }
            break;
        }
        case QMI_INDICATION_NAS_SYSTEM_INFO: {
            QmiIndicationNasSystemInfoOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_system_info_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'System Info' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_SYSTEM_INFO], 0, output);
                qmi_indication_nas_system_info_output_unref (output);
            }
            break;
        }
        case QMI_INDICATION_NAS_SIGNAL_INFO: {
            QmiIndicationNasSignalInfoOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_signal_info_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'Signal Info' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_SIGNAL_INFO], 0, output);
                qmi_indication_nas_signal_info_output_unref (output);
            }
            break;
        }
        case QMI_INDICATION_NAS_NETWORK_REJECT: {
            QmiIndicationNasNetworkRejectOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_network_reject_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'Network Reject' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_NETWORK_REJECT], 0, output);
                qmi_indication_nas_network_reject_output_unref (output);
            }
            break;
        }
        default:
            break;
    }
}

static void
qmi_client_nas_init (QmiClientNas *self)
{
}

static void
qmi_client_nas_class_init (QmiClientNasClass *klass)
{
    QmiClientClass *client_class = QMI_CLIENT_CLASS (klass);

    client_class->process_indication = process_indication;

    /**
     * QmiClientNas::event-report:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasEventReportOutput.
     *
     * The ::event-report signal gets emitted when a '<link linkend="libqmi-glib-NAS-Event-Report-indication.top_of_page">Event Report</link>' indication is received.
     *
     * Since: 1.0
     */
    signals[SIGNAL_EVENT_REPORT] =
        g_signal_new ("event-report",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_EVENT_REPORT_OUTPUT);

    /**
     * QmiClientNas::serving-system:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasServingSystemOutput.
     *
     * The ::serving-system signal gets emitted when a '<link linkend="libqmi-glib-NAS-Serving-System-indication.top_of_page">Serving System</link>' indication is received.
     *
     * Since: 1.0
     */
    signals[SIGNAL_SERVING_SYSTEM] =
        g_signal_new ("serving-system",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_SERVING_SYSTEM_OUTPUT);

    /**
     * QmiClientNas::operator-name:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasOperatorNameOutput.
     *
     * The ::operator-name signal gets emitted when a '<link linkend="libqmi-glib-NAS-Operator-Name-indication.top_of_page">Operator Name</link>' indication is received.
     *
     * Since: 1.18
     */
    signals[SIGNAL_OPERATOR_NAME] =
        g_signal_new ("operator-name",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_OPERATOR_NAME_OUTPUT);

    /**
     * QmiClientNas::network-time:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasNetworkTimeOutput.
     *
     * The ::network-time signal gets emitted when a '<link linkend="libqmi-glib-NAS-Network-Time-indication.top_of_page">Network Time</link>' indication is received.
     *
     * Since: 1.0
     */
    signals[SIGNAL_NETWORK_TIME] =
        g_signal_new ("network-time",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_NETWORK_TIME_OUTPUT);

    /**
     * QmiClientNas::system-info:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasSystemInfoOutput.
     *
     * The ::system-info signal gets emitted when a '<link linkend="libqmi-glib-NAS-System-Info-indication.top_of_page">System Info</link>' indication is received.
     *
     * Since: 1.0
     */
    signals[SIGNAL_SYSTEM_INFO] =
        g_signal_new ("system-info",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_SYSTEM_INFO_OUTPUT);

    /**
     * QmiClientNas::signal-info:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasSignalInfoOutput.
     *
     * The ::signal-info signal gets emitted when a '<link linkend="libqmi-glib-NAS-Signal-Info-indication.top_of_page">Signal Info</link>' indication is received.
     *
     * Since: 1.0
     */
    signals[SIGNAL_SIGNAL_INFO] =
        g_signal_new ("signal-info",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_SIGNAL_INFO_OUTPUT);

    /**
     * QmiClientNas::network-reject:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasNetworkRejectOutput.
     *
     * The ::network-reject signal gets emitted when a '<link linkend="libqmi-glib-NAS-Network-Reject-indication.top_of_page">Network Reject</link>' indication is received.
     *
     * Since: 1.30
     */
    signals[SIGNAL_NETWORK_REJECT] =
        g_signal_new ("network-reject",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_NETWORK_REJECT_OUTPUT);
}


QmiMessageNasResetOutput *
qmi_client_nas_reset_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
reset_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasResetOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_reset_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_reset_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_reset (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_reset_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)reset_ready,
                             task);
}


QmiMessageNasSetEventReportOutput *
qmi_client_nas_set_event_report_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
set_event_report_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasSetEventReportOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_set_event_report_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_set_event_report_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_set_event_report (
    QmiClientNas *self,
    QmiMessageNasSetEventReportInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_set_event_report_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)set_event_report_ready,
                             task);
}


QmiMessageNasRegisterIndicationsOutput *
qmi_client_nas_register_indications_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
register_indications_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasRegisterIndicationsOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_register_indications_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_register_indications_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_register_indications (
    QmiClientNas *self,
    QmiMessageNasRegisterIndicationsInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_register_indications_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)register_indications_ready,
                             task);
}


QmiMessageNasGetSupportedMessagesOutput *
qmi_client_nas_get_supported_messages_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_supported_messages_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetSupportedMessagesOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_supported_messages_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_supported_messages_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_supported_messages (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_supported_messages_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_supported_messages_ready,
                             task);
}


QmiMessageNasGetSignalStrengthOutput *
qmi_client_nas_get_signal_strength_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_signal_strength_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetSignalStrengthOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_signal_strength_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_signal_strength_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_signal_strength (
    QmiClientNas *self,
    QmiMessageNasGetSignalStrengthInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_signal_strength_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_signal_strength_ready,
                             task);
}


QmiMessageNasNetworkScanOutput *
qmi_client_nas_network_scan_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

#if defined HAVE_QMI_MESSAGE_NAS_ABORT

static QmiMessage *
__qmi_message_nas_network_scan_abortable_build_request (
    QmiDevice   *self,
    QmiMessage  *message,
    QmiClient   *client,
    GError     **error)
{
    QmiMessage *abort_request;
    guint16 transaction_id;
    g_autoptr(QmiMessageNasAbortInput) input = NULL;

    transaction_id = qmi_message_get_transaction_id (message);
    g_assert (transaction_id != 0);

    input = qmi_message_nas_abort_input_new ();
    qmi_message_nas_abort_input_set_transaction_id (
        input,
        transaction_id,
        NULL);
    abort_request = __qmi_message_nas_abort_request_create (
                        qmi_client_get_next_transaction_id (client),
                        qmi_client_get_cid (client),
                        input,
                        NULL);
    return abort_request;
}

static gboolean
__qmi_message_nas_network_scan_abortable_parse_response (
    QmiDevice   *self,
    QmiMessage  *abort_response,
    QmiClient   *client,
    GError     **error)
{
    g_autoptr(QmiMessageNasAbortOutput) output = NULL;

    output = __qmi_message_nas_abort_response_parse (
               abort_response,
               error);
    return !!output;
}

#endif /* HAVE_QMI_MESSAGE_NAS_ABORT */


static void
network_scan_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasNetworkScanOutput *output;

    reply = qmi_device_command_abortable_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_network_scan_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_network_scan_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_network_scan (
    QmiClientNas *self,
    QmiMessageNasNetworkScanInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_network_scan_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_abortable (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
#if defined HAVE_QMI_MESSAGE_NAS_ABORT
                             (QmiDeviceCommandAbortableBuildRequestFn)  __qmi_message_nas_network_scan_abortable_build_request,
                             (QmiDeviceCommandAbortableParseResponseFn) __qmi_message_nas_network_scan_abortable_parse_response,
                             g_object_ref (self),
                             g_object_unref,
#else
                             NULL,
                             NULL,
                             NULL,
                             NULL,
#endif
                             cancellable,
                             (GAsyncReadyCallback)network_scan_ready,
                             task);
}


QmiMessageNasInitiateNetworkRegisterOutput *
qmi_client_nas_initiate_network_register_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
initiate_network_register_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasInitiateNetworkRegisterOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_initiate_network_register_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_initiate_network_register_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_initiate_network_register (
    QmiClientNas *self,
    QmiMessageNasInitiateNetworkRegisterInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_initiate_network_register_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)initiate_network_register_ready,
                             task);
}


QmiMessageNasAttachDetachOutput *
qmi_client_nas_attach_detach_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
attach_detach_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasAttachDetachOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_attach_detach_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_attach_detach_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_attach_detach (
    QmiClientNas *self,
    QmiMessageNasAttachDetachInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_attach_detach_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)attach_detach_ready,
                             task);
}


QmiMessageNasGetServingSystemOutput *
qmi_client_nas_get_serving_system_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_serving_system_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetServingSystemOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_serving_system_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_serving_system_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_serving_system (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_serving_system_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_serving_system_ready,
                             task);
}


QmiMessageNasGetHomeNetworkOutput *
qmi_client_nas_get_home_network_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_home_network_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetHomeNetworkOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_home_network_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_home_network_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_home_network (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_home_network_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_home_network_ready,
                             task);
}


QmiMessageNasGetPreferredNetworksOutput *
qmi_client_nas_get_preferred_networks_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_preferred_networks_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetPreferredNetworksOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_preferred_networks_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_preferred_networks_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_preferred_networks (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_preferred_networks_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_preferred_networks_ready,
                             task);
}


QmiMessageNasSetPreferredNetworksOutput *
qmi_client_nas_set_preferred_networks_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
set_preferred_networks_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasSetPreferredNetworksOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_set_preferred_networks_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_set_preferred_networks_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_set_preferred_networks (
    QmiClientNas *self,
    QmiMessageNasSetPreferredNetworksInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_set_preferred_networks_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)set_preferred_networks_ready,
                             task);
}


QmiMessageNasSetTechnologyPreferenceOutput *
qmi_client_nas_set_technology_preference_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
set_technology_preference_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasSetTechnologyPreferenceOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_set_technology_preference_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_set_technology_preference_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_set_technology_preference (
    QmiClientNas *self,
    QmiMessageNasSetTechnologyPreferenceInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_set_technology_preference_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)set_technology_preference_ready,
                             task);
}


QmiMessageNasGetTechnologyPreferenceOutput *
qmi_client_nas_get_technology_preference_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_technology_preference_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetTechnologyPreferenceOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_technology_preference_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_technology_preference_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_technology_preference (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_technology_preference_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_technology_preference_ready,
                             task);
}


QmiMessageNasGetRfBandInformationOutput *
qmi_client_nas_get_rf_band_information_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_rf_band_information_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetRfBandInformationOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_rf_band_information_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_rf_band_information_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_rf_band_information (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_rf_band_information_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_rf_band_information_ready,
                             task);
}


QmiMessageNasSetSystemSelectionPreferenceOutput *
qmi_client_nas_set_system_selection_preference_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
set_system_selection_preference_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasSetSystemSelectionPreferenceOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_set_system_selection_preference_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_set_system_selection_preference_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_set_system_selection_preference (
    QmiClientNas *self,
    QmiMessageNasSetSystemSelectionPreferenceInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_set_system_selection_preference_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)set_system_selection_preference_ready,
                             task);
}


QmiMessageNasGetSystemSelectionPreferenceOutput *
qmi_client_nas_get_system_selection_preference_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_system_selection_preference_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetSystemSelectionPreferenceOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_system_selection_preference_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_system_selection_preference_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_system_selection_preference (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_system_selection_preference_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_system_selection_preference_ready,
                             task);
}


QmiMessageNasGetOperatorNameOutput *
qmi_client_nas_get_operator_name_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_operator_name_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetOperatorNameOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_operator_name_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_operator_name_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_operator_name (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_operator_name_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_operator_name_ready,
                             task);
}


QmiMessageNasGetCellLocationInfoOutput *
qmi_client_nas_get_cell_location_info_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_cell_location_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetCellLocationInfoOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_cell_location_info_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_cell_location_info_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_cell_location_info (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_cell_location_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_cell_location_info_ready,
                             task);
}


QmiMessageNasGetPlmnNameOutput *
qmi_client_nas_get_plmn_name_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_plmn_name_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetPlmnNameOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_plmn_name_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_plmn_name_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_plmn_name (
    QmiClientNas *self,
    QmiMessageNasGetPlmnNameInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_plmn_name_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_plmn_name_ready,
                             task);
}


QmiMessageNasGetSystemInfoOutput *
qmi_client_nas_get_system_info_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_system_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetSystemInfoOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_system_info_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_system_info_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_system_info (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_system_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_system_info_ready,
                             task);
}


QmiMessageNasGetSignalInfoOutput *
qmi_client_nas_get_signal_info_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_signal_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetSignalInfoOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_signal_info_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_signal_info_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_signal_info (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_signal_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_signal_info_ready,
                             task);
}


QmiMessageNasConfigSignalInfoOutput *
qmi_client_nas_config_signal_info_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
config_signal_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasConfigSignalInfoOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_config_signal_info_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_config_signal_info_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_config_signal_info (
    QmiClientNas *self,
    QmiMessageNasConfigSignalInfoInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_config_signal_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)config_signal_info_ready,
                             task);
}


QmiMessageNasGetTxRxInfoOutput *
qmi_client_nas_get_tx_rx_info_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_tx_rx_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetTxRxInfoOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_tx_rx_info_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_tx_rx_info_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_tx_rx_info (
    QmiClientNas *self,
    QmiMessageNasGetTxRxInfoInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_tx_rx_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_tx_rx_info_ready,
                             task);
}


QmiMessageNasGetCdmaPositionInfoOutput *
qmi_client_nas_get_cdma_position_info_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_cdma_position_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetCdmaPositionInfoOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_cdma_position_info_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_cdma_position_info_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_cdma_position_info (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_cdma_position_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_cdma_position_info_ready,
                             task);
}


QmiMessageNasForceNetworkSearchOutput *
qmi_client_nas_force_network_search_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
force_network_search_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasForceNetworkSearchOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_force_network_search_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_force_network_search_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_force_network_search (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_force_network_search_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)force_network_search_ready,
                             task);
}


QmiMessageNasGetDrxOutput *
qmi_client_nas_get_drx_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_drx_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetDrxOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_drx_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_drx_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_drx (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_drx_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_drx_ready,
                             task);
}


QmiMessageNasGetLteCphyCaInfoOutput *
qmi_client_nas_get_lte_cphy_ca_info_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
get_lte_cphy_ca_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetLteCphyCaInfoOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_lte_cphy_ca_info_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_get_lte_cphy_ca_info_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_get_lte_cphy_ca_info (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_lte_cphy_ca_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             NULL,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)get_lte_cphy_ca_info_ready,
                             task);
}


QmiMessageNasSwiGetStatusOutput *
qmi_client_nas_swi_get_status_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   return g_task_propagate_pointer (G_TASK (res), error);
}

static void
swi_get_status_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GTask *task)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasSwiGetStatusOutput *output;

    reply = qmi_device_command_full_finish (device, res, &error);
    if (!reply) {
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_swi_get_status_response_parse (reply, &error);
    if (!output)
        g_task_return_error (task, error);
    else
        g_task_return_pointer (task,
                               output,
                               (GDestroyNotify)qmi_message_nas_swi_get_status_output_unref);
    g_object_unref (task);
    qmi_message_unref (reply);
}

void
qmi_client_nas_swi_get_status (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GTask *task;
    GError *error = NULL;
    guint16 transaction_id;
    g_autoptr(QmiMessage) request = NULL;
    g_autoptr(QmiMessageContext) context = NULL;

    task = g_task_new (self, cancellable, callback, user_data);
    if (!qmi_client_is_valid (QMI_CLIENT (self))) {
        g_task_return_new_error (task, QMI_CORE_ERROR, QMI_CORE_ERROR_WRONG_STATE, "client invalid");
        g_object_unref (task);
        return;
    }

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_swi_get_status_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_task_return_error (task, error);
        g_object_unref (task);
        return;
    }

    context = qmi_message_context_new ();
    qmi_message_context_set_vendor_id (context, 0x1199);

    qmi_device_command_full (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                             request,
                             context,
                             timeout,
                             cancellable,
                             (GAsyncReadyCallback)swi_get_status_ready,
                             task);
}

